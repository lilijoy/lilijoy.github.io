<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.2/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","images":"/images","scheme":"Pisces","version":"8.2.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>
<meta name="description" content="计算机系统概述 冯诺依曼计算机特点：  计算机由五大部件组成 指令和数据以同等地位存储 指令和数据用二进制表示 指令由操作码和地址码组成 存储程序 以运算器为中心">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机组成原理框架和重点">
<meta property="og:url" content="http://example.com/2021/03/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E6%A1%86%E6%9E%B6%E5%92%8C%E9%87%8D%E7%82%B9/index.html">
<meta property="og:site_name" content="lilijoy">
<meta property="og:description" content="计算机系统概述 冯诺依曼计算机特点：  计算机由五大部件组成 指令和数据以同等地位存储 指令和数据用二进制表示 指令由操作码和地址码组成 存储程序 以运算器为中心">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.hualigs.cn/image/605a9d3639c59.jpg">
<meta property="og:image" content="https://www.hualigs.cn/image/605df8c321686.jpg">
<meta property="og:image" content="https://www.hualigs.cn/image/605ef6f2d35c4.jpg">
<meta property="og:image" content="https://www.hualigs.cn/image/60601fd0007b0.jpg">
<meta property="og:image" content="https://www.hualigs.cn/image/606076e7e826d.jpg">
<meta property="og:image" content="https://www.hualigs.cn/image/60609d767effd.jpg">
<meta property="article:published_time" content="2021-03-24T02:01:46.000Z">
<meta property="article:modified_time" content="2021-04-02T04:43:27.739Z">
<meta property="article:author" content="Li Jing">
<meta property="article:tag" content="计组">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.hualigs.cn/image/605a9d3639c59.jpg">


<link rel="canonical" href="http://example.com/2021/03/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E6%A1%86%E6%9E%B6%E5%92%8C%E9%87%8D%E7%82%B9/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<title>计算机组成原理框架和重点 | lilijoy</title>
  




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">lilijoy</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">计算机系统概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="nav-number">1.1.</span> <span class="nav-text">计算机系统层次结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97"><span class="nav-number">1.2.</span> <span class="nav-text">定点数的表示和运算</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97"><span class="nav-number">1.3.</span> <span class="nav-text">浮点数的表示与运算</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F"><span class="nav-number">2.</span> <span class="nav-text">存储系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E4%B8%8ECPU%E8%BF%9E%E6%8E%A5"><span class="nav-number">2.1.</span> <span class="nav-text">主存储器与CPU连接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8C%E7%AB%AF%E5%8F%A3RAM%E5%92%8C%E5%A4%9A%E6%A8%A1%E5%9D%97%E5%AD%98%E5%82%A8%E5%99%A8"><span class="nav-number">2.2.</span> <span class="nav-text">双端口RAM和多模块存储器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E9%80%9F%E7%BC%93%E5%86%B2%E5%AD%98%E5%82%A8%E5%99%A8"><span class="nav-number">2.3.</span> <span class="nav-text">高速缓冲存储器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8"><span class="nav-number">2.4.</span> <span class="nav-text">虚拟存储器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F"><span class="nav-number">3.</span> <span class="nav-text">指令系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E7%9A%84%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="nav-number">3.1.</span> <span class="nav-text">指令的寻址方式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8"><span class="nav-number">4.</span> <span class="nav-text">中央处理器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="nav-number">4.1.</span> <span class="nav-text">指令执行过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E5%8A%9F%E8%83%BD%E5%92%8C%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">4.2.</span> <span class="nav-text">控制器的功能和工作原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="nav-number">4.3.</span> <span class="nav-text">指令流水线</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Li Jing</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">28</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E6%A1%86%E6%9E%B6%E5%92%8C%E9%87%8D%E7%82%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Li Jing">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lilijoy">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          计算机组成原理框架和重点
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-03-24 10:01:46" itemprop="dateCreated datePublished" datetime="2021-03-24T10:01:46+08:00">2021-03-24</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-04-02 12:43:27" itemprop="dateModified" datetime="2021-04-02T12:43:27+08:00">2021-04-02</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/408/" itemprop="url" rel="index"><span itemprop="name">408</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="计算机系统概述"><a href="#计算机系统概述" class="headerlink" title="计算机系统概述"></a>计算机系统概述</h1><p><img src="https://www.hualigs.cn/image/605a9d3639c59.jpg"></p>
<p>冯诺依曼计算机特点：</p>
<ul>
<li>计算机由五大部件组成</li>
<li>指令和数据以<strong>同等地位</strong>存储</li>
<li>指令和数据用<strong>二进制</strong>表示</li>
<li>指令由<strong>操作码和地址码</strong>组成</li>
<li>存储程序</li>
<li>以运算器为中心</li>
</ul>
<span id="more"></span>

<p>软件和硬件的区别：</p>
<p>软件和硬件具有逻辑上的等效性，硬件实现具有更高的执行速度，软件实现具有更好的灵活性。执行频繁硬件实现代价不高的功能通常用硬件实现</p>
<h2 id="计算机系统层次结构"><a href="#计算机系统层次结构" class="headerlink" title="计算机系统层次结构"></a>计算机系统层次结构</h2><ol>
<li>完整的计算机系统应该包括配套的硬件设备和软件系统。</li>
</ol>
<p>只写运算器、存储器、控制器等是不完整的</p>
<ol start="2">
<li>冯诺依曼的基本工作方式是==控制流驱动方式==。</li>
<li>冯诺依曼计算机中指令和数据均以二进制形式存放在存储器中，CPU区分它们的依据是==指令周期的不同阶段==</li>
</ol>
<p>通常取指阶段取出的是指令，执行阶段取出的是数据</p>
<ol start="4">
<li>存放欲执行指令的寄存器是IR，存放下一条指令地址(跟踪下一条指令的地址）是PC</li>
<li>MAR、MDR的位数分别为地址码长度、存储字长</li>
<li>系列机的基本特性是指令向后兼容，即高版本可以执行低版本指令</li>
<li>计算机硬件能后直接执行的==只有==机器语言程序</li>
</ol>
<p>##计算机性能和指标</p>
<ol>
<li>汇编程序员可以通过指定待执行命令地址来设置PC的值，状态寄存器、通用寄存器使用汇编语言可见，而IR、MAR、MDR都是不透明的</li>
</ol>
<p>只有指令寄存器是完全透明的</p>
<ol start="2">
<li>时钟周期是计算机操作的最小单位时间</li>
<li>当前设计高性能计算机的重要技术途径是采用并行处理技术</li>
<li>评价计算机系统性能的综合参数是吞吐率</li>
<li>兼容指计算机软件或硬件的通用性，通常在同一系列不同型号的计算机间通用</li>
</ol>
<hr>
<p>#数据表示和运算</p>
<ol>
<li>国际通用的ASCII码是由7位二进制代码表示的，从0000000到1111111共128种编码，大写字母在英文字母前</li>
<li>数据的小端方案存储是指将最低有效字节存储在最小位置</li>
</ol>
<h2 id="定点数的表示和运算"><a href="#定点数的表示和运算" class="headerlink" title="定点数的表示和运算"></a>定点数的表示和运算</h2><ul>
<li><p>对0的处理：原码和反码有+0和-0，补码和移码只有一个0，补码的1000表示-7</p>
</li>
<li><p>原码表示的数据个数：2^n-1^-1个，补码能表示的最大负数是==-2^n-1^==</p>
</li>
<li><p>N位(不考虑符号位)2进制补码小数可以表示的数的个数为2^N^,N位十进制小数可以表示的数的个数为10^N^</p>
</li>
<li><p>==使用补码表示时，若符号位相同，则数值位越大码值越大==(正数补码是本身所以正数也成立，可以用于判断当补码需要满足某个范围时x的取值)</p>
</li>
<li><p><strong>模2补码和模4补码：</strong></p>
<p>​    模4补码具有模2补码的全部优点且更易检查加减运算中的溢出问题；存储模4补码仅需要一个符号位，因为任意一个正确的数值，模4补码的两个符号位总是相同的；只有在把两个模4补码的数送往ALU进行加减运算时，才把每个数的符号位的值同时送到ALU的双符号位中，即只在ALU中采取双符号位。</p>
</li>
<li><p><strong>溢出的三种判断方法</strong>：一位符号位(参加操作的两个数符号相同，结果与他们符号不同)、双符号位(某个数只有单符号位时可以直接将该位复制后进行判断，01正溢出10负溢出)、进位判断(符号位进位异或最高数位进位)</p>
</li>
<li><p><strong>乘除法：</strong>原码乘法符号位与数值位分开，最低位为1则加x后右移，最低位为0则加0后右移；补码乘法符号位则需要参与运算；原码除法单独计算符号位，补码除法一起计算</p>
</li>
<li><p>原码乘法移位和加法都是最多n次，补码一位乘法中，最多需要n次移位，n+1次加法</p>
</li>
<li><p>计算机中，通常用于表示主存地址的是无符号数</p>
</li>
<li><p><strong>逻辑移位和算术移位</strong>：逻辑移位左移和右移都补0，且所有数字移动；算术移位赌好玩不参加移位，右移补符号位，左移补0</p>
</li>
<li><p><strong>边界对齐</strong>：数据按边界对齐方式存储时，所有半字、字等占据的都是机器字长位数；如机器字长为32位时，则int占32位(一个机器字长);short定义的值会占据16位后，将剩下的16位填充，不用于写后面的数据，计算后面数据的地址是必须考虑到；</p>
</li>
</ul>
<h2 id="浮点数的表示与运算"><a href="#浮点数的表示与运算" class="headerlink" title="浮点数的表示与运算"></a>浮点数的表示与运算</h2><ul>
<li><p>浮点数表示中基数越大，范围越大，精度越低(变稀疏)；阶码越长范围越大；尾数越长精度越高</p>
</li>
<li><p>在浮点数编码表示中，==基数==在机器数中不出现是隐含的(一般是约定好的)</p>
</li>
<li><p>采用规格化浮点数最主要是为了增加数据的表示精度(规格化本质是使尾数最高位数是有效值)</p>
</li>
<li><p><strong>怎样判断数字是否规格化</strong></p>
<p>原码表示：0.1 1.1  尾数第一位为1  基数为2^n^时则尾数前n为必须有一个1  补码表示 0.1 1.0 尾数第一位与符号位相反  IEEE:   1.1 隐含1 尾数首位为1</p>
</li>
<li><p><strong>IEEE 754单精度浮点数格式</strong>：1数符+8移码+23尾数</p>
<p>该移码与一般的移码(补码符号位取反)有所不同，计算方式应该是原码+127；如3的移码为10000010</p>
</li>
<li><p><strong>IEEE 754最大值</strong>：尾数全取1时最大，此时尾数为1.1111111…小数点后23个1则可以表示为2-2^-23^,阶数为移码，最大为127,因此最大值为(2-2^-23^)*2^127^=2^128^-2^104^</p>
</li>
<li><p><strong>IEEE 754正数最小值</strong>：移码范围是1~254，阶码的值范围为-126到127,则最小的规格化正数为1.0*2^-126^</p>
</li>
<li><p>浮点运算中的上溢是指运算结果的==绝对值==大于机器所能表示的最大绝对值，下溢是结果绝对值小于最小绝对值</p>
</li>
<li><p><strong>对阶：</strong>小阶向大阶看齐，将阶码小的尾数右移，直到两个阶码相等，右移存在舍入问题</p>
</li>
<li><p><strong>移位</strong>：补码表示时，正数的符号位为0，左移最高位为0时数据不会丢失，负数符号位和左移最高位为1时数据不会丢失，即左移移走的最高位要与符号位相同；双符号位时，最高符号位代表真正的符号，低位符号用于参与移位操作以判断是否发生溢出，结果01表示结果正溢出，10表示结果负溢出</p>
</li>
<li><p><strong>舍入：</strong>只有浮点数需要考虑舍入的问题，定点数不需要；浮点数舍入的情况有两种：对阶和右规格化；舍入不一定产生误差，如11.000舍入到11.00没有误差  舍入包括0舍1入法和恒置1法。</p>
</li>
<li><p><strong>类型转换：</strong>double包容性最强，一般其他的转过去都不会有损失。float和int位数相同，但float包括阶数和尾数，表示的范围大但是精度低</p>
</li>
<li><p><strong>为什么要用移码表示阶码？</strong></p>
</li>
</ul>
<ol>
<li>浮点数进行加减运算经常需要比较阶码的大小，使用移码比较大小很方便</li>
<li>检验移码的特殊值容易，移码的特殊值分别是全0和全1，全0表示阶码为负无穷，相当于分母无穷大，整个数无限接近0，若尾数也为0则可以表示0；全1表示指数正无穷大，若尾数为0表示正负无穷，尾数不为0则表示运算错误</li>
</ol>
<h1 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a>存储系统</h1><p>计算机有多级存储系统：</p>
<p>CPU</p>
<hr>
<p>寄存器</p>
<p>Cache  </p>
<p>主存</p>
<p>磁盘</p>
<p>磁带  光盘</p>
<hr>
<p>Cache-主存 解决CPU与主存数据不匹配的问题</p>
<p>主存-辅存  解决存储系统的容量问题，形成了虚拟存储系统</p>
<p>主要思想是上一级存储器作为低一层存储器的高速缓存</p>
<p>##存储器</p>
<ul>
<li><p>存储器按存取方式分类可以分为**顺序存储(磁带)、直接存储(磁盘、光盘)、随机存储;**直接存储器既不像RAM那样随机的访问任何一个存储单元，又不像顺序存储那样完全按顺序存储，介于两者之间</p>
</li>
<li><p>注意单位换算 1MB=1024KB=2^10^ KB=2^20^B 如： 机器字长=64位=8B  按字编址=8B一个存储单元</p>
</li>
<li><p><strong>怎样计算RAM芯片的引脚数目？</strong></p>
<p>例：芯片容量为1024*8位，则芯片容量为1024B，且以字节为单位进行存取，所以需要10根地址线(1024B=2^10^B), 8位说明数据线需要8根，加上片选线1根和读写控制线2根，一共需要21根</p>
<p>注意：读写控制线有时只需要一根，需要看题目说明</p>
</li>
<li><p>RAM和ROM：</p>
<p>RAM是随机存储器；具有易失性；包括SRAM(触发器、不需要刷新、Cache)、DRAM(电容、刷新、主存)</p>
<p>ROM是只读存储器；具有非易失性；MROM、PROM、EPROM、Flash(U盘)、SSD固态硬盘</p>
<p>都采用随机存取的方式进行信息访问</p>
</li>
</ul>
<h2 id="主存储器与CPU连接"><a href="#主存储器与CPU连接" class="headerlink" title="主存储器与CPU连接"></a>主存储器与CPU连接</h2><ul>
<li>地址分配：</li>
</ul>
<p>例：用若干2k×4位的芯片组成一个8k×8位的存储器，地址如何划分？0B1FH所在芯片最小地址为？</p>
<p>每行两个芯片，每列4个芯片，地址分配如下：</p>
<p>第一行：0000H~07FFH</p>
<p>第二行：0800H~0FFFH</p>
<p>第三行：1000H~17FFH</p>
<p>第四行：1800H~1FFFH</p>
<p>0B1FH在第二行，最小地址为0800H</p>
<ul>
<li>MAR位数：只与主存储器容量有关，如64MB=2^26^B, MAR位数即为26，与主存实际大小无关(可能会拓展)</li>
<li>确定地址线实例</li>
</ul>
<p><img src="https://www.hualigs.cn/image/605df8c321686.jpg"></p>
<ul>
<li><p>设计DRAM芯片：</p>
<p>保证地址引脚数最少：采用行列地址线复用的方式，32*64只需要6根地址线</p>
<p>减少刷新开销：减小行数</p>
</li>
</ul>
<h2 id="双端口RAM和多模块存储器"><a href="#双端口RAM和多模块存储器" class="headerlink" title="双端口RAM和多模块存储器"></a>双端口RAM和多模块存储器</h2><ul>
<li><p>四位：四个存储器  高位交叉：顺序方式，一个存储器一个存储器排序  低位交叉：交叉方式，轮流编号</p>
</li>
<li><p><strong>例题：</strong>四位低位交叉存储器  ①读取6个连续地址单元中存放的存储字，重复80次②读取8个连续地址单元中存放的存储字，重复60次  其中①②所花费的时间之比为4:3</p>
<blockquote>
<p>情况②中第一轮可以按顺序读取完6个字，花费时间为3/2 T,但是重复第二次的时候，第一次的最后一次读取使用了M1还处于占用状态，必须等待1/2 T的时间，即共2T时间进入下一轮</p>
<p>情况②直接依次读完8个字并继续下一轮，不存在等待情况，每轮仍然需要2T时间</p>
<p>因此花费时间之比=80:60=4:3</p>
</blockquote>
</li>
<li><p><strong>例题：</strong>某计算机主存按字节编址, 由4个64M*8位的DRAM芯片采用交叉编址方式构成，并与宽度为32位的存储器总线相连，主存每次最多读写32位数据。若double型变量x的主存地址为804001AH，则读取x需要的存储周期数是()</p>
<blockquote>
<p>double型：64位  4个DRAM：一个存储周期可以读4个字节的数据  地址为804001A，末两位为10，说明从编号为2的芯片开始存储，因此需要3个存储周期</p>
<p>总线是32位，则每次连续读出32位数据，第一次实质上读出是模块2模块3的数据 第二次是0123 第三次是01 才能读出所有数据，共3次周期</p>
</blockquote>
</li>
</ul>
<h2 id="高速缓冲存储器"><a href="#高速缓冲存储器" class="headerlink" title="高速缓冲存储器"></a>高速缓冲存储器</h2><p>这一章看似不难理解，实际做题很需要细节，对地址的各位理解也要求较高；</p>
<ul>
<li><p>主存块和cache的块必须大小相同，有时候题目不会告诉cach块的大小。</p>
</li>
<li><p>直接映射的地址结构为：标记+行号+块内地址</p>
</li>
<li><p><strong>例题：直接映射</strong></p>
</li>
<li><p>某 32 位计算机的 cache 容量为 16KB，cache 块的大小为 16B，若主存与 cache 的地址映射采用直接映射方式，则主存地址为 1234E8F8（十六进制）的单元装入的 cache 地址为C。</p>
<p>A. 00 0100 0100 1101 (二进制)<br>B. 01 0010 0011 0100 (二进制)<br>C. 10 1000 1111 1000 (二进制)<br>D. 11 0100 1110 1000 (二进制)</p>
<blockquote>
<p>解：Cache大小为16KB，块大小为16B，所以Cache被分成16KB/16B=1024块，因210＝1024故需要10位来表示块数。</p>
<p>24＝16故块内地址需要4位来表示。所以Cache的地址线位置为14位。</p>
<p>由于采用直接映像的方式，所以==主存的后14位就是要装入的到Cache中的位置==。故选 C.</p>
</blockquote>
</li>
<li><p><strong>例题：直接映射读数据</strong></p>
</li>
<li><p>有如下C语言程序段： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for(int k &#x3D; 0; k &lt; 1000; k++)</span><br><span class="line">&#123;</span><br><span class="line">    a[k] &#x3D; a[k]+32;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若数组a以及变量k均为int型，int型数据占4B，数据Cache采用直接映射 方式，数据区大小是1KB，块大小是16B，该程序段执行前Cache为空，则该程序段执行过程中，访问数组a的Cache的缺失率是：C <br>A. 1.25% <br>B. 2.5% <br>C. 12.5% <br>D. 25%</p>
<blockquote>
<p>首先读取a[k]需要访问一次a[k],之后将结果复制给a[k]需要访问一次，共访问两次</p>
<p>本题中一个数据占4B，一个块大小是16B，这说明一个块中有4个数据;</p>
<p>主存和块之间==按块==传数据，所以第一次读a[0]没找到，去主存中调数据时，实际是一次调了一个块的数据（4个int，即a[0]到a[3]）进cache。所以后面读写a[1]到a[3]时都已经在cache中了，算命中了 </p>
<p>因此前8次读顺序可以理解为读0 读0 读1 读1 读2 读2 读3 读3 ，读0的时候就将0.1.2.3的数据全部放入了cache，第一次无法命中，后续的7个操作全部命中，缺失率为1/8=12.5%</p>
</blockquote>
</li>
<li><p>全相联映射的地址结构：标记+块内地址  存储数据是以块为单位的，因此同一标记的内容会被一次读入到同一块中；后续访问这一标记的其他内容也视为命中</p>
</li>
<li><p>组相联映射的地址结构为：标记+组号+块内地址；标记一般是内存块号的前k位，k由地址总位数和后两部分所占位数决定；主存地址由三部分组成，存储对应的Cache块信息，而Cache存储的是标记+数据，标记用于判断命中。</p>
</li>
<li><p><strong>例题：相联映射</strong></p>
</li>
<li><p>某计算机的Cache共有16块，采用2路组相联映射方式(即每组2块)。每个主存块大小为32字节，按字节编址。主存129号单元所在主存块应装入到的Cache组号是( )。 </p>
<blockquote>
<p>解答：组相联映射方式下，主存块按模Q(Q为Cache组数)映射到Cache对应组中的任一块；</p>
<p>Cache共有16块，采用2路组相联映射，故Cache共分16/2=8组；</p>
<p>主存块大小为32字节，按字节编址，故主存129号单元所在主存块为第129/32=4块；</p>
<p>4 Mod 8=4，故129号单元所在主存块应装入Cache第4组中任一块。 </p>
</blockquote>
<p>注意题目中129是单元数，不是块数</p>
</li>
<li><p><strong>例题：相联映射</strong></p>
</li>
<li><p>有效容量为128KB的Cache，每块16B，采用8位组相联，字节地址为1234567H的单元调入该Cache，则其tag为()</p>
<blockquote>
<p>128KB每块16B，则共有2^13^块，采用8位组相联，则有2^10^组，因此组号为10位；</p>
<p>每块大小为16B，块内地址需要4位来表示；</p>
<p>1234567H共28位，则其中后14位是组号+块内地址，前14位为标记字段即0001 0010 0011 01 -&gt;048DH</p>
</blockquote>
</li>
<li><p>替换是以块为单位的，当映射到同一组，但是标记不同的时候，如果组满才需要替换，即将组中某一块取出，若未满直接插入</p>
</li>
<li><p>Cache容量计算</p>
</li>
</ul>
<p><img src="https://www.hualigs.cn/image/605ef6f2d35c4.jpg"></p>
<ul>
<li>对于由高速缓存、主存、硬盘构成的三级存储体系，CPU访问该存储系统时发送的地址为主存物理地址</li>
<li>采用指令Cache和数据Cache分离的主要目的是减少指令流水线资源冲突(取指和取数可以分别到不同的cache中寻找)</li>
</ul>
<h2 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h2><ul>
<li>虚拟存储系统利用的是局部性原理</li>
<li>在虚拟存储器中，当程序正在执行时，由操作系统完成地址映射，但也需要一部分硬件基础的支持</li>
<li>页式虚拟存储器中，页面过小会导致虚拟存储器包含页面数过多，页表体积过大，操作变慢；页面很大时没页面数减少，页面调度频率较高，换页次数增加，降低操作速度</li>
<li>快表采用的是<strong>相联存储器</strong>，按照查找内容访问，查找速度比慢表快；快表是单独的存储器，而慢表存储在主存中</li>
<li>取数：先访问cache，没有再访问快表，没有再访问慢表，最少访问主存0次；写回时如果采用直写方式，则必须访问ache和主存，访问主存次数最少为1</li>
<li>在请求分页系统中，当要访问的页面不在内存中时，CPU检测到异常变回产生<strong>缺页中断</strong>，请求<strong>操作系统</strong>将缺页调入内存。缺页中断处理程序会根据缺页故障的地址从外存读入缺失的页，完成后<strong>回到发生缺页的指令</strong>继续执行</li>
</ul>
<h1 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h1><p>##基本框架</p>
<p><img src="https://www.hualigs.cn/image/60601fd0007b0.jpg"></p>
<ul>
<li><p>堆栈计算机中，有些堆栈零地址的运算类指令在指令格式中不给出操作数的地址，参加的两个操作数来自堆栈的栈顶和次栈顶单元。</p>
<blockquote>
<p>堆栈指令的访存次数取决于采用的是硬堆栈(由寄存器实现，只需要取指时访问一次内存)还是软堆栈(由内存实现，需要访问四次内存，取指、取数1、取数2、存结果)</p>
</blockquote>
</li>
<li><p>指令的基本格式：操作码+地址码</p>
</li>
<li><p>例题：扩展操作码</p>
</li>
<li><p>一个计算机系统采用32条单字长指令，地址码为12位，若定义了250条二地址指令，则还可以有()条单地址指令</p>
<p>二地址指令=两个地址码，每个地址码12位，那么操作码占了32-12-12=8位；</p>
<p>250条二地址指令，则8位操作码共256个码剩余了6个；</p>
<p>若要变为单地址指令，则最多可以将操作码拓展12位，可以有6*2^12^=24K条单地址指令</p>
</li>
<li><p>特权指令通常用于实现系统软件，这类指令一般不提供给用户</p>
</li>
</ul>
<hr>
<p>##不同字长的区别</p>
<p><strong>机器字长：</strong>CPU一次能够处理的数据的位数。通常等于寄存器的位数。例子：windows 64位/32位，这里的64位和32位指的就是该操作系统的机器字长。</p>
<p><strong>存储字长</strong>：计算机存储器中一个存储单元可以存储的位数。例子：某某计算机按照字节编址，即说明该计算机的存储字长为1B=8位。</p>
<p><strong>指令字长</strong>：计算机内一条指令的位数。这里通常指的定长指令。</p>
<p>机器字长与存储字长：两者没有必然的联系</p>
<p>机器字长与指令字长：两者没有必然的联系。它既可以等于机器字长也可以大于或者小于机器字长。通常把等于机器字长的指令称为单字长指令。把等于半个机器字长的指令称为半字长指令。把等于两倍机器字长的指令称为双字长指令。</p>
<p>存储字长和指令字长。各位可能经常看到这样的字眼：某某计算机按字节编址，指令长度为16位/32位。通常为了方便取址<strong>规定指令字长为存储字长的整数倍</strong>。现在的计算机指令长度基本都是存储字长的整数倍。</p>
<hr>
<h2 id="指令的寻址方式"><a href="#指令的寻址方式" class="headerlink" title="指令的寻址方式"></a>指令的寻址方式</h2><ul>
<li><p>内存地址是无符号数，而相对偏移量可以有正负</p>
</li>
<li><p>不同寻址方式特点：简化地址结构可以选择隐地址(不占位置),缩短指令地址段位数可以用寄存器寻址(寄存器一共就那么多~几个位就表示了);最快速获取操作数选择立即寻址;处理数组选择变址寻址;多道程序设计中最重要的寻址方式是相对寻址(同时多个程序按一定顺序轮流执行，相对方便程序浮动)</p>
</li>
<li><p>相对寻址是以<strong>下条</strong>指令在内存中首地址为基准的偏移量</p>
</li>
<li><p>采用相对寻址进行转移指令的时候，要注意程序计数器数值的变化，根据题意取指令时PC会增加，增加的位数要考虑机器字长。(<strong>每当取出1字节时PC的值+1，要看指令是多少字节</strong>)</p>
</li>
<li><p>程序计数器(PC)给出下一条指令字的访存地址，长度取决于存储器的字数；指令寄存器(IR)用于接收取得的指令，长度取决于指令字长</p>
</li>
<li><p>基址寻址和变址寻址具体寻址操作：找到变址/基址寄存器内容和形式地址内容，相加，得到操作数的实际地址，再根据实际地址访问内存，获取操作数；基址寻址中程序员操作的是偏移地址，基址寄存器内容由操作系统控制；变址寻址中，程序员操作的是变址寄存器，偏移地址是固定不变的</p>
</li>
<li><p>注意区分题目中的寄存器间接寻址和一般的间接寻址，寄存器间接寻址不考虑嵌套，寄存器中存储的就是有效地址，间接寻址需要考虑首位，如果是1则是继续向下寻找</p>
</li>
<li><p><strong>堆栈寻址进出操作：</strong>进、出堆栈对栈顶指针的操作顺序相反，进栈先压数据再改指针，使指针指向栈顶空单元；出栈先改指针再出数据，因为指针要先指向数据才能把它推出去；</p>
</li>
</ul>
<h1 id="中央处理器"><a href="#中央处理器" class="headerlink" title="中央处理器"></a>中央处理器</h1><p>##CPU功能和基本结构</p>
<ul>
<li><p><strong>程序计数器：</strong>内容为指令在主存中的地址，所以程序计数器的位数与存储器地址的位数相等，而存储器地址取决于存储器的容量，因此程序计数器的位数取决于存储器的容量;其中存储的地址可能是本条指令的地址，也可能是下条指令，具体取决于是取指令前还是取指令后</p>
<blockquote>
<p>例：某计算机的主存空间为4GB，字长为32位，按字节编址，采用32位字长指令字格式。若指令按字边界对齐存放，内存的字数=4GB*8/32=2^30^，则程序计数器的位数=30；指令寄存器IR的位数取决于指令长度为32</p>
</blockquote>
</li>
<li><p><strong>指令译码</strong>是对指令的操作码字段进行译码</p>
</li>
<li><p>间址周期结束时，CPU内寄存器MDR中的内容为操作数地址。间址周期的作用是取操作数的有效地址，因此间址周期结束后，MDR中的内容为操作数的地址</p>
</li>
<li><p>溢出标志位根据溢出的三种判断方法来看，进位/借位标志位 如果是减法直接比较两个数大小即可判断，加法判断是否进位</p>
</li>
<li><p>计算机可以划分为控制部件和执行部件：控制部件包括指令寄存器、程序寄存器、操作寄存器；执行部件包括运算器、存储器、外围设备</p>
</li>
</ul>
<h2 id="指令执行过程"><a href="#指令执行过程" class="headerlink" title="指令执行过程"></a>指令执行过程</h2><ul>
<li>取指操作是控制器自动进行的，不需要得到相应指令，是所有指令周期的第一步</li>
<li>指令执行方案包括单指令周期、多指令周期、流水线方案</li>
<li>执行各条指令的机器周期数、各机器周期的长度都应该是可变的</li>
</ul>
<p>##不同周期的区分</p>
<p>时钟周期：机器节拍，主频的倒数 </p>
<p>CPU周期：同机器周期</p>
<p>机器周期：完成一个基本操作所需时间，基本操作包括：取值、间址、执行、中断等。==通常使用存取周期来确定机器周期，就是说可以认为机器周期等于存取周期==</p>
<p>指令周期：从主存中取出并执行一条指令所需完整时间； 指令周期划分为四个阶段：取址周期、间址周期、执行周期、中断周期。 </p>
<p>存取周期：存储器进行两次独立存储器操作所需最小的时间间隔。 </p>
<hr>
<h2 id="控制器的功能和工作原理"><a href="#控制器的功能和工作原理" class="headerlink" title="控制器的功能和工作原理"></a>控制器的功能和工作原理</h2><p><img src="https://www.hualigs.cn/image/606076e7e826d.jpg"></p>
<ul>
<li><p>每条微指令存放在控制器的一个控制存储器单元中，控制存储器由ROM构成，在CPU中，只需要读操作不需要写</p>
</li>
<li><p>微程序&gt;微指令&gt;微命令&gt;微操作</p>
<p>一条指令的功能由一段微程序实现；</p>
<p>微指令包含操作控制字段(微操作码)、顺序控制字段(微地址码)(存放<strong>下一条</strong>要执行的微指令地址);</p>
<p>微命令是控制部件向执行部件发出的各种控制命令，是构成控制序列的最小单位</p>
<p>微操作是计算机最基本的、不可再分解的操作</p>
</li>
<li><p><strong>微程序控制器基本组成</strong>：控制存储器、微指令寄存器、微地址形成部件、微地址寄存器</p>
</li>
<li><p><strong>微指令格式：</strong>水平型微指令(并行)、垂直型微指令、混合型</p>
</li>
<li><p><strong>微指令编码方式</strong>：直接编码(一个指令一位二进制)、字段直接编码(互斥命令组合在同一字段中，相容性微命令组合在不同字段中，每个字段独立编码，每个小段留出一个状态)、字段间接编码方式</p>
</li>
<li><p><strong>微指令地址形成方式：</strong>断定方式(微指令的下地址字段指出)、根据机器指令操作码形成</p>
</li>
<li><p><strong>硬布线和微程序控制器对比</strong></p>
</li>
</ul>
<p><img src="https://www.hualigs.cn/image/60609d767effd.jpg"></p>
<h2 id="指令流水线"><a href="#指令流水线" class="headerlink" title="指令流水线"></a>指令流水线</h2><ul>
<li><p>流水CPU是一种非常经济而实用的<strong>时间</strong>并行技术</p>
</li>
<li><p>题目中问的存在数据冒险的指令对是xx和xx，意思是这两个指令冲突–，不要理解成这两个指令和前面的冲突了</p>
</li>
<li><p>指令流水线数据通路包括程序计数器、算术逻辑运算部件、通用寄存器组、取指部件等，不包括控制部件</p>
</li>
<li><p>流水线冲突：对流水线影响最严重的是数据相关</p>
<p>资源冲突：同一时刻争抢同一资源  ①后指令暂停 ②设置不同存储器</p>
<p>数据冲突：下一条指令使用上一条结果 ①暂停，硬件阻塞和软件插入 ②数据旁路技术  ③编译器优化调整顺序</p>
<p>控制冲突：转移、调用、返回时冲突  ①分支预测②预测转移成功与不成功指令</p>
</li>
<li><p>超标量流水线：</p>
<p>超标量流水线技术：同一阶段并行执行多条指令；要求配置多个功能部件和指令译码电路</p>
<p>超流水线技术：每个周期分段，一个周期内每个部件使用多次；对cache容量要求更大，需要执行的指令长度很长</p>
<p>超长指令字：将多条能并行操作的指令组合成一条具有多个操作码字段的超长指令字</p>
</li>
<li><p>流水线按序流动，不会出现WAR、WAW，只有可能出现RAW相关</p>
</li>
<li><p>CPU时钟周期应该根据指令各功能部件执行的最大时间决定</p>
</li>
<li><p><strong>CPI</strong>表示执行指令所需的时钟周期数，对于一个程序或一套机器来说，其CPI是执行该程序或机器指令集中所有指令所需的平均时钟周期数。对于单周期CPU，指令周期=时钟周期，CPI=1；对于多周期CPU，CPU的执行分为几个阶段，每个阶段用一个时钟完成，每种指令所用的时钟数可以不同，CPI&gt;1；对于基本流水线CPU，让每个时钟周期流出一条指令，CPI=1；超标量流水线CPU，每个周期并发执行多条独立指令，CPI&lt;1</p>
</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Li Jing
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="http://example.com/2021/03/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E6%A1%86%E6%9E%B6%E5%92%8C%E9%87%8D%E7%82%B9/" title="计算机组成原理框架和重点">http://example.com/2021/03/24/计算机组成原理框架和重点/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/%E8%AE%A1%E7%BB%84/" rel="tag"># 计组</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/03/21/%E7%AE%97%E6%B3%95-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9/" rel="prev" title="算法-链表中倒数第k个结点">
                  <i class="fa fa-chevron-left"></i> 算法-链表中倒数第k个结点
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/03/29/CPU%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E5%8E%9F%E7%90%86/" rel="next" title="CPU的构造和原理">
                  CPU的构造和原理 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>







<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Li Jing</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="/js/local-search.js"></script>






  





</body>
</html>
