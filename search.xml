<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CPU的构造和原理</title>
    <url>/2021/03/29/CPU%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>CPU分为哪几部分？</p>
<p>CPU是如何数据传输的？</p>
<p>CPU怎样控制执行指令？</p>
<p>执行顺序是否可以优化</p>
<span id="more"></span>

<p><img src="https://www.hualigs.cn/image/606144e7aef39.jpg"></p>
<h2 id="CPU的组成和功能"><a href="#CPU的组成和功能" class="headerlink" title="CPU的组成和功能"></a>CPU的组成和功能</h2><p>​    分为运算器和控制器。运算器负责对数据的加工，即对数据进行算术和逻辑运算；控制器是整个系统的指挥中枢，对整个计算机系统进行有效的控制，包括指令控制、操作控制、时间控制和中断管理</p>
<h2 id="CPU如何进行数据传输"><a href="#CPU如何进行数据传输" class="headerlink" title="CPU如何进行数据传输"></a>CPU如何进行数据传输</h2><p>CPU传输数据一般有三种方式：</p>
<ul>
<li>CPU内部单总线方式：所有输入输出都接到一条通路上</li>
<li>CPU内部三总线方式：有数据总线、控制总线、地址总线</li>
<li>专用数据通路方式：根据数据和地址流动方向安排连接线路，避免使用共享总线</li>
</ul>
<p>总线可以实现数据的传递，比如说CPU已经取到了指令并放在了MDR中，要把MDR的指令传入IR，就要通过总线</p>
<p>寄存器间的数据传送、主存与CPU间的数据传送、暂存器与寄存器间的数据传送，都是以总线为桥梁的</p>
<h2 id="CPU如何执行指令"><a href="#CPU如何执行指令" class="headerlink" title="CPU如何执行指令"></a>CPU如何执行指令</h2><p>CPU执行指令的一个周期主要包括取指周期、间指周期、执行周期、中断周期四部分</p>
<p><strong>取指周期</strong>就是将PC中的内容从主存中取出并存放在IR中，数据流向为</p>
<p>PC→Bus→MAR</p>
<p>1→R  </p>
<p>MEM(MAR)→MDR</p>
<p>MDR→Bus→IR</p>
<p><strong>间址周期</strong>就是取操作数有效地址，只有使用间接寻址时才需要这步操作，一次间址就是将指令中的地址码送到MAR再传到总线，CU发出读命令在存储器相应地址中读取该地址后存回MDR</p>
<p><strong>执行周期</strong>就是根据IR中的指令通过ALU操作来产生执行结果，不同指令有不同的执行周期内容</p>
<p><strong>中断周期</strong>是处理中断请求，假设程序断点存放在堆栈中，那么需要由CU通过MAR、总线到主存修改栈顶指针，再通过控制总线发出写命令，然后将程序计数器内容通过MDR、数据总线写入存储器对应的堆栈中。</p>
<h2 id="CPU怎么控制指令执行"><a href="#CPU怎么控制指令执行" class="headerlink" title="CPU怎么控制指令执行"></a>CPU怎么控制指令执行</h2><p>​    通过控制器，根据指令操作码和时序信号，产生各种操作控制信号，以便正确地建立数据通路，从而完成取指令和执行指令的控制。 </p>
<p>控制器主要功能有：</p>
<ol>
<li>从主存中取出一条指令，并指出下一条指令在主存中的位置。</li>
<li>对指令进行译码或测试，产生相应的操作控制信号，以便启动规定的动作。</li>
<li>指挥并控制CPU、主存、输入和输出设备之间的数据流动方向。</li>
</ol>
<p>​    控制器可以分为硬布线控制器和微程序控制器两种，两类控制器中PC和IR是相同的，有区别的是操作控制器部分。</p>
<p>###硬布线控制器</p>
<p>​    通过布线的方式实现不同控制信号输入得到相应的输出结果，控制器的速度取决于电路延迟，速度快，但是设计完成不容易修改</p>
<p><img src="https://www.hualigs.cn/image/6061530491f5d.jpg"></p>
<p>###微程序控制器</p>
<p>​    将每条机器指令编写成一个微程序，每个微程序包含若干微指令，每条微指令对应一个或几个微操作命令</p>
<p>工作过程：</p>
<ol>
<li>执行取微指令公共操作。具体的执行是：在机器开始运行时，自动将取指微程序的入口地址送入CMAR，并从CM中读出相应的微指令送入CMDR。取指微程序的入口地址一般为CM的0号单元，当取指微程序执行完后，从主存中取出的机器指令就已存入指令寄存器中。</li>
<li>由机器指令的操作码字段通过微地址形成部件产生该机器指令所对应的微程序的入口地址，并送入CMAR。</li>
<li>从CM中逐条取出对应的微指令并执行。</li>
<li>执行完对应于一条机器指令的一个微程序后，又回到取指微程序的入口地址，继续第 1 步，以完成取下一条机器指令的公共操作。</li>
</ol>
<p>以上是一条机器指令的执行过程，如此周而复始，直到整个程序执行完毕</p>
<p><img src="https://www.hualigs.cn/image/606076e7e826d.jpg"></p>
<p>其中CU是一个控制单元</p>
<p>概念辨析：</p>
<blockquote>
<p>微程序&gt;微指令&gt;微命令&gt;微操作</p>
<p>一条指令的功能由一段微程序实现；</p>
<p>微指令包含操作控制字段(微操作码)、顺序控制字段(微地址码)(存放<strong>下一条</strong>要执行的微指令地址);</p>
<p>微命令是控制部件向执行部件发出的各种控制命令，是构成控制序列的最小单位</p>
<p>微操作是计算机最基本的、不可再分解的操作</p>
</blockquote>
<h2 id="指令执行顺序的优化"><a href="#指令执行顺序的优化" class="headerlink" title="指令执行顺序的优化"></a>指令执行顺序的优化</h2><p>​    一条指令的执行过程可以分解为多个阶段，如果一条指令一条指令按顺序执行，必然效率很低。因此引入了指令流水线。</p>
<p>​    流水CPU是一种非常经济而实用的时间并行技术</p>
<p><img src="https://www.hualigs.cn/image/6061562ca3fb6.jpg"></p>
<p>​    类似如图所示的流水线形式工作，可以大幅度提升工作效率</p>
<p>​    那么不免想到一个问题，如果第二条指令需要资源时第一条指令正在使用呢？或者第二条指令需要的数据应该是第一条输出的数据呢？</p>
<ol>
<li>资源冲突：同一时刻争抢同一资源  解决方案：①后面的指令暂停 ②设置不同存储器</li>
<li>数据冲突：下一条指令使用上一条结果  解决方案：①后面的指令暂停，硬件阻塞和软件插入 ②数据旁路技术  ③编译器优化调整顺序</li>
<li>控制冲突：转移、调用、返回时冲突  解决方案①分支预测②预测转移成功与不成功指令</li>
</ol>
<p>此时如果还是觉得速度不够快效率不够高呢？还有新的技术</p>
<ol>
<li>超标量流水线技术：同一阶段并行执行多条指令；要求配置多个功能部件和指令译码电路</li>
<li>超流水线技术：每个周期分段，一个周期内每个部件使用多次；对cache容量要求更大，需要执行的指令长度很长</li>
<li>超长指令字：将多条能并行操作的指令组合成一条具有多个操作码字段的超长指令字；需要采用多个处理部件</li>
</ol>
<p>本质还是用空间换时间，后续CPU的多核并行也一样是为了提高CPU的工作效率，也是目前速度优化的主流趋势</p>
<p>后续等待补充—0—</p>
]]></content>
      <categories>
        <category>408</category>
      </categories>
      <tags>
        <tag>计组</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS3之变换与动画</title>
    <url>/2021/03/11/CSS3%E4%B9%8B%E5%8F%98%E6%8D%A2%E4%B8%8E%E5%8A%A8%E7%94%BB/</url>
    <content><![CDATA[<h2 id="2D转换"><a href="#2D转换" class="headerlink" title="2D转换"></a>2D转换</h2><p>转换是CSS3中具有颠覆性的特征之一，可以实现元素的位移、旋转、缩放等效果</p>
<p>转换可以简单理解为变形</p>
<span id="more"></span>

<ul>
<li>移动: translate</li>
<li>旋转：retate</li>
<li>缩放：scale</li>
</ul>
<blockquote>
<p>过渡效果是transition: all 0.3s;</p>
</blockquote>
<h3 id="translate"><a href="#translate" class="headerlink" title="translate"></a>translate</h3><p>二维坐标系：向右向下为正</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">transform: translate(x,y)</span><br><span class="line">transform: translateX(x)</span><br><span class="line">transform: translateY(y)</span><br></pre></td></tr></table></figure>

<ul>
<li>x是x轴上移动位置，y是y轴移动位置</li>
<li>translate不会影响其他元素位置</li>
<li>百分比单位是相对自身元素的</li>
<li>对<strong>行内标签无效</strong></li>
<li>在子盒子想要定位到父盒子中间时，可以定位top%50,left50%,然后translate(50%,50%)</li>
</ul>
<h3 id="rotate"><a href="#rotate" class="headerlink" title="rotate"></a>rotate</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">transform: rotate(360deg)</span><br></pre></td></tr></table></figure>

<ul>
<li>可以用来实现小三角&gt;&lt;朝上朝下(小正方形只要两个边框，旋转)</li>
<li>度数逆时针为正</li>
</ul>
<h3 id="转换中心点-transform-origin"><a href="#转换中心点-transform-origin" class="headerlink" title="转换中心点 transform-origin"></a>转换中心点 transform-origin</h3><p>默认为50 % 50%</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">transform-origin: x y;</span><br></pre></td></tr></table></figure>

<p>x y可以是像素、百分比、方位名词</p>
<h3 id="缩放scale"><a href="#缩放scale" class="headerlink" title="缩放scale"></a>缩放scale</h3><p>可以实现放大缩小</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">transform:scale(x,y);</span><br><span class="line">transform:scale(x);</span><br></pre></td></tr></table></figure>

<p>x,y表示倍数，1表示一倍,只写一个表示同时x倍</p>
<ul>
<li>不会影响其他盒子，而且可以设置缩放中心点</li>
<li>缩放是向四周缩放的，比直接改宽高更适合做动画</li>
</ul>
<h3 id="综合写法"><a href="#综合写法" class="headerlink" title="综合写法"></a>综合写法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">transform: translate() rotate() scale()</span><br></pre></td></tr></table></figure>

<ul>
<li>先旋转会改变坐标轴方向</li>
<li>先同时有位移和其他效果时，位移放在最前面</li>
</ul>
<h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><p>可以通过设置多个节点来精确控制一个或者一组动画，实现复杂的动画效果</p>
<ul>
<li>先定义动画</li>
<li>再调用动画</li>
</ul>
<h3 id="用keyframes定义动画"><a href="#用keyframes定义动画" class="headerlink" title="用keyframes定义动画"></a>用keyframes定义动画</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@keyframes move &#123;</span><br><span class="line">    0% &#123;</span><br><span class="line">        transform: translateX(0px);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    100% &#123;</span><br><span class="line">        transform: translateX(1000px);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">使用的元素 &#123;</span><br><span class="line">    animation-name: move;</span><br><span class="line">    animation-duration: 2s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>from to等同于0%,100%</li>
<li>可以做多个状态的变化，百分比要是正数，100%的时候是总时间</li>
</ul>
<h4 id="动画属性"><a href="#动画属性" class="headerlink" title="动画属性"></a>动画属性</h4><ul>
<li>animation: 动画属性的简写属性</li>
<li>animation-name: 动画名字</li>
<li>animation-duration: 持续时间</li>
<li>animation-timing-function: 规定动画的速度曲线，默认是’ease’</li>
<li>animation-delay: 规定动画何时开始，单位是秒</li>
<li>animation-iteration-count: 规定动画被播放的次数infinite表示无限循环</li>
<li>animation-direction: 规定动画</li>
<li>animation-direction: 默认是normal反方向是alternate</li>
<li>animation-play-state: 规定动画是否正在运行或者暂停，默认是running,pause</li>
<li>animation-fill-mode: 规定动画结束后状态，保持forwards回到起始backwards</li>
</ul>
<p>简写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">annimation: 动画名称 持续时间 运动曲线 何时开始 播放次数 是否反方向 动画起始或者结束的状态</span><br><span class="line">annimation: myfirst 5s linear 2s infinite alternate;</span><br></pre></td></tr></table></figure>

<p>前两个不能省略</p>
<h4 id="速度曲线细节"><a href="#速度曲线细节" class="headerlink" title="速度曲线细节"></a>速度曲线细节</h4><p>animation-timing-function:</p>
<ul>
<li>linear 匀速</li>
<li>ease 低–&gt;高–&gt;低</li>
<li>ease-in 低速开始</li>
<li>ease-out 低速结束</li>
<li>ease-in-out 低速开始和结束</li>
<li>steps()指定了时间函数中的间隔数量(步长)，相当于一步一步走，离散化</li>
</ul>
<p>–可以通过设定一个盒子，装n个字，宽度为n个字的宽度，并且分n步，设定一行显示和溢出隐藏，即可实现打字机效果</p>
<h3 id="动画实例"><a href="#动画实例" class="headerlink" title="动画实例"></a>动画实例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">    background-color: rgb(163, 151, 229);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">div &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    margin: 0 auto;</span><br><span class="line">    background: url(bear.png) no-repeat;</span><br><span class="line"></span><br><span class="line">    animation: run 1s steps(8) infinite, move 3s forwards;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@keyframes run &#123;</span><br><span class="line">    0% &#123;</span><br><span class="line">        background-position: 0 0;</span><br><span class="line">        &#x2F;* transform: translate(0, 0); *&#x2F;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    100% &#123;</span><br><span class="line">        background-position: -1600px 0;</span><br><span class="line">        &#x2F;* transform: translate(-1400px, 0); *&#x2F;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@keyframes move &#123;</span><br><span class="line">    0% &#123;</span><br><span class="line">        left: 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    100% &#123;</span><br><span class="line">        left: 50%;</span><br><span class="line">        transform: translate(-50%);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="D:\桌面\web\bear.png"></p>
<h2 id="3D变换"><a href="#3D变换" class="headerlink" title="3D变换"></a>3D变换</h2><p>x水平向右y垂直向下z垂直屏幕（往外是正值，往内是负值）</p>
<h3 id="3D位移"><a href="#3D位移" class="headerlink" title="3D位移"></a>3D位移</h3><p>translateZ沿着z轴运动，后面的单位一般跟px</p>
<p>translate3d(100px,100px,100px) 不能省略x，y，z，如果没有就写0</p>
<p>z轴值越大，我们看到的物体越大</p>
<h3 id="透视perspective"><a href="#透视perspective" class="headerlink" title="透视perspective"></a>透视perspective</h3><p>网页中产生3D效果需要透视，透视也称为视距(人的眼睛到屏幕的距离)，透视的单位是像素</p>
<p>透视要加在父亲上</p>
<p>perspective: 500px;</p>
<h3 id="3D旋转rotate"><a href="#3D旋转rotate" class="headerlink" title="3D旋转rotate"></a>3D旋转rotate</h3><p>transform: rotate3d(x,y,z,deg):沿着自定义轴旋转deg</p>
<p>(x,y,z)可以表示轴的方向</p>
<p>transformX:</p>
<p>transformY：</p>
<p>transformZ：</p>
<p>左手准则，大拇指指向x正向，则四指指向翻转方向</p>
<h3 id="3D呈现transform-style"><a href="#3D呈现transform-style" class="headerlink" title="3D呈现transform-style"></a>3D呈现transform-style</h3><ul>
<li>控制子元素是否开启三维立体空间</li>
<li>默认flat不开启3D</li>
<li>transform-style: preserve-3D子元素开启3D立体空间</li>
<li>代码写给父级，影响的是子盒子</li>
</ul>
<h3 id="实现双面盒子"><a href="#实现双面盒子" class="headerlink" title="实现双面盒子"></a>实现双面盒子</h3><ul>
<li>两个盒子叠在一起放在一个父盒子里，先将背面盒子旋转180，再将父盒子旋转180，记得维持3D效果</li>
<li>多个transform记得放在一起</li>
<li>要让旋转轴在中间</li>
</ul>
<h3 id="实现旋转木马"><a href="#实现旋转木马" class="headerlink" title="实现旋转木马"></a>实现旋转木马</h3><ul>
<li>先旋转后移动</li>
</ul>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS3与HTML5</title>
    <url>/2021/03/11/CSS3%E4%B8%8EHTML5/</url>
    <content><![CDATA[<h2 id="HTML5新特性"><a href="#HTML5新特性" class="headerlink" title="HTML5新特性"></a>HTML5新特性</h2><p>增加了一些新的标签、新的表单以及新的表单属性等</p>
<p>这些新特性都有兼容性问题，基本上IE9+以上版本浏览器才支持，如果不考虑兼容性问题，可以大量使用这些新特性</p>
<span id="more"></span>

<h3 id="新增语义化标签"><a href="#新增语义化标签" class="headerlink" title="新增语义化标签"></a>新增语义化标签</h3><ul>
<li><header>:头部标签</li>
<li><nav>:导航标签</li>
<li><article>:内容标签</li>
<li><section>：定义文档某个区域</li>
<li><aside>:侧边栏标签</li>
<li><footer>:尾部标签</li>
</ul>
<p>注意：</p>
<ul>
<li>这种语义化标签主要是针对搜索引擎的</li>
<li>这些新标签可以多次使用</li>
<li>IE9中，需要把这些标签转化为块级元素</li>
<li>移动端常用</li>
</ul>
<h3 id="新增的多媒体标签"><a href="#新增的多媒体标签" class="headerlink" title="新增的多媒体标签"></a>新增的多媒体标签</h3><p>新媒体标签主要包含两个：</p>
<ol>
<li>音频：<audio></li>
<li>视频：<video></li>
</ol>
<p>使用他们不需要flash和其他浏览器插件即可嵌入视频或者音频</p>
<p>video目前支持三种视频格式，mp4，WebbM，Ogg，一般推荐mp4格式，兼容性好</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;video src&#x3D;&quot;地址&quot; controls&#x3D;&quot;controls&quot;&gt;&lt;&#x2F;video&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;video src&#x3D;&quot;地址&quot; controls&#x3D;&quot;controls&quot; width&#x3D;&quot;300&quot;&gt;</span><br><span class="line">	&lt;source src&#x3D;&quot;move.mp4&quot; type&#x3D;&quot;video&#x2F;mp4&quot;&gt;</span><br><span class="line">	&lt;source src&#x3D;&quot;move.ogg&quot; type&#x3D;&quot;video&#x2F;ogg&quot;&gt;</span><br><span class="line">	你的浏览器暂时不支持&lt;video&gt;标签播放视频</span><br><span class="line">&lt;&#x2F;video&gt;</span><br></pre></td></tr></table></figure>

<p>常见属性</p>
<ul>
<li>src： 图片地址</li>
<li>autoplay=“autoplay” 视频就绪自动播放（谷歌浏览器禁用了自动播放）</li>
</ul>
<p>muted=”muted”静音播放，使用这个属性后谷歌浏览器也可以自动播放</p>
<ul>
<li>control=”controls”播放控件（播放、暂停、静音）</li>
<li>width: 100% 显示和浏览器一样宽</li>
<li>height</li>
<li>loop: 值为loop时循环播放，不写该属性则不循环</li>
<li>preload: auto预先加载视频，none不加载视频，如果有了autoplay忽略该属性</li>
<li>poster: 值imgurl，加载等待的图片画面（视频正在加载时显示的图片）</li>
<li>muted: muted静音播放</li>
</ul>
<p>一般不加controls，因为不同浏览器控件不同，后续可以用JS实现相同的控件</p>
<h4 id="新增input表单"><a href="#新增input表单" class="headerlink" title="新增input表单"></a>新增input表单</h4><p>type值：</p>
<p>原有text、password、submit等</p>
<blockquote>
<ul>
<li>email:</li>
<li>url</li>
<li>date</li>
<li>time</li>
<li>month</li>
<li>week</li>
<li>number</li>
<li>tel 手机号码</li>
<li>search 搜索框</li>
<li>color 生成一个颜色选择表单</li>
</ul>
</blockquote>
<p>type=”submit” value=”提交”为提交按钮，提交时会对其他输入检测</p>
<p>number、tel、search最重要</p>
<h4 id="HTML5新增的表单属性"><a href="#HTML5新增的表单属性" class="headerlink" title="HTML5新增的表单属性"></a>HTML5新增的表单属性</h4><ul>
<li>required=”required”     表示不能为空，必须写</li>
<li>placeholder=””: 默认显示的内容，输入一些文字后会消失</li>
</ul>
<p>还可以通过box::placeholder选择该属性并进行属性调整</p>
<ul>
<li>autofocus=“autofocus”: 自动获取焦点</li>
<li>autocomplete=off/on 记录上次提交过的内容，开始键入时显示以前输入过的</li>
<li>multiple：multiple 用于多选文件</li>
</ul>
<h3 id="广义的H5"><a href="#广义的H5" class="headerlink" title="广义的H5"></a>广义的H5</h3><p>广义的HTML5指的是HTML5本身+CSS3+JavaScript，这个集合有时称为HTML5和朋友，将来HTML5是一种发展趋势</p>
<h2 id="CSS3的现状"><a href="#CSS3的现状" class="headerlink" title="CSS3的现状"></a>CSS3的现状</h2><p>新增选择器和盒子模型和其他特性，ie9+才支持</p>
<h3 id="新的选择器"><a href="#新的选择器" class="headerlink" title="新的选择器"></a>新的选择器</h3><h4 id="属性选择器："><a href="#属性选择器：" class="headerlink" title="属性选择器："></a>属性选择器：</h4><ul>
<li><p>可以根据元素特定属性来选择元素，可以不用借助类或id选择</p>
<p>input[value] {color: pink;}                                   选择具有value属性的input</p>
<p>input[type=”text”]                            选择文本框的input（重要）</p>
<p>input[class^=”icon”]                                       选择具有class属性且属性值为icon开头的元素</p>
<p>input[class$=”-data”]                        选择具有class属性且以-data为结尾的元素</p>
<p>input[class*=”val”]                        选择出具有class属性且包含val的元素</p>
</li>
<li><p>类选择器、属性选择器、伪类选择器权重为10</p>
</li>
</ul>
<h4 id="结构伪类选择器"><a href="#结构伪类选择器" class="headerlink" title="结构伪类选择器"></a>结构伪类选择器</h4><ul>
<li><p>主要根据文档结构选择器元素，常用与根据父级选择器里面的元素</p>
<p>E:first-child                                选择父元素的第一个子元素</p>
<p>E:last-child                                选择父元素的最后一个子元素</p>
<p>E:nth-child(n)                            选择父元素的第n个子元素</p>
<p>E:first-of-type                            指定类型E的第一个</p>
<p>E:last-of-type                                指定类型E的最后一个</p>
<p>E:nth-of-type                                指定类型E的第n个</p>
</li>
<li><p>完整写法ul li:first-child  ul</p>
</li>
<li><p>nth-child给所有孩子排序，先看第几个孩子，再判断是否符合要求如果第一个孩子不是li则选不出来结果，优先看第几个孩子</p>
</li>
<li><p>nth-of-type会把指定元素的孩子排列序号，优先看类型，再看第几个孩子</p>
</li>
<li><p>n可以是数字关键字或者公式；                                                                                                                          n可以是关键字：even偶数odd奇数；直接写n表示每次加1往后计算；                                                       可以是公式：可以写2<em>n（偶数），2</em>n+1（奇数），5*n（一行显示5个时可以选择第五个去掉右边距），n+5（从第五个开始到最后），-n+5（前五个）</p>
</li>
<li><p>无序列表用nth-child更多</p>
</li>
<li><p>类选择器、属性选择器、伪类选择器权重为10</p>
</li>
</ul>
<h4 id="伪元素选择器"><a href="#伪元素选择器" class="headerlink" title="伪元素选择器"></a>伪元素选择器</h4><p>帮助我们利用css创建标签元素，而不需要HTML便签，从而简化HTML结构</p>
<p>CSS3时是两个冒号，CSS2前是单冒号</p>
<p>​    ::before                                             在元素的内部的前面插入内容</p>
<p>​    ::after                                             在元素的内部的后面插入内容</p>
<ul>
<li>before和after创建一个元素，但是是行内元素</li>
<li>装饰类的小图片可以用伪元素做，不需要插入新标签</li>
<li>新创建的元素在文档树中无法找到，所以称为伪元素</li>
<li>before和after必须有content属性</li>
<li>伪元素选择器和标签选择器的权重一样为1，div::before权重为2</li>
</ul>
<p>使用场景：</p>
<ol>
<li>配合字体图标</li>
</ol>
<p>content: ‘\e91e’</p>
<p>content: ‘’’’</p>
<p>content: ‘’也可以</p>
<ol>
<li>视频遮罩 .box::hover::before 鼠标经过时的before</li>
<li>伪元素清除浮动</li>
</ol>
<h3 id="CSS3盒子模型"><a href="#CSS3盒子模型" class="headerlink" title="CSS3盒子模型"></a>CSS3盒子模型</h3><p>CSS3可通过box-sizing指定盒模型，有两个值：即可指定为content-box、border-box,</p>
<ol>
<li>box-sizing: content-box 盒子大小为width+padding+border</li>
<li>box-sizing: border-box盒子大小为width</li>
</ol>
<p>这样使用padding和border就不会撑大盒子了（padding和border不要超过width）</p>
<p>经常在css开头*中加上border-sizing: border-box;</p>
<h3 id="CSS其他特性"><a href="#CSS其他特性" class="headerlink" title="CSS其他特性"></a>CSS其他特性</h3><p><strong>CSS3滤镜filter</strong></p>
<p>可以将模糊或者颜色偏移等图形效果应用于元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">filter: 函数(); </span><br></pre></td></tr></table></figure>

<p>例如filter: blur(5px)  可以让图像模糊，数值越大，图像越模糊</p>
<h5 id="CSS3-calc函数"><a href="#CSS3-calc函数" class="headerlink" title="CSS3 calc函数"></a>CSS3 calc函数</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">width: calc(100% - 80px);</span><br></pre></td></tr></table></figure>

<p>可以实现一些计算，可以实现比父盒子小多少像素</p>
<p>运算符前后要加空格</p>
<h5 id="CSS过渡"><a href="#CSS过渡" class="headerlink" title="CSS过渡"></a>CSS过渡</h5><p>过渡是CSS3具有颠覆性的特性之一，可以实现某些动画，经常与：hover一起使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">transition:要过渡的属性 花费时间 运动曲线 何时开始</span><br></pre></td></tr></table></figure>

<ol>
<li>属性：想要变化的CSS属性，宽度高度背景颜色等</li>
<li>花费时间：单位是秒</li>
<li>运动曲线：默认是ease（渐慢） linear（匀速）</li>
<li>何时开始：单位是秒，最迟延迟触发时间，默认是0s</li>
</ol>
<p>后两个属性可以省略</p>
<p>要同时改变两个属性,需要在类和类：hover中写变化前和变化后的属性值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">transition: width .5s, height .5s</span><br><span class="line">transition: all 0.5s</span><br></pre></td></tr></table></figure>

<p>利用逗号分隔</p>
<h4 id="背景颜色渐变"><a href="#背景颜色渐变" class="headerlink" title="背景颜色渐变"></a>背景颜色渐变</h4><p>background: linear-gradient(起始方向，颜色1，颜色2，…)</p>
<p>电脑端使用尽量加上前缀-webkit- linear-gradient</p>
<p>起始方向包括top left, left, right等</p>
<h3 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h3><h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><p>见下一篇博客</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS基础</title>
    <url>/2021/03/11/CSS%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>CSS基础</p>
<span id="more"></span>

<h3 id="CSS元素显示模式"><a href="#CSS元素显示模式" class="headerlink" title="CSS元素显示模式"></a>CSS元素显示模式</h3><h5 id="块元素"><a href="#块元素" class="headerlink" title="块元素"></a>块元素</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;h1&gt;~&lt;h6&gt;、&lt;p&gt;、&lt;div&gt;、&lt;ul&gt;、&lt;ol&gt;、&lt;li&gt;</span><br></pre></td></tr></table></figure>

<p>独占一行、可以控制宽度高度内外边距、宽度默认是父级宽度的百分之百、里面可以放行内或块级元素</p>
<p>和<h>不能放其他块级元素

<h5 id="行内元素"><a href="#行内元素" class="headerlink" title="行内元素"></a>行内元素</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a&gt; &lt;strong&gt; &lt;b&gt; &lt;em&gt; &lt;i&gt; &lt;del&gt; &lt;s&gt; &lt;ins&gt; &lt;u&gt; &lt;span&gt;</span><br></pre></td></tr></table></figure>

<p>一行可以显示多个、无法直接设置宽、高，默认宽度是它内容的宽度，只能容纳文本和其他行内元素</p>
<p>特殊情况连接可以放块级元素，但是转换一个块级模式更加安全</p>
<h5 id="行内块元素"><a href="#行内块元素" class="headerlink" title="行内块元素"></a>行内块元素</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img&gt; &lt;input&#x2F;&gt; &lt;td&gt;</span><br></pre></td></tr></table></figure>

<p>一行可以显示多个、默认宽度是内容的宽度、高宽和内外边距可以控制</p>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><table>
<thead>
<tr>
<th>属性</th>
<th>意义</th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td>background-color</td>
<td>背景颜色</td>
<td>预定义颜色值/十六进制/RGB代码</td>
</tr>
<tr>
<td>background-image</td>
<td>背景图片</td>
<td>url(图片路径)</td>
</tr>
<tr>
<td>background-repeat</td>
<td>是否平铺</td>
<td>repeat/no-repeat/repeat-x/repeat-y</td>
</tr>
<tr>
<td>background-position</td>
<td>背景位置</td>
<td>分别是x和y坐标，可以为固定值也可是center，top</td>
</tr>
<tr>
<td>background-attachment</td>
<td>背景是否滚动</td>
<td>fixed（背景固定）/scroll（背景滚动）</td>
</tr>
<tr>
<td>background-size</td>
<td>背景大小</td>
<td>固定/相对(x y)/cover（填满容器)/contain（至少一端满)</td>
</tr>
</tbody></table>
<blockquote>
<ul>
<li>简写：background: 背景颜色 背景图片地址 背景平铺 背景图像滚动 背景图片位置</li>
<li>装饰性小图片和超大背景图片经常使用背景图片来做，方便控制位置</li>
</ul>
</blockquote>
<h4 id="背景颜色半透明"><a href="#背景颜色半透明" class="headerlink" title="背景颜色半透明"></a>背景颜色半透明</h4><blockquote>
<p>background :rgba(0,0,0,0.3);</p>
<p>最后一个参数是alpha透明度，取值在(0,1)之间，0.3前的0可以省略</p>
<p>背景半透明是指盒子背景半透明，盒子里面内容不受影响</p>
</blockquote>
<h3 id="CSS三大特性"><a href="#CSS三大特性" class="headerlink" title="CSS三大特性"></a>CSS三大特性</h3><h4 id="层叠性"><a href="#层叠性" class="headerlink" title="层叠性"></a>层叠性</h4><p>解决样式冲突的问题，遵循就近原则，哪个样式离结构近，执行哪一个</p>
<h4 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h4><ul>
<li>子标签会继承父标签的某些特性</li>
<li>text- font- line- color属性会继承</li>
<li>行高的继承</li>
</ul>
<blockquote>
<p>父元素 font:24px/1.5 “微软雅黑”  表示行高为当前元素1.5倍</p>
<p>子元素 font:16px</p>
<p>行高也是当前元素1.5倍,即16*1.5=24px</p>
<p>子元素2 未指定文字大小</p>
<p>继承父元素的文字大小和行高，即24px/1.5</p>
</blockquote>
<h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><ol>
<li>选择器相同，则执行层叠</li>
<li>选择器不同，根据选择器权重进行</li>
</ol>
<blockquote>
<p>继承或者*  0,0,0,0</p>
<p>元素选择器   0,0,0,1</p>
<p>类选择器，伪类选择器 0,0,1,0</p>
<p>ID选择器 0,1,0,0</p>
<p>行内样式 1,0,0,0</p>
<p>!important 无穷大</p>
</blockquote>
<ol>
<li>等级判断从左到右，如果哪一位数值相同，则依次判断下一位</li>
<li>继承的权重是0，不管父元素权重多高，子元素得到的权重都是0</li>
<li>对body指定颜色不会改变文中链接的颜色，因为浏览器有默认颜色即蓝色</li>
<li>复合选择器会有<strong>权重叠加</strong>的问题,但是不会进位                                                                                                ul li权重为0,0,0,2 .nav li权重为0,0,1,1</li>
</ol>
<hr>
<h3 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h3><p>HTML页面的布局本质是一个个盒子</p>
<p>border: 边框</p>
<p>content：内容，可以是文字图片或者其他的盒子</p>
<p>padding：内边距，内容和边框的距离</p>
<p>margin：外边距，不同盒子间的距离</p>
<h4 id="边框-border"><a href="#边框-border" class="headerlink" title="边框(border)"></a>边框(border)</h4><p>border: border-width ||border-style ||border-color</p>
<p>定义边框粗细、样式、颜色</p>
<p>border-style: solid 实线边框  dashed：虚线边框  dotted：点线边框</p>
<p><code>border: 1px solid red;</code> </p>
<p>没有顺序要求</p>
<p>border-top border-bottom上边框 下边框</p>
<h5 id="表格细线边框"><a href="#表格细线边框" class="headerlink" title="表格细线边框"></a>表格细线边框</h5><p>border-collapse: collapse </p>
<p>相邻边框合并一起</p>
<h5 id="边框会影响盒子的大小"><a href="#边框会影响盒子的大小" class="headerlink" title="边框会影响盒子的大小"></a>边框会影响盒子的大小</h5><p>width不包括border-width</p>
<p>实际宽度=width+border-width</p>
<h4 id="内边距-padding"><a href="#内边距-padding" class="headerlink" title="内边距(padding)"></a>内边距(padding)</h4><p>padding-left/padding-right/padding-top/padding-bottom</p>
<p>调整边框与内容距离</p>
<p>padding:5px 表示上下左右各5像素内边距</p>
<p>padding:5px 10px上下5px，左右10px</p>
<p>padding：5px，10px，15px  上/左右/下</p>
<p>四个值 上/右/下/左</p>
<h5 id="paddding会影响实际盒子大小"><a href="#paddding会影响实际盒子大小" class="headerlink" title="paddding会影响实际盒子大小"></a>paddding会影响实际盒子大小</h5><p>如果盒子没有指定高度/宽度，padding不会撑开盒子</p>
<h4 id="外边距（margin"><a href="#外边距（margin" class="headerlink" title="外边距（margin)"></a>外边距（margin)</h4><p>margin-left/margin-right/margin-top/margin-bottom</p>
<p>外边距可以让块级盒子<strong>水平居中</strong>，必须满足</p>
<ul>
<li>盒子指定了宽度</li>
<li>盒子左右的外边距都设置为auto</li>
</ul>
<p>margin: auto;</p>
<p>margin: 0 auto;（最常用)</p>
<p><strong>行内元素和行内块元素水平居中</strong>直接给父元素添加text-align:center</p>
<h5 id="嵌套块元素垂直外边距的塌陷"><a href="#嵌套块元素垂直外边距的塌陷" class="headerlink" title="嵌套块元素垂直外边距的塌陷"></a>嵌套块元素垂直外边距的塌陷</h5><p>对于两个嵌套关系的块元素，父元素的有下外边距，子元素有上外边距，会塌陷为较大的边距</p>
<p>解决方法:</p>
<ul>
<li>可以为父元素定义上边框 border: 1px solid transparent</li>
<li>可以为父元素定义上内边距</li>
<li>可以为父元素添加overflow:hidden</li>
</ul>
<h5 id="清除内外边距"><a href="#清除内外边距" class="headerlink" title="清除内外边距"></a>清除内外边距</h5><p>*{margin:0;padding:0}</p>
<p>布局前，应该先清除网页元素的内外边距</p>
<p>行内元素尽量只设置左右内外边距，不要设置上下内外边距，但是转换为块级和行内块级就可以了</p>
<hr>
<p>list-style: none; </p>
<p>去掉无序列表前的小圆点</p>
<h3 id="圆角边框"><a href="#圆角边框" class="headerlink" title="圆角边框"></a>圆角边框</h3><p>border-radius: length;</p>
<p>如10px或%50</p>
<ol>
<li>length为正方形的长度一半时，显示为圆形</li>
<li>length为矩形的高度一半时，显示为圆角矩形</li>
<li>最多可以四个值，分别为左上右上右下坐下</li>
</ol>
<h3 id="盒子阴影"><a href="#盒子阴影" class="headerlink" title="盒子阴影"></a>盒子阴影</h3><p>box-shadow: h-shadow v-shadow blue spread color inset</p>
<ol>
<li>前两个必须写，其他可选</li>
<li>水平阴影、垂直阴影（可以正负，相对主体的偏移距离)、模糊距离（虚实)、阴影尺寸、阴影颜色、外部阴影</li>
<li>阴影颜色通常不用黑色，可以用rgba(0,0,0,.3)的操作，透明度为30的黑色</li>
<li>默认是外阴影，只能写inset，不能写外阴影</li>
<li>阴影不占用盒子空间</li>
</ol>
<h4 id="文字阴影"><a href="#文字阴影" class="headerlink" title="文字阴影"></a>文字阴影</h4><p>text-shadow: h-shadow v-shadow -blur color</p>
<hr>
<h3 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h3><h4 id="传统网页布局的三种方式"><a href="#传统网页布局的三种方式" class="headerlink" title="传统网页布局的三种方式"></a>传统网页布局的三种方式</h4><p>实际开发中，一个页面基本包含了<strong>三种</strong>布局方式</p>
<p>多个块级元素纵向排列用标准流，多个块级元素横向排列用浮动</p>
<ul>
<li>标准流（普通流/文档流)</li>
</ul>
<p>标签按照规定好默认方式排列</p>
<ul>
<li>浮动</li>
</ul>
<p>可以改变默认的排列方式</p>
<ul>
<li>定位</li>
</ul>
<h4 id="浮动特性"><a href="#浮动特性" class="headerlink" title="浮动特性"></a>浮动特性</h4><ul>
<li>浮动后脱离标准流的控制移动到指定位置（脱标），浮动的盒子不再保留原先的位置</li>
<li>如果多个盒子设置了浮动，他们会按照属性值一行内显示并且顶端对齐排列</li>
<li>浮动元素会具有行内块特性，可以设定高度宽度，没写宽度时为内容宽度</li>
<li>浮动的盒子没有外边距合并的问题</li>
</ul>
<h4 id="浮动元素经常和标准流父级搭配使用"><a href="#浮动元素经常和标准流父级搭配使用" class="headerlink" title="浮动元素经常和标准流父级搭配使用"></a>浮动元素经常和标准流父级搭配使用</h4><p>先用标准流的父元素排列上下位置，之后内部子元素采用浮动排列左右位置，符合网页布局第一准则</p>
<p>先设置盒子大小，再设置盒子位置</p>
<p>标准流独占一行，不会被后面的浮动盒子影响，但如果前面盒子浮动，会上移</p>
<h4 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h4><p>清除浮动后，父级就会根据子盒子自动检测高度。父级有了高度后就不会影响下面的标准流。</p>
<p>选择器{clear:属性值;}</p>
<p>left/right/both</p>
<p>本质是清除浮动元素脱离标准流造成的影响</p>
<p>为什么要清除浮动</p>
<ul>
<li>父级没高度</li>
<li>子盒子浮动了</li>
<li>影响下面布局了</li>
</ul>
<h5 id="清除浮动方法"><a href="#清除浮动方法" class="headerlink" title="清除浮动方法"></a>清除浮动方法</h5><ul>
<li>额外标签法，也称隔墙法</li>
</ul>
<p>在最后一个浮动的子元素后面添加一个额外标签，添加清除浮动样式</p>
<p>实质是闭合浮动，只让浮动在父盒子内部影响，不影响父盒子外面的其他盒子</p>
<ul>
<li>父级添加<strong>overflow属性</strong></li>
</ul>
<p>overflow: hidden(清除)</p>
<p>外边距合并也是用这句代码</p>
<p>代码简洁但是无法显示溢出的部分</p>
<ul>
<li><strong>父级</strong>添加after伪元素</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.clearfix:after &#123;</span><br><span class="line">content:&quot;&quot;;</span><br><span class="line">display: block;</span><br><span class="line">height: 0;</span><br><span class="line">clear:both;</span><br><span class="line">visibility: hidden</span><br><span class="line">&#125;</span><br><span class="line">.clearfix &#123;</span><br><span class="line">*zoom: 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种是I6I7专有</p>
<p>一般约定就叫clearfix</p>
<p>百度淘宝网易等都用这种方式</p>
<ul>
<li>父级添加双伪元素</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">.clearfix:before,.clearfix:after &#123;</span><br><span class="line">content: &quot;&quot;;</span><br><span class="line">display:table;</span><br><span class="line">&#125;</span><br><span class="line">.clearfix:after &#123;</span><br><span class="line">clear: both;</span><br><span class="line">&#125;</span><br><span class="line">.clearfix &#123;</span><br><span class="line">*zoom: 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后一个照顾IE6IE7</p>
<p>代表网站：小米，腾讯</p>
<hr>
<h3 id="切图"><a href="#切图" class="headerlink" title="切图"></a>切图</h3><h4 id="常见图片格式"><a href="#常见图片格式" class="headerlink" title="常见图片格式"></a>常见图片格式</h4><ol>
<li>jpg:对色彩信息保留好，高清，颜色多，<strong>产品类图片</strong>经常用jpg</li>
<li>gif图像格式：只能存储256色，但是可以保存透明背景和动画效果，实际经常用于一些<strong>图片小动画效果</strong></li>
<li>png结合了gif和JPEG优点，能够保持<strong>透明背景</strong></li>
<li>PSD是PS专用格式，可以从上面直接复制文字，图片，还可以测量大小和距离</li>
</ol>
<h4 id="PS切图"><a href="#PS切图" class="headerlink" title="PS切图"></a>PS切图</h4><ol>
<li>点击图片，找到图层，右键快速导出PNG，有时需要合并图层后导出</li>
<li>切片切图，利用切片选中图片，导出选中的图片（文件-导出-存储位web所用格式-存储-切片（选中的切片）-保存</li>
<li>使用cutterman插件</li>
</ol>
<hr>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><h4 id="CSS属性书写顺序"><a href="#CSS属性书写顺序" class="headerlink" title="CSS属性书写顺序"></a>CSS属性书写顺序</h4><ol>
<li>布局定位属性（建议display第一个写）</li>
<li>自身属性</li>
<li>文本属性</li>
<li>其他属性</li>
</ol>
<h4 id="导航栏制作"><a href="#导航栏制作" class="headerlink" title="导航栏制作"></a>导航栏制作</h4><p>用li包含链接(li+a)的做法 ul&gt;li&gt;a</p>
<ol>
<li>li+a语义清晰</li>
<li>直接用a，搜索引擎容易辨别为堆砌关键字嫌疑，从而影响网站排名</li>
</ol>
<hr>
<h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><ol>
<li>可以染多个块级盒子一行没有缝隙排列显示，经常用于横向排列盒子</li>
<li>定位可以让盒子自由的在某个盒子内移动位置或者固定屏幕中的某个位置，并且压住其他盒子</li>
</ol>
<h4 id="定位组成"><a href="#定位组成" class="headerlink" title="定位组成"></a>定位组成</h4><p>定位=定位模式+边偏移</p>
<h5 id="定位模式"><a href="#定位模式" class="headerlink" title="定位模式"></a>定位模式</h5><p>position属性</p>
<p>值有四个：static(静态定位)/relative（相对）/absolute（绝对）/fixed(固定)</p>
<p>静态定位是按照标准流特性摆放位置，没有边偏移，很少使用</p>
<h5 id="边偏移"><a href="#边偏移" class="headerlink" title="边偏移"></a>边偏移</h5><p>top、bottom、left、right四个属性</p>
<p>表示距离顶部/底部/左侧/右侧x距离</p>
<p>如果既有left又有right则优先左侧，上下优先上</p>
<h4 id="相对定位-relative"><a href="#相对定位-relative" class="headerlink" title="相对定位 relative"></a>相对定位 relative</h4><p><code>position:relative</code></p>
<ol>
<li>以自身原来的位置为基础偏移</li>
<li>原来在标准流的位置<strong>继续占有</strong>，后面的盒子保留原来位置，不脱标</li>
</ol>
<h4 id="绝对定位-absolute"><a href="#绝对定位-absolute" class="headerlink" title="绝对定位 absolute"></a>绝对定位 absolute</h4><p><code>position:absolute</code></p>
<p>绝对定位是元素在移动位置时，相对它祖先元素来说的</p>
<ol>
<li>如果没有祖先元素或祖先元素没有定位，则以浏览器为准定位（Document文档）</li>
<li>如果祖先元素有定位（相对、绝对、固定），则以最近一级有定位的祖先元素为参考点移动位置</li>
<li>绝对定位<strong>不再占有</strong>原来的位置</li>
</ol>
<h4 id="子绝父相"><a href="#子绝父相" class="headerlink" title="子绝父相"></a>子绝父相</h4><p>子级绝对定位的话，父级要用相对定位</p>
<ol>
<li>父盒子必须占有位置，则只能相对定位，而子盒子不需要占有位置，则是绝对定位</li>
<li>某种情况下父绝子绝也会用到，当父亲不需要占有位置时</li>
</ol>
<h4 id="固定定位"><a href="#固定定位" class="headerlink" title="固定定位"></a>固定定位</h4><p><code>position:fixed</code></p>
<p>元素固定于浏览器可视区的某个位置，用于浏览器页面滚动时元素的位置不会改变</p>
<ol>
<li><p>以<strong>浏览器的可视窗口</strong>为参考元素</p>
<p>跟父元素无关，不随滚动条滚动</p>
</li>
<li><p>固定定位不再占有原先的位置</p>
</li>
</ol>
<p>如何让盒子固定在版心右侧位置？</p>
<ol>
<li>让固定定位的盒子left:50%,走到浏览器可视区的一半位置</li>
<li>让固定定位的盒子margin-left:-版心宽度的一半距离，多走版心宽度的一半位置</li>
</ol>
<h4 id="粘性定位"><a href="#粘性定位" class="headerlink" title="粘性定位"></a>粘性定位</h4><p>position:sticky; top:10px</p>
<ol>
<li>以浏览器的可视窗口为参照点移动元素（固定定位特点）</li>
<li>占有原先的位置（相对定位特点）</li>
<li>必须添加top、left、right、bottom其中一个，否则视为相对定位</li>
</ol>
<p>–兼容性较差，IE不支持–</p>
<h4 id="定位叠放顺序"><a href="#定位叠放顺序" class="headerlink" title="定位叠放顺序"></a>定位叠放顺序</h4><p><code>z-index:1;</code></p>
<ul>
<li>数值可以是正整数，负整数，或0，默认是auto，数值越大，盒子越靠上</li>
<li>如果属性值相同，按照书写顺序，后来居上</li>
<li>数字后面不能加定位</li>
<li>只有定位的盒子才有z-index属性</li>
</ul>
<h4 id="绝对定位居中"><a href="#绝对定位居中" class="headerlink" title="绝对定位居中"></a>绝对定位居中</h4><p>加了绝对定位的盒子不能用margin：0 auto 居中</p>
<p>方法：</p>
<ol>
<li>left: %50</li>
<li>margin-left: -自身宽度的一半</li>
</ol>
<p>垂直方向居中同理</p>
<h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><ol>
<li>行内元素添加绝对或者相对定位，可以直接给高度宽度</li>
<li>块级元素添加绝对或者固定定位，如果不给宽度或者高度，默认大小的内容的大小</li>
<li>脱标的盒子不会触发外边距塌陷</li>
<li>绝对定位（固定定位会完全压住盒子）</li>
</ol>
<p>浮动元素不同，只会压住下面标准流的盒子，但是不会压住下面标准流盒子里面的文字，绝对定位会压住所有内容</p>
<p>浮动产生的最初目的是为了做文字环绕效果的</p>
<hr>
<h3 id="元素的显示与隐藏"><a href="#元素的显示与隐藏" class="headerlink" title="元素的显示与隐藏"></a>元素的显示与隐藏</h3><p>某些元素，关闭后会消失，刷新时会出现</p>
<ol>
<li>display</li>
</ol>
<p>display:none ;隐藏对象，隐藏后不再占有原来的位置</p>
<p>dispaly:block ;除了转换为块级元素外，还有显示对象的意思</p>
<p>应用十分广泛，配合JS可以做很多网页特效</p>
<ol>
<li>visibility</li>
</ol>
<p>visibility：visible 元素可视</p>
<p>visibility：hidden 元素隐藏，隐藏后仍然占有原来的位置</p>
<ol>
<li>overflow</li>
</ol>
<ul>
<li>overflow：hidden 溢出部分隐藏</li>
<li>overflow：visible 不剪切内容也不添加滚动条</li>
<li>overflow：auto 不剪切内容<strong>在需要的时候</strong>添加滚动条</li>
<li>overflow：scroll 溢出的部分显示滚动条（不溢出也显示滚动条）</li>
</ul>
<p>一般情况下，不让溢出的内容显示出来，因为溢出的部分会影响布局</p>
<p>但是如果有定位的盒子，慎用overflow：hidden 会影响多余的部分</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS高级技巧</title>
    <url>/2021/03/11/CSS%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h3 id="精灵图"><a href="#精灵图" class="headerlink" title="精灵图"></a>精灵图</h3><h4 id="为什么需要精灵图"><a href="#为什么需要精灵图" class="headerlink" title="为什么需要精灵图"></a>为什么需要精灵图</h4><p>有效减少服务器接收和发送请求的次数，提高页面的加载速度，出现了CSS精灵技术（也称）CSS Sprites、CSS雪碧）</p>
<p>核心原理：将网页中一些小背景图像整合到一张大图中，这样只需要一次请求即可</p>
<p>使用精灵图：使用background-position属性，移动的是这个目标图片的x和y坐标</p>
<span id="more"></span>

<p>精灵图使用：</p>
<ol>
<li>使用ps切片选择需要的切片</li>
<li>找到w、h、x、y属性，用css实现</li>
</ol>
<p>缺点</p>
<ol>
<li>图片文件比较大</li>
<li>图片本身放大缩小会失真</li>
<li>一旦图片制作完毕想要更换比较复杂</li>
</ol>
<h3 id="字体图标"><a href="#字体图标" class="headerlink" title="字体图标"></a>字体图标</h3><p>字体图标iconfont，展示的是图片，本质是文字</p>
<p>优点</p>
<ol>
<li>轻量级：比图像小，随字体加载出来，减少了服务器请求</li>
<li>灵活性：可以改变颜色、阴影、透明效果、旋转等</li>
<li>兼容性：几乎支持所有浏览器</li>
</ol>
<p>不能替代精灵技术，只是对工作中图标部分技术的提升和优化</p>
<h4 id="字体图标的下载"><a href="#字体图标的下载" class="headerlink" title="字体图标的下载"></a>字体图标的下载</h4><p><a href="http://icomoon.io/">http://icomoon.io</a></p>
<p><a href="http://www.iconfont.cn/">http://www.iconfont.cn/</a></p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@font-face &#123;</span><br><span class="line">  font-family: &#39;icomoon&#39;;</span><br><span class="line">  src:  url(&#39;fonts&#x2F;icomoon.eot?cv7dvn&#39;);</span><br><span class="line">  src:  url(&#39;fonts&#x2F;icomoon.eot?cv7dvn#iefix&#39;) format(&#39;embedded-opentype&#39;),</span><br><span class="line">    url(&#39;fonts&#x2F;icomoon.ttf?cv7dvn&#39;) format(&#39;truetype&#39;),</span><br><span class="line">    url(&#39;fonts&#x2F;icomoon.woff?cv7dvn&#39;) format(&#39;woff&#39;),</span><br><span class="line">    url(&#39;fonts&#x2F;icomoon.svg?cv7dvn#icomoon&#39;) format(&#39;svg&#39;);</span><br><span class="line">  font-weight: normal;</span><br><span class="line">  font-style: normal;</span><br><span class="line">  font-display: block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用的元素中声明font-family: “icomoon”</p>
<h4 id="字体图标的追加"><a href="#字体图标的追加" class="headerlink" title="字体图标的追加"></a>字体图标的追加</h4><ol>
<li>把压缩包里的selection.json在网页里打开</li>
<li>选择新的图标</li>
<li>重新下载</li>
</ol>
<h3 id="CSS三角"><a href="#CSS三角" class="headerlink" title="CSS三角"></a>CSS三角</h3><p>让盒子的长宽为0，四个边框不为0，则会生成一个正方形其中四个三角形</p>
<p>–&gt;将其中一个边框设定颜色，其他位transparant，就会出现单独的三角形</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">    width: 0;</span><br><span class="line">    height: 0;</span><br><span class="line">    line-height: 0;</span><br><span class="line">    font-size: 0;</span><br><span class="line">    border: 50px solid transparent;</span><br><span class="line">    border-left-color: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>行高和字体大小是为了兼容性</p>
<h3 id="CSS用户界面样式"><a href="#CSS用户界面样式" class="headerlink" title="CSS用户界面样式"></a>CSS用户界面样式</h3><h4 id="鼠标样式"><a href="#鼠标样式" class="headerlink" title="鼠标样式"></a>鼠标样式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">li &#123;cursor: pointer&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>default: 小白箭头 默认</li>
<li>pointer：小手</li>
<li>move：移动</li>
<li>text：文字</li>
<li>not-allowed：禁止</li>
</ul>
<h4 id="轮廓线"><a href="#轮廓线" class="headerlink" title="轮廓线"></a>轮廓线</h4><p>默认选中输入（input/textarea标签）框的时候，会有个蓝色的外框线</p>
<p>给表单添加outline:0/none</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input&#123;outline:0 ;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="防止拖拽文本域"><a href="#防止拖拽文本域" class="headerlink" title="防止拖拽文本域"></a>防止拖拽文本域</h4><p>默认文本框（textarea）拖动右下角是可以拉大的，会影响布局</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">textarea&#123;resize: none;&#125;</span><br></pre></td></tr></table></figure>

<p>文本框的前标签和后标签应放在同一行，使光标在左上角，可以通过加padding改变位置</p>
<h4 id="vertical-align使用"><a href="#vertical-align使用" class="headerlink" title="vertical-align使用"></a>vertical-align使用</h4><p>经常用于设置图片或者表单和文字垂直对齐</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vertical-align :baseline |top |middle |bottom</span><br></pre></td></tr></table></figure>

<ul>
<li>baseline：默认，元素放置在父元素的基线上</li>
<li>top： 元素的顶端和行中最高元素的顶端对齐</li>
<li>middle：把元素放置在父元素中部</li>
<li>bottom： 把元素的顶端与行中最低的元素顶端对齐</li>
</ul>
<p>块级元素无法使用veritcal-align，有时需要先把块级元素转化为行内块元素</p>
<h4 id="图片底部空白缝隙"><a href="#图片底部空白缝隙" class="headerlink" title="图片底部空白缝隙"></a>图片底部空白缝隙</h4><p>原因是行内块元素会和文字基线对齐</p>
<ol>
<li>给图片添加vertial-align: middle |top |bottom（推荐）</li>
<li>把图片转换成块级元素display:block</li>
</ol>
<h4 id="溢出的文字省略号"><a href="#溢出的文字省略号" class="headerlink" title="溢出的文字省略号"></a>溢出的文字省略号</h4><ol>
<li>单行文本溢出</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">white-space: nowrap;</span><br><span class="line">overflow: hidden;</span><br><span class="line">text-overflow: ellipsis;</span><br></pre></td></tr></table></figure>

<p>强制一行显示–&gt;超出的部分隐藏–&gt;文字用省略号替代超出的部分</p>
<ol>
<li>多行文本溢出</li>
</ol>
<p>有较大兼容性问题，适合于WebKit浏览器（谷歌）或移动端（移动端大多数是webkit内核）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">overflow: hidden;</span><br><span class="line">text-overflow: ellipsis;</span><br><span class="line">display: -webkit-box;</span><br><span class="line">-webkit-line-clamp: 2;</span><br><span class="line">-webkit-box-orient: vertical;</span><br></pre></td></tr></table></figure>

<h3 id="常见布局技巧"><a href="#常见布局技巧" class="headerlink" title="常见布局技巧"></a>常见布局技巧</h3><h4 id="margin负值："><a href="#margin负值：" class="headerlink" title="margin负值："></a>margin负值：</h4><p>可以用于解决相邻盒子边框重叠后变粗的问题</p>
<p>float要放在margin：-1前面</p>
<p>当鼠标经过时改变边框颜色，会出现边框被其他边框压住的问题</p>
<p>–&gt;如果没有定位，加相对定位，如果有定位，则加z-index提高层级</p>
<h4 id="文字围绕浮动元素"><a href="#文字围绕浮动元素" class="headerlink" title="文字围绕浮动元素"></a>文字围绕浮动元素</h4><p>浮动元素周围的文字会自动围绕该元素，可以用于实现左图右文字的模块或者新闻中图片样式</p>
<h4 id="行内块元素巧妙应用"><a href="#行内块元素巧妙应用" class="headerlink" title="行内块元素巧妙应用"></a>行内块元素巧妙应用</h4><p>页码的布局</p>
<p>行内块默认有大小，且自带距离，使用text-align：center即可水平居中对齐</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 给父亲添加text-align:center即可实现所有子元素水平居中 --&gt;</span><br><span class="line">.box &#123;</span><br><span class="line">    text-align: center</span><br><span class="line">&#125;</span><br><span class="line">.box a&#123;</span><br><span class="line">    display: inline-block;</span><br><span class="line">    width: 36px;</span><br><span class="line">    height:36px;</span><br><span class="line">    background-color: #f7f7f7;</span><br><span class="line">    border: 1px solid #ccc;</span><br><span class="line">    text-align: center;</span><br><span class="line">    line-height: 36px;</span><br><span class="line">    text-decoration: 36px;</span><br><span class="line">    color: #333;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="三角的巧妙应用"><a href="#三角的巧妙应用" class="headerlink" title="三角的巧妙应用"></a>三角的巧妙应用</h4><p>实现某些价格标签中的斜三角</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">    width: 0;</span><br><span class="line">    height: 0;</span><br><span class="line">    &#x2F;* 只保留右边边框 *&#x2F;</span><br><span class="line">    border-color: transparent red transparent transparent;</span><br><span class="line">    border-style: solid;</span><br><span class="line">    &#x2F;* 上大右小 *&#x2F;</span><br><span class="line">    border-width: 22px 8px 0 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CSS初始化"><a href="#CSS初始化" class="headerlink" title="CSS初始化"></a>CSS初始化</h4><p>不同浏览器对某些标签的默认值是不同的，为了清除不同浏览器对html文本呈现的差异，照顾浏览器的兼容性，需要初始化</p>
<p>Unicode编码字体：</p>
<p>把中文字体的名称用相应的unicode编码代替，有效的避免浏览器解释css代码时出现乱码</p>
<p>“5B8B\4F53”表示宋体/黑体</p>
<p>京东初始化代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* 把我们所有标签的内外边距清零 *&#x2F;</span><br><span class="line">* &#123;</span><br><span class="line">    margin: 0;</span><br><span class="line">    padding: 0;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;* em 和 i 斜体的文字不倾斜 *&#x2F;</span><br><span class="line">em,</span><br><span class="line">i &#123;</span><br><span class="line">    font-style: normal;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;* 去掉li 的小圆点 *&#x2F;</span><br><span class="line">li &#123;</span><br><span class="line">    list-style: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">img &#123;</span><br><span class="line">    &#x2F;* border 0 照顾低版本浏览器 如果 图片外面包含了链接会有边框的问题 *&#x2F;</span><br><span class="line">    border: 0;</span><br><span class="line">    &#x2F;* 取消图片底侧有空白缝隙的问题 *&#x2F;</span><br><span class="line">    vertical-align: middle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">button &#123;</span><br><span class="line">    &#x2F;* 当我们鼠标经过button 按钮的时候，鼠标变成小手 *&#x2F;</span><br><span class="line">    cursor: pointer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a &#123;</span><br><span class="line">    color: #666;</span><br><span class="line">    text-decoration: none</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a:hover &#123;</span><br><span class="line">    color: #c81623;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">button,</span><br><span class="line">input &#123;</span><br><span class="line">    &#x2F;* &quot;\5B8B\4F53&quot; 就是宋体的意思 这样浏览器兼容性比较好 *&#x2F;</span><br><span class="line">    font-family: Microsoft YaHei, Heiti SC, tahoma, arial, Hiragino Sans GB, &quot;\5B8B\4F53&quot;, sans-serif;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">body &#123;</span><br><span class="line">    &#x2F;* CSS3 抗锯齿形 让文字显示的更加清晰 *&#x2F;</span><br><span class="line">    -webkit-font-smoothing: antialiased;</span><br><span class="line">    background-color: #fff;</span><br><span class="line">    font: 12px&#x2F;1.5 Microsoft YaHei, Heiti SC, tahoma, arial, Hiragino Sans GB, &quot;\5B8B\4F53&quot;, sans-serif;</span><br><span class="line">    color: #666;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.hide,</span><br><span class="line">.none &#123;</span><br><span class="line">    display: none;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;* 清除浮动 *&#x2F;</span><br><span class="line">.clearfix:after &#123;</span><br><span class="line">    visibility: hidden;</span><br><span class="line">    clear: both;</span><br><span class="line">    display: block;</span><br><span class="line">    content: &quot;.&quot;;</span><br><span class="line">    height: 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.clearfix &#123;</span><br><span class="line">    *zoom: 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS移动端开发</title>
    <url>/2021/03/13/CSS%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<p>​    移动端浏览器主要对webkit内核兼容，现在的移动端主要针对手机端开发，移动端碎片化比较严重，分辨率和屏幕尺寸不一</p>
<span id="more"></span>

<h2 id="调试方法"><a href="#调试方法" class="headerlink" title="调试方法"></a>调试方法</h2><ol>
<li>谷歌浏览器模拟手机调试</li>
<li>搭建本地web服务器，手机和服务器在同一个局域网内，通过手机访问服务器</li>
<li>使用外网服务器，直接IP或域名访问</li>
</ol>
<h2 id="视口"><a href="#视口" class="headerlink" title="视口"></a>视口</h2><p>视口就是浏览器显示页面内容的屏幕区域。视口可以分布为布局视口、视觉视口和理想视口</p>
<h3 id="布局视口layout-viewport"><a href="#布局视口layout-viewport" class="headerlink" title="布局视口layout viewport"></a>布局视口layout viewport</h3><ul>
<li>一般移动设备的浏览器都默认设置了一个布局视口，用于解决早期的PC端页面在手机上显示的问题</li>
<li>IOS、Android都把视口分辨率设置为980px，所以pc端上的页面大多都能在手机上呈现，只不过元素看起来很小，一般只能手动缩放页面</li>
</ul>
<h3 id="视觉视口-visual-viewport"><a href="#视觉视口-visual-viewport" class="headerlink" title="视觉视口 visual viewport"></a>视觉视口 visual viewport</h3><p>用户正在看到的网站的区域，可以通过缩放操作视觉视口，但是不会影响布局视口，布局视口仍然保持原来的宽度</p>
<h3 id="理想视口-ideal-viewport"><a href="#理想视口-ideal-viewport" class="headerlink" title="理想视口 ideal viewport"></a>理想视口 ideal viewport</h3><ul>
<li>为了使网站在移动端有最理想的浏览和阅读宽度而设定</li>
<li>理想视口，对设备来讲，是最理想的视口尺寸</li>
<li>需要手写meta视口标签来通知浏览器操作</li>
<li>meta视口标签的目的：布局视口的宽度和理想视口的宽度保持一致，就是设备有多宽，布局的视口就有多宽</li>
</ul>
<h3 id="meta视口标签"><a href="#meta视口标签" class="headerlink" title="meta视口标签"></a>meta视口标签</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, user-scalable&#x3D;no,initial-scale&#x3D;1.0,maximum-scale&#x3D;1.0,minimum-scale&#x3D;1.0&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>width viewport宽度，可以设置device-width特殊值</p>
<p>initial-scale 初始缩放比，大于0的数字</p>
<p>maximum-scale  最大缩放比，大于0的数字</p>
<p>minimum-scale   最小缩放比，大于0的数字</p>
<p>user-scalable  用户是否可以缩放，yes或no</p>
<p>视口宽度和设备一致、默认缩放比1:0，不允许用户自行缩放、最大允许缩放比1.0，最小允许缩放比1.0</p>
<h2 id="二倍图"><a href="#二倍图" class="headerlink" title="二倍图"></a>二倍图</h2><h3 id="物理像素-amp-物理像素比"><a href="#物理像素-amp-物理像素比" class="headerlink" title="物理像素&amp;物理像素比"></a>物理像素&amp;物理像素比</h3><p>物理像素点指屏幕显示的最小颗粒，1px在PC端等于1物理像素，但是移动端不一定，一个1px能显示多少物理像素点成为屏幕像素比</p>
<ul>
<li>视网膜屏幕是一种显示技术，把更多物理像素点压缩至一块屏幕内，从而达到更多分辨率</li>
</ul>
<h3 id="多倍图"><a href="#多倍图" class="headerlink" title="多倍图"></a>多倍图</h3><p>图片在手机中打开，会按照物理像素比放大，出现模糊现象，因此用倍图的方式（放二倍大小的图片再缩小到需要的大小）</p>
<h3 id="背景缩放"><a href="#背景缩放" class="headerlink" title="背景缩放"></a>背景缩放</h3><ul>
<li>background-size  </li>
<li>规定背景图像尺寸，两个参数为高度，宽度，只写一个参数就是指宽度，等比例缩放</li>
<li>单位可以是百分比，是相对父盒子的百分比</li>
<li>cover：等比例缩放，要求完全覆盖盒子 ，可能有部分背景图片显示不全</li>
<li>contain: 等比例缩放，尽量铺满不会超出，可能会有空白</li>
</ul>
<h2 id="移动端开发选择"><a href="#移动端开发选择" class="headerlink" title="移动端开发选择"></a>移动端开发选择</h2><p>单独制作移动端页面（主流）</p>
<p>响应式页面兼容移动端</p>
<h2 id="移动端技术解决方案"><a href="#移动端技术解决方案" class="headerlink" title="移动端技术解决方案"></a>移动端技术解决方案</h2><p>###移动端初始化nomalize.css</p>
<p><a href="http://necolas.github.io/normalize.css/">http://necolas.github.io/normalize.css/</a></p>
<h3 id="CSS3盒子模型box-sizing"><a href="#CSS3盒子模型box-sizing" class="headerlink" title="CSS3盒子模型box-sizing"></a>CSS3盒子模型box-sizing</h3><p>boxing-size:border-box;(传统是content-box)</p>
<p>padding和border不会再撑大盒子</p>
<p>移动端可以完全兼容CSS3</p>
<h3 id="特殊样式"><a href="#特殊样式" class="headerlink" title="特殊样式"></a>特殊样式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-webkit-tap-highlight-color: transparent;&#x2F;&#x2F;清除高亮</span><br><span class="line">-webkit-appearance: none;&#x2F;&#x2F;在ios上加上这个属性才可以给按钮和输入框自定义样式</span><br><span class="line">img,a&#123;-webkit-touch-callout:none&#125;&#x2F;&#x2F;禁止长按页面时弹出菜单</span><br></pre></td></tr></table></figure>

<h3 id="二倍精灵图"><a href="#二倍精灵图" class="headerlink" title="二倍精灵图"></a>二倍精灵图</h3><p>background-size缩放的是整个精灵图</p>
<ul>
<li>在firework里把精灵图等比例缩放为原来的一半</li>
<li>根据大小测量坐标</li>
<li>代码里的bgcsize也要缩放</li>
</ul>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>JS-1-基本语法</title>
    <url>/2021/03/11/JS-1-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h2 id="初识JavaScript"><a href="#初识JavaScript" class="headerlink" title="初识JavaScript"></a>初识JavaScript</h2><ul>
<li>JavaScript是一种运行在客户端的脚本语言</li>
<li>脚本语言：不需要编译，运行过程中由js解释器（js引擎）逐行来进行解释并执行</li>
<li>现在也可以基于Node.js技术进行服务器编程</li>
</ul>
<span id="more"></span>

<ul>
<li>浏览器分为渲染引擎和JS引擎，渲染引擎用来解析HTML和CSS，俗称内核，比如chrome浏览器的blink，老版本的webkit,JS引擎也成js解释器，用来读取网页中的JavaScript代码，对其处理后运行，比如chrome浏览器的V8</li>
<li>JS引擎执行代码时逐行解释每一句原码，然后由计算机取执行，所以归为脚本语言</li>
</ul>
<h2 id="JS作用"><a href="#JS作用" class="headerlink" title="JS作用"></a>JS作用</h2><ul>
<li>表单动态校验</li>
<li>网页特效</li>
<li>服务端开发(Node.js)</li>
<li>桌面程序（Electron)</li>
<li>App（Cordova）</li>
<li>控制硬件-物联网（Ruff）</li>
<li>游戏开发（cocos2D-js）</li>
</ul>
<h2 id="JS组成"><a href="#JS组成" class="headerlink" title="JS组成"></a>JS组成</h2><ul>
<li>ECMAScript ：规定了JS的编程语法和基础核心知识，是所有浏览器厂商共同遵守的一套JS语法工业标准</li>
<li>DOM：文档对象模型</li>
<li>BOM：浏览器对象模型，提供了独立于内容的，可以与浏览器窗口互动的对象结构，通过BOM可以操作浏览器窗口，比如弹出框、控制浏览器跳转、获取分辨率等</li>
</ul>
<h2 id="书写方法"><a href="#书写方法" class="headerlink" title="书写方法"></a>书写方法</h2><ul>
<li>行内式：写在元素内部，JS中推荐用单引号，可读性差，一般特殊情况下使用</li>
<li>内嵌式：</li>
<li>外部JS文件：</li>
</ul>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ul>
<li>单行注释//                 ctrl+/</li>
<li>多行注释/* */            shift+alt+a</li>
</ul>
<h3 id="常用输入输出语句"><a href="#常用输入输出语句" class="headerlink" title="常用输入输出语句"></a>常用输入输出语句</h3><ul>
<li>alert(msg)   浏览器弹出警示框</li>
<li>console.log(msg)  浏览器控制台打印输出信息</li>
<li>prompt(info)  浏览器弹出输入框，用户可以接入</li>
</ul>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h4 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var age;</span><br></pre></td></tr></table></figure>

<h4 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">age&#x3D;18;</span><br></pre></td></tr></table></figure>

<h4 id="变量的初始化"><a href="#变量的初始化" class="headerlink" title="变量的初始化"></a>变量的初始化</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var age&#x3D;18;</span><br></pre></td></tr></table></figure>

<h4 id="变量更新"><a href="#变量更新" class="headerlink" title="变量更新"></a>变量更新</h4><p>多次赋值后会被覆盖</p>
<h4 id="声明多个变量"><a href="#声明多个变量" class="headerlink" title="声明多个变量"></a>声明多个变量</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var age&#x3D;18,</span><br><span class="line">address&#x3D;&#39;sss&#39;,</span><br><span class="line">gz&#x3D;&#39;2000&#39;;</span><br></pre></td></tr></table></figure>

<h4 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h4><ul>
<li>不能是关键字或者保留字</li>
<li>区分大小写</li>
<li>只能字母数字下划线组成，不能数字开头</li>
<li>首字母小写，后面单词字母需要大写</li>
</ul>
<h4 id="标识符、关键字、保留字"><a href="#标识符、关键字、保留字" class="headerlink" title="标识符、关键字、保留字"></a>标识符、关键字、保留字</h4><p>标识符：开发人员为变量、属性、函数、参数取的名字</p>
<p>关键字：JS已经使用了的字，不能作为变量名、方法名</p>
<p>保留字：预留的关键字</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>JS是一种弱类型或者说动态语言，意味着不用提前声明变量的类型，在程序运行过程中，类型会被自动确定</p>
<h4 id="简单数据类型"><a href="#简单数据类型" class="headerlink" title="简单数据类型"></a>简单数据类型</h4><ul>
<li>number：数字型，JS中八进制前面要加0，十六进制前加0x</li>
</ul>
<p>数字类型有三个特殊值，infinity、-infinity、NaN（代表非数值）</p>
<p>可以用isNaN判断是否是数字，</p>
<ul>
<li>boolean：布尔型类型，默认为false</li>
<li>string： 字符串类型，默认值为“”</li>
</ul>
<p>外用单引号，里面用双引号，或者外双内单</p>
<p>可以用length获取字符串长度</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str.length</span><br></pre></td></tr></table></figure>

<p>字符串拼接</p>
<p>字符串+任意类型=拼接后的新字符串，拼接前把任意类型转化为字符串</p>
<ul>
<li>undefined： 声明了但是没有给值，默认值为undefined</li>
<li>null：空类型，默认值为null</li>
</ul>
<h4 id="数据类型的检测"><a href="#数据类型的检测" class="headerlink" title="数据类型的检测"></a>数据类型的检测</h4><ul>
<li>typeof</li>
<li>字面量字面量是源代码中一个固定值的表示法，通俗来说就是字面量表示如何表达这个值</li>
</ul>
<h4 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h4><p>把一种数据类型的变量转换成另一种数据类型</p>
<p>转换成字符串型：</p>
<ul>
<li>toString() </li>
<li>String()强制转换</li>
<li>加号拼接字符串，和字符串拼接的结果都是字符串，这种方法也称为隐式转换</li>
</ul>
<p>转换成数字型（前两个重点）</p>
<ul>
<li>parseInt(string)： 可以把带单位的值变数字120px-120,得到是整数</li>
<li>parseFloat(string)：得到是浮点数</li>
<li>Numer()</li>
<li>js隐式转换，利用算术运算 如：’12’-0 ‘12’*1 ‘12’/1 加号是转化成字符串</li>
</ul>
<p>转化成布尔型</p>
<ul>
<li>Boolean()代表空、否定的值会被转换为false，如’’,0,NaN,null,undefined,其余值都会转化为true</li>
</ul>
<h3 id="解释型语言和编译型语言"><a href="#解释型语言和编译型语言" class="headerlink" title="解释型语言和编译型语言"></a>解释型语言和编译型语言</h3><p>编译和解释的区别在于翻译的<strong>时间点</strong>不同，编译器是代码执行之前进行编译生成机器语言，解释器读到每一行都解释为机器语言并执行，java是编译语言，js是解释型语言</p>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>+-*/%   (%是取余，一般用于判断能否被整除)</p>
<h3 id="表达式和返回值"><a href="#表达式和返回值" class="headerlink" title="表达式和返回值"></a>表达式和返回值</h3><p>由数字变量运算符等组成的式子</p>
<h3 id="递增运算符和递减运算符"><a href="#递增运算符和递减运算符" class="headerlink" title="递增运算符和递减运算符"></a>递增运算符和递减运算符</h3><p>++ –</p>
<ol>
<li>放在变量前面，表示前置递增，放在变量后面，表示前置递减</li>
<li>必须和变量配合使用</li>
<li>++在前，先加后返回值；++在后先返回值后自加1</li>
<li>开发中大多数使用后置递增/递减，代码独占一行</li>
</ol>
<h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><ul>
<li>&lt; &gt;  &gt;=  &lt;=  == !=  </li>
<li>===  ！==全等、不全等，要求值和数据类型都一致</li>
</ul>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>&amp;&amp; || ！</p>
<p>短路运算（逻辑中断）：当有多个表达式时，左边的表达式值可以确定结果时，就不再继续运算右边的表达式的值</p>
<h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><ul>
<li>=</li>
<li>+=   -=   加、减一个数后再赋值</li>
<li>*=   /=  %= 乘、除、取模后赋值</li>
</ul>
<h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><ul>
<li>1  ()</li>
<li>2  ++   –  !</li>
<li>3  先*/%后+-</li>
<li>4 &gt; &gt;= &lt; &lt;=</li>
<li>5  == ！= === ！==</li>
<li>6  先&amp;&amp;后||</li>
<li>7  =</li>
<li>8  ，</li>
</ul>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>分为顺序结构、分支结构、循环结构三种，会按照代码的先后顺序依次执行</p>
<h3 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(条件表达式) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">else if ()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;三元表达式</span><br><span class="line">num&gt;5?&#39;11&#39;:&#39;22&#39;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;switch</span><br><span class="line">switch(表达式) &#123;</span><br><span class="line">	case value1:</span><br><span class="line">		执行语句1;</span><br><span class="line">		break;</span><br><span class="line">	case value2:</span><br><span class="line">		执行语句2;</span><br><span class="line">		break;</span><br><span class="line">	default:</span><br><span class="line">		执行语句</span><br></pre></td></tr></table></figure>

<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;for循环</span><br><span class="line">for(初始化变量；条件表达式；操作表达式)&#123;</span><br><span class="line"> &#x2F;&#x2F;循环体</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;while</span><br><span class="line">while(条件表达式) &#123;</span><br><span class="line">    &#x2F;&#x2F;循环体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; do while 先执行一次循环体，如果条件表达式为真，则继续执行循环体</span><br><span class="line">do &#123;</span><br><span class="line">    &#x2F;&#x2F;循环体</span><br><span class="line">&#125;while(条件表达式)</span><br></pre></td></tr></table></figure>

<p>continue;</p>
<p>break;</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr&#x3D; [1,2,3,4];</span><br></pre></td></tr></table></figure>

<p>利用new创建数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var 数组名&#x3D;new Array();</span><br><span class="line">var arr&#x3D;new Array();</span><br></pre></td></tr></table></figure>

<p>利用数组字面量创建数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var 数组名&#x3D;[];</span><br><span class="line">var 数组名&#x3D;[1,2,3];</span><br></pre></td></tr></table></figure>

<p>数组里可以存放数字、字符串、布尔型等</p>
<h3 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h3><p>可以通过循环</p>
<h3 id="数组新增元素"><a href="#数组新增元素" class="headerlink" title="数组新增元素"></a>数组新增元素</h3><ol>
<li>修改length长度</li>
<li>直接增加索引号，追加数组元素</li>
</ol>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="声明函数"><a href="#声明函数" class="headerlink" title="声明函数"></a>声明函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function 函数名(形参) &#123;</span><br><span class="line">    &#x2F;&#x2F;函数体</span><br><span class="line">&#125;</span><br><span class="line">var 变量名&#x3D;function()&#123;</span><br><span class="line">    &#x2F;&#x2F;匿名函数，fun是变量名，不是函数名，但是调用的时候可以fun()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h3><p>函数名(实参);</p>
<h3 id="形参实参不匹配"><a href="#形参实参不匹配" class="headerlink" title="形参实参不匹配"></a>形参实参不匹配</h3><ul>
<li>个数相等，正常输出</li>
<li>实参个数大于形参个数，得到形参个数</li>
<li>实参个数小于形参个数，多的形参值视为undefined，相加结果为NaN</li>
</ul>
<h3 id="函数返回"><a href="#函数返回" class="headerlink" title="函数返回"></a>函数返回</h3><p>return</p>
<ul>
<li>return后面的语句不会再被执行</li>
<li>return只能返回一个值，如果返回多个，返回的结果是最后一个</li>
<li>函数没有return则返回undefined</li>
</ul>
<h3 id="Arguements的使用"><a href="#Arguements的使用" class="headerlink" title="Arguements的使用"></a>Arguements的使用</h3><p>当不确定有多少个参数传递的时候，可以用arguments来获取，在JS中，arguments实际上是当前函数的一个内置对象，所有函数都内置了一个arguments对象，arguments对象存储了传递的所有实参</p>
<ul>
<li>是一个伪数组</li>
<li>没有真正数组的一些方法</li>
<li>按照索引的方式存储的</li>
</ul>
<h2 id="JS作用域"><a href="#JS作用域" class="headerlink" title="JS作用域"></a>JS作用域</h2><ul>
<li>作用域就是代码名字在某个范围内起效果，目的是在某个范围内起作用和效果，目的是提高程序的可靠性，重要的是减少命名冲突</li>
<li>es6之前，js的作用域分为全局作用域和局部作用域</li>
<li>全局作用域：整个script标签  或者一个单独的js文件</li>
<li>局部作用域：在函数内部就是局部作用域，这个代码的名字只在函数内部起效果和作用</li>
<li>全局变量只有在浏览器关闭的时候才会销毁，局部变量只要在程序执行完毕就会销毁，比较节约内存资源</li>
</ul>
<h3 id="JS没有块级作用域（es6会新增）"><a href="#JS没有块级作用域（es6会新增）" class="headerlink" title="JS没有块级作用域（es6会新增）"></a>JS没有块级作用域（es6会新增）</h3><p>块级作用域{}，即只能在大括号里使用的变量</p>
<h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>函数嵌套函数时，就会嵌套一个新的作用域；</p>
<p>根据内部函数可以访问外部函数变量的机制，就用<strong>链式查找</strong>的方式，决定哪些数据能被内部函数访问（取哪个值），就称为作用域链，类似就近原则</p>
<h3 id="JS预解析"><a href="#JS预解析" class="headerlink" title="JS预解析"></a>JS预解析</h3><p>JS解析器在运行代码的时候，分为预解析和代码执行两步，预解析时，js会先将js里面所有var还有function提升到当前作用域的最前面</p>
<p>预解析分为变量预解析（变量提升）和函数预解析（函数提升）</p>
<p>（1）变量提升：把所有的变量声明提升到当前的作用域最前面，不提供赋值操作</p>
<p>（2）函数提升：把所有的函数声明提升到当前的作用域最前面，不提供调用操作</p>
<h2 id="JS对象"><a href="#JS对象" class="headerlink" title="JS对象"></a>JS对象</h2><p>对象：一个具体的事物，可以是一个数据库，一个网页，一个远程服务器的连接</p>
<p>对象是由属性和方法组成的</p>
<ul>
<li>属性：事物的特征，在对象中用属性来表示（常用名词</li>
<li>方法：事物的行为，在对象中用方法来表示（常用动词</li>
</ul>
<h3 id="为什么需要对象"><a href="#为什么需要对象" class="headerlink" title="为什么需要对象"></a>为什么需要对象</h3><p>数组很难保存一个人的完整信息，可以使用对象实现</p>
<p>var arr={‘你好’，’男’,128,154};</p>
<h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><h5 id="字面量方法："><a href="#字面量方法：" class="headerlink" title="字面量方法："></a>字面量方法：</h5><p>属性或者方法采用键值对的形式，多个属性之间用逗号隔开，方法冒号后面跟的是一个匿名函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;字面量创建对象</span><br><span class="line">var obj&#x3D; &#123;</span><br><span class="line">    usname: &#39;张三&#39;,</span><br><span class="line">    age :18,</span><br><span class="line">    say: function() &#123;</span><br><span class="line">        console.log(&#39;hi&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(obj.uname);&#x2F;&#x2F;调用属性</span><br><span class="line">console.log(obj[&#39;age&#39;]);&#x2F;&#x2F;调用属性的第二种方法</span><br><span class="line">obj.say();&#x2F;&#x2F;调用对象的方法</span><br></pre></td></tr></table></figure>

<h5 id="利用new-object创建对象"><a href="#利用new-object创建对象" class="headerlink" title="利用new object创建对象"></a>利用new object创建对象</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj &#x3D;new Object();</span><br><span class="line">obj.usename&#x3D;&#39;张三&#39;;</span><br><span class="line">obj.age&#x3D;18;</span><br><span class="line">obj.say&#x3D;function()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="利用构造函数创建对象"><a href="#利用构造函数创建对象" class="headerlink" title="利用构造函数创建对象"></a>利用构造函数创建对象</h5><p>前面两个创建对象的方式只能一次创建一个对象，可以利用构造函数批量构造，这种函数称为构造函数,这种函数封装的不是普通代码，而是对象</p>
<p>定义：把对象里一些相同的属性和方法抽象出来封装到函数里</p>
<p>构造函数的语法格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function 构造函数名() &#123;</span><br><span class="line">    this.属性&#x3D;值；</span><br><span class="line">    this.方法&#x3D;function() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">new 构造函数名()</span><br><span class="line">-------</span><br><span class="line">function Star(uname,age,sex) &#123;</span><br><span class="line">    this.name&#x3D;uname;</span><br><span class="line">    this.age&#x3D;age;</span><br><span class="line">    this.sex&#x3D;sex;</span><br><span class="line">&#125;</span><br><span class="line">new Star(&#39;张三&#39;,18,&#39;男&#39;);</span><br></pre></td></tr></table></figure>

<ul>
<li>构造函数名字首字母要大写</li>
<li>构造函数不需要return就可以返回结果</li>
<li>新建构造函数必须用new</li>
<li>只要new Star()   调用函数就创建一个对象</li>
<li>属性和方法前必须加this</li>
</ul>
<h4 id="遍历对象"><a href="#遍历对象" class="headerlink" title="遍历对象"></a>遍历对象</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (变量 in 对象)</span><br><span class="line">for (var k in obj) &#123;&#x2F;&#x2F;一般喜欢用k或key</span><br><span class="line">    console.log(k);&#x2F;&#x2F;得到属性名</span><br><span class="line">    console.log(obj[k]);&#x2F;&#x2F;得到属性值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法也会被遍历出来</p>
<h3 id="JS内置对象"><a href="#JS内置对象" class="headerlink" title="JS内置对象"></a>JS内置对象</h3><ul>
<li>JS中对象分为自定义对象、内置对象、浏览器对象</li>
<li>前两种是ECMAScript，第三个是JS独有的</li>
<li>内置对象是JS中自带的一些对象，提供了最常用和基本的功能，帮助我们快速开发</li>
<li>内置对象包括Math、Date、Array、String等</li>
</ul>
<h4 id="MDN"><a href="#MDN" class="headerlink" title="MDN"></a>MDN</h4><p>Mozilla开发者网络（MDN）提供了有关开放网络技术的信息，包括HTML、CSS和万维网及HTML5应用的API</p>
<h4 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h4><p>是一个内置对象，不是构造函数，不需要通过new调用</p>
<p>Math.PI   Math.max(非数值型返回NaN，无参数返回-infinite)</p>
<p>Math.abs() 取绝对值Math.ceil()向上取整 Math.floor()向下取整  Math.round() 四舍五入</p>
<h5 id="随机数方法"><a href="#随机数方法" class="headerlink" title="随机数方法"></a>随机数方法</h5><p>Math.random():返回一个随机小数，0&lt;=x&lt;1,浮点数</p>
<h4 id="日期对象"><a href="#日期对象" class="headerlink" title="日期对象"></a>日期对象</h4><ul>
<li>date是个构造函数,必须使用new调用</li>
<li>如果没有输入参数，则返回当前系统的当前时间</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var today&#x3D;new Date();</span><br><span class="line">var date1&#x3D;new Date(2019,10,1);&#x2F;&#x2F;月份要小一个月，是从0-11的月</span><br><span class="line">var date2&#x3D;new Date(&#39;2019-10-1 8:8:8&#39;);</span><br></pre></td></tr></table></figure>

<h5 id="日期格式化"><a href="#日期格式化" class="headerlink" title="日期格式化"></a>日期格式化</h5><ul>
<li>date.getFullYear()   返回年</li>
<li>date.getMonth()+1    返回月份</li>
<li>date.getDate()    返回几号</li>
<li>date.getHours()</li>
<li>date.getMinutes()</li>
<li>date.getSeconds()</li>
</ul>
<p>获得Date总的毫秒数，是距离1970年1月1日过了多少毫秒数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var date&#x3D;new Date()</span><br><span class="line"></span><br><span class="line">console.log(date.valueOf());</span><br><span class="line">console.log(date.getTime());</span><br><span class="line"></span><br><span class="line">var date1&#x3D;+new Date();&#x2F;&#x2F;最常用的写法</span><br><span class="line">console.log(date1);</span><br><span class="line"></span><br><span class="line">console.log(Date.now());&#x2F;&#x2F;H5新增的获得总的毫秒数</span><br></pre></td></tr></table></figure>

<h4 id="数组对象"><a href="#数组对象" class="headerlink" title="数组对象"></a>数组对象</h4><h5 id="检测是否为数组"><a href="#检测是否为数组" class="headerlink" title="检测是否为数组"></a>检测是否为数组</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(arr instanceof Array);&#x2F;&#x2F;（1）用instanceof检测</span><br><span class="line">console.log(Array.isArray(arr));&#x2F;&#x2F;(2)优先于instanceof，H5新增，IE9以上版本支持</span><br></pre></td></tr></table></figure>

<h5 id="增加数组元素"><a href="#增加数组元素" class="headerlink" title="增加数组元素"></a>增加数组元素</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arr.push(1)&#x2F;&#x2F;在arr数组中添加1,返回的结果是新数组的长度</span><br><span class="line">arr.unshift(&#39;red&#39;，‘green&#39;);&#x2F;&#x2F;在arr数组前添加&#39;red&#39;,&#39;green&#39;,返回新数组的长度</span><br></pre></td></tr></table></figure>

<h5 id="删除数组元素"><a href="#删除数组元素" class="headerlink" title="删除数组元素"></a>删除数组元素</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arr.pop()&#x2F;&#x2F;删除数组的最后一个元素，返回值是删除掉的元素</span><br><span class="line">arr.shift()&#x2F;&#x2F;删除数组的第一个元素，shift完毕后，返回第一个元素的值</span><br></pre></td></tr></table></figure>

<h5 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arr.reverse(); &#x2F;&#x2F;翻转数组</span><br><span class="line">arr.sort();&#x2F;&#x2F;数组排序，比较的是字符串，数字排序要用以下方法</span><br><span class="line">arr.sort(function(a,b))&#123;</span><br><span class="line">    return a-b;&#x2F;&#x2F;升序排列，b-a是降序</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="数组索引方法"><a href="#数组索引方法" class="headerlink" title="数组索引方法"></a>数组索引方法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arr.indexOf(&#39;blue&#39;)&#x2F;&#x2F;返回该数组元素的索引号</span><br><span class="line">&#x2F;&#x2F;只返回第一个满足条件的索引号，如果在该数组中找不到元素，则返回-1</span><br><span class="line">arr.lastIndexOf(&#39;blue&#39;)&#x2F;&#x2F;倒序查找</span><br></pre></td></tr></table></figure>

<h5 id="数组转化为字符串"><a href="#数组转化为字符串" class="headerlink" title="数组转化为字符串"></a>数组转化为字符串</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arr.toString()&#x2F;&#x2F;</span><br><span class="line">arr.join()&#x2F;&#x2F;默认逗号分隔</span><br><span class="line">arr.join(&#39;-&#39;)；&#x2F;&#x2F;用-分隔</span><br><span class="line">arr.join(&#39;&amp;&#39;)；&#x2F;&#x2F;表单常用分隔符</span><br></pre></td></tr></table></figure>

<p>其他</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arr.concat()  &#x2F;&#x2F;拼接两个或多个数组，不影响原数组，返回一个新数组</span><br><span class="line">arr.slice()  &#x2F;&#x2F;数组截取，返回被截取项目的新数组slice(begin,end)</span><br><span class="line">arr.splice()  &#x2F;&#x2F;数组删除splice（第几个开始，要删除个数）  返回被删除项目的新数组，会影响原数组</span><br></pre></td></tr></table></figure>

<h4 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h4><p>字符串如何调用length的？</p>
<ol>
<li>把简单数据类型包含为复杂数据类型</li>
<li>把临时变量的值给str</li>
<li>销毁这个临时变量</li>
</ol>
<p>基本包装类型：String、Number、Boolean，，就是把简单数据类型包装成复杂数据类型，这样基本数据类型就就有了属性和方法</p>
<h5 id="字符串的不可变性"><a href="#字符串的不可变性" class="headerlink" title="字符串的不可变性"></a>字符串的不可变性</h5><p>只字符串里面的值没有变，只是指向了新的地址，看起来像变了，因此不应该大量拼接字符串</p>
<h5 id="根据字符返回位置"><a href="#根据字符返回位置" class="headerlink" title="根据字符返回位置"></a>根据字符返回位置</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str.indexOf(&#39;要查找的字符&#39;,[起始的位置])&#x2F;&#x2F;可以实现从第几位开始查找，查找不到返回的结果是-1</span><br></pre></td></tr></table></figure>

<h5 id="根据位置返回字符"><a href="#根据位置返回字符" class="headerlink" title="根据位置返回字符"></a>根据位置返回字符</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str.charAt(index)&#x2F;&#x2F;返回第index个字符，从0开始</span><br><span class="line"></span><br><span class="line">str.charCodeAt(index)&#x2F;&#x2F;返回相应索引号的字符ASCII值  目的：判断用户按下了哪个键</span><br><span class="line"></span><br><span class="line">str[index]&#x2F;&#x2F;H5新增</span><br></pre></td></tr></table></figure>

<h5 id="字符串操作方法"><a href="#字符串操作方法" class="headerlink" title="字符串操作方法"></a>字符串操作方法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str.concat(&#39;a&#39;)&#x2F;&#x2F;相当于str+&#39;a&#39;</span><br><span class="line">substr(截取的起始位置，截取几个字符)</span><br><span class="line">slice</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str.replace(&#39;a&#39;,&#39;b&#39;)&#x2F;&#x2F;把str中的&#39;a&#39;替换成&#39;b&#39;,只会替换第一个</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str.split(&#39;,&#39;)&#x2F;&#x2F;字符串转化为数组，用&#39;,&#39;分割，可以改为其他分隔符</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">toUpperCase()&#x2F;&#x2F;转换大写</span><br><span class="line">toLowerCase()&#x2F;&#x2F;转换小写</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="数据类型总结"><a href="#数据类型总结" class="headerlink" title="数据类型总结"></a>数据类型总结</h2><p>简单数据类型/值类型：string、number、boolean、underfined、null</p>
<p>复杂类型/引用类型：在存储时变量中存储的仅仅是地址（引用），因此叫做引用数据类型，是通过new创建的类型</p>
<ul>
<li>一般有个变量打算以后放对象，可以先让他等于none</li>
<li>一般简单的数据类型<strong>值</strong>放在栈中，复杂的是把<strong>地址</strong>放在栈中，内容是存放在堆中</li>
<li>函数的形参也可以看做是一个变量，当我们把引用类型变量传给形参时，实质上是把变量在栈内保存的堆地址复制给了形参，形参和实参保存的是同一个堆地址，因此函数内部对输入的对象进行改变的时候，直接改变了堆中的内容，函数执行完毕后，该对象的内容已经改变</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS-2-DOM</title>
    <url>/2021/03/11/JS-2-DOM/</url>
    <content><![CDATA[<h2 id="API和Web-API"><a href="#API和Web-API" class="headerlink" title="API和Web API"></a>API和Web API</h2><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>应用程序编程接口，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，且又无需访问源码，或理解内部工作机制的细节</p>
<p>API是给程序员提供的一种工具，以便能更轻松的实现想要的功能</p>
<span id="more"></span>

<h3 id="Web-API"><a href="#Web-API" class="headerlink" title="Web API"></a>Web API</h3><p>是浏览器提供的一套操作浏览器功能和页面元素的API（BOM和DOM）</p>
<h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><p>DOM是(Document Object Model)文档对象模型，是W3C组织推荐的处理可扩展标记语言的标准编程接口</p>
<p>可以通过DOM接口改变网页的结构、内容和样式</p>
<h3 id="DOM树"><a href="#DOM树" class="headerlink" title="DOM树"></a>DOM树</h3><ul>
<li>文档：一个页面就是一个文档，DOM中使用document表示</li>
<li>元素：页面中所有标签就是元素，DOM中使用element表示</li>
<li>节点：网页中所有内容都是节点（标签、属性、文本、注释）等，DOM中使用node表示</li>
</ul>
<p>DOM把以上内容都看作对象</p>
<h2 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h2><h4 id="根据ID获取"><a href="#根据ID获取" class="headerlink" title="根据ID获取"></a>根据ID获取</h4><p>getElementById</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;time&quot;&gt;2010&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    &#x2F;&#x2F; 参数id是大小写敏感的字符串,返回的是一个元素对象</span><br><span class="line">    var timer &#x3D; document.getElementById(&#39;time&#39;);</span><br><span class="line">    console.log(timer);</span><br><span class="line">    console.log(typeof timer);&#x2F;&#x2F;返回object</span><br><span class="line">    &#x2F;&#x2F;打印返回的元素对象，更好的查看里面的属性和方法</span><br><span class="line">    console.dir(timer);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="根据标签名获取"><a href="#根据标签名获取" class="headerlink" title="根据标签名获取"></a>根据标签名获取</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;返回的是获取过来元素对象的集合 以伪数组的形式存储的 </span><br><span class="line">var lis &#x3D; document.getElementsByTagName(&#39;li&#39;);</span><br><span class="line">console.log(lis);</span><br><span class="line">&#x2F;&#x2F;如果页面中只有一个li，返回的还是伪数组，没有则是空的伪数组[]</span><br></pre></td></tr></table></figure>

<p>可以指定父元素内部所有指定标签名的子元素</p>
<p>父元素必须是单个对象（必须指明是哪一个元素对象），获取的时候不包括父元素自己</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var mm &#x3D; document.getElementsByTagName(&#39;div&#39;);</span><br><span class="line">console.log(mm[0].getElementsByTagName(&#39;li&#39;));</span><br></pre></td></tr></table></figure>

<h4 id="通过类名获取"><a href="#通过类名获取" class="headerlink" title="通过类名获取"></a>通过类名获取</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.getElementsByClassName(&#39;box&#39;);&#x2F;&#x2F;选择类名为box的对象</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;指定选择器的第一个对象</span><br><span class="line">document.querySelector(&#39;.box&#39;);</span><br><span class="line">document.querySelector(&#39;#nav&#39;);&#x2F;&#x2F;选择器必须加符号</span><br><span class="line">&#x2F;&#x2F;指定选择器的所有对象</span><br><span class="line">document.querySelectorAll(&#39;.box&#39;);</span><br></pre></td></tr></table></figure>

<h4 id="获取body3元素"><a href="#获取body3元素" class="headerlink" title="获取body3元素"></a>获取body3元素</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.body;</span><br></pre></td></tr></table></figure>

<h4 id="获取html元素"><a href="#获取html元素" class="headerlink" title="获取html元素"></a>获取html元素</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.documentElement;&#x2F;&#x2F;得到整个html标签的内容</span><br></pre></td></tr></table></figure>

<h2 id="事件基础"><a href="#事件基础" class="headerlink" title="事件基础"></a>事件基础</h2><p>执行事件的步骤：</p>
<ol>
<li>获取事件源</li>
<li>注册事件（绑定事件）</li>
<li>添加事件处理程序</li>
</ol>
<h3 id="常见的鼠标事件"><a href="#常见的鼠标事件" class="headerlink" title="常见的鼠标事件"></a>常见的鼠标事件</h3><ul>
<li>onclick  鼠标左键按下</li>
<li>onmouseover  鼠标经过</li>
<li>onmouseout  鼠标离开</li>
<li>onfouse  获得鼠标焦点触发</li>
<li>onblur  失去鼠标焦点触发</li>
<li>onmousemove  鼠标移动触发</li>
<li>onmouseup 鼠标弹起触发</li>
<li>onmousedown鼠标按下触发</li>
</ul>
<h2 id="操作元素"><a href="#操作元素" class="headerlink" title="操作元素"></a>操作元素</h2><h4 id="改变元素内容"><a href="#改变元素内容" class="headerlink" title="改变元素内容"></a>改变元素内容</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">element.innerText&#x3D;</span><br><span class="line">element.innerHTML&#x3D;</span><br></pre></td></tr></table></figure>

<ul>
<li>innerText不识别HTML标签，innerHTML识别,是W3C标准</li>
<li>这两个属性是可读写的</li>
<li>读的时候，innerText会去除标签空格和换行，innerHTML显示是完整的</li>
</ul>
<h4 id="修改常见元素属性"><a href="#修改常见元素属性" class="headerlink" title="修改常见元素属性"></a>修改常见元素属性</h4><p>img.src换图</p>
<h4 id="表单元素的属性操作"><a href="#表单元素的属性操作" class="headerlink" title="表单元素的属性操作"></a>表单元素的属性操作</h4><p>type、value、checked、selected、disabled</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    var btn &#x3D; document.querySelector(&#39;button&#39;);</span><br><span class="line">    var input &#x3D; document.querySelector(&#39;input&#39;);</span><br><span class="line">    btn.onclick &#x3D; function () &#123;</span><br><span class="line">        input.value &#x3D; &#39;被点击了&#39;;</span><br><span class="line">        &#x2F;&#x2F; 禁用某个表单不能再点击用disabled</span><br><span class="line">        btn.disabled &#x3D; true;</span><br><span class="line">        this.disabled&#x3D;true;&#x2F;&#x2F;this指向的是调用者</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\LiJing\AppData\Local\Temp\1615301396516.png" alt="1615301396516"></p>
<h4 id="修改元素样式属性"><a href="#修改元素样式属性" class="headerlink" title="修改元素样式属性"></a>修改元素样式属性</h4><ol>
<li>使用element.style获得修改元素形式</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.style.backgroundColor&#x3D;&#39;purple&#39;;</span><br></pre></td></tr></table></figure>

<ul>
<li>JS里的样式采取驼峰命名法</li>
<li>JS修改style样式操作，产生的是行内样式，css权重比较高</li>
<li>一般样式少，功能简单时使用</li>
</ul>
<ol>
<li>使用this.className=’’,然后在css里定义该类的样式属性</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.className&#x3D;&#39;change&#39;;</span><br></pre></td></tr></table></figure>

<ul>
<li>className是保留字，操作元素类名属性</li>
<li>会直接更改类名，覆盖原来的类名</li>
<li>如果想要保留原来的类名，可以使用多类名选择器</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.className&#x3D;&#39;first change&#39;;</span><br></pre></td></tr></table></figure>

<h3 id="排他思想"><a href="#排他思想" class="headerlink" title="排他思想"></a>排他思想</h3><p>给所有元素全部清除样式后，给当前元素设置样式，顺序不可以颠倒</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var btns &#x3D; document.getElementsByTagName(&#39;button&#39;);</span><br><span class="line">for (var i &#x3D; 0; i &lt; btns.length; i++) &#123;</span><br><span class="line">    btns[i].onclick &#x3D; function () &#123;</span><br><span class="line">        console.log(&#39;1&#39;);</span><br><span class="line">        for (var i &#x3D; 0; i &lt; btns.length; i++) &#123;</span><br><span class="line">            btns[i].style.backgroundColor &#x3D; &#39;&#39;;</span><br><span class="line">        &#125;</span><br><span class="line">        this.style.backgroundColor &#x3D; &#39;pink&#39;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义属性操作"><a href="#自定义属性操作" class="headerlink" title="自定义属性操作"></a>自定义属性操作</h3><h4 id="获取属性值"><a href="#获取属性值" class="headerlink" title="获取属性值"></a>获取属性值</h4><ol>
<li>element.属性  只能获取内置属性值（元素自带）</li>
<li>element.getAttribute(‘属性’)  可以获取自定义属性（程序员自己添加）</li>
<li>H5新增</li>
</ol>
<p>element.dataset.index或者element.dataset[‘index’]  ie11才开始支持</p>
<p>dataset是一个集合，存放了所有以data开头的自定义属性</p>
<h4 id="更改属性值"><a href="#更改属性值" class="headerlink" title="更改属性值"></a>更改属性值</h4><p>element.属性=’值’</p>
<p>element.setAttribute=(‘属性’，’值’);</p>
<h4 id="移除属性值"><a href="#移除属性值" class="headerlink" title="移除属性值"></a>移除属性值</h4><p>element.removeAttribute(‘属性’);</p>
<h4 id="H5自定义属性"><a href="#H5自定义属性" class="headerlink" title="H5自定义属性"></a>H5自定义属性</h4><p>自定义属性目的：为了保存并使用数据，有些数据可以保存到页面中而不用保存到数据库中</p>
<p>自定义属性容易引起歧义，不容易判断是元素的内置属性还是自定义属性</p>
<p>一般规定data-开头作为属性名如：data-index</p>
<p>如果自定义属性里面有多个-连接的单词，获取的时候采取驼峰命名法</p>
<h2 id="节点操作"><a href="#节点操作" class="headerlink" title="节点操作"></a>节点操作</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>获取元素通常有两种方法</p>
<ol>
<li>利用DOM提供的方法获取元素  逻辑性不强</li>
<li>利用节点层级关系获取元素  利用父子兄节点关系获取元素，逻辑性强但是兼容性较差</li>
</ol>
<p>网页中所有内容都是节点，在DOM中，节点使用node表示，节点至少拥有nodeType节点类型、nodeName节点名称、nodeValue节点值三个基本属性</p>
<ul>
<li>元素节点nodetype为1</li>
<li>属性节点2</li>
<li>文本节点3（包括文字、空格、换行等）</li>
</ul>
<p>实际开发中，节点操作主要操作的是元素节点</p>
<h3 id="通过节点层级获取节点"><a href="#通过节点层级获取节点" class="headerlink" title="通过节点层级获取节点"></a>通过节点层级获取节点</h3><p>利用DOM树把节点划分为不同的层级关系，最常见的是父子兄层级</p>
<p><strong>父亲节点</strong>：</p>
<ul>
<li>node.parentNode</li>
</ul>
<p>返回的是最近的父节点，如果找不到就返回空</p>
<p><strong>子节点</strong>：</p>
<ul>
<li>parentNode.childNodes</li>
</ul>
<p>得到的所有的子节点，包括文本节点（换行也会被计算进去）</p>
<p>如果想获取元素节点，需要专门处理（检测nodeType），一般不提倡使用</p>
<ul>
<li>parentNode.children(<strong>非标准</strong>)，开发中常用</li>
</ul>
<p><strong>第一个子节点</strong>：</p>
<ul>
<li>parentNode.firstChild  返回第一个子节点，会返回文本</li>
<li>parentNode.firstElementChild   返回第一个子元素节点</li>
<li>parentNode.lastElementChild   返回最后一个子元素节点</li>
</ul>
<p>有兼容性问题，IE9以上支持</p>
<p><strong>实际开发</strong>的写法 既 没有兼容性问题又返回第一个元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node.children[0]</span><br><span class="line">node.children[node.children.length-1]</span><br></pre></td></tr></table></figure>

<p><strong>兄弟节点</strong>：</p>
<ul>
<li>node.nextSibling</li>
</ul>
<p>得到的是下一个兄弟节点，包含元素节点和文本节点等等</p>
<ul>
<li>node.previousSibling</li>
</ul>
<p>返回上一个兄弟节点，找不到返回null</p>
<ul>
<li>node.nextElementSibling  下一个元素节点</li>
<li>node.previousElementSibling  上一个元素节点</li>
</ul>
<p>有兼容性问题，只能自己封装一个兼容性的函数</p>
<h3 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h3><ul>
<li>document.createElement(‘tagment’)  动态创建节点</li>
<li>node.appendChild(child)  添加一个节点到指定父节点的子节点列表<strong>末尾</strong>，类似数组中的push</li>
<li>node.insertBefore(child,指定元素)   将一个节点插入指定元素前面</li>
<li>想要页面添加新元素 ；创建；添加</li>
</ul>
<h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><p>parentNode.removeChild(子节点);</p>
<h3 id="复制节点"><a href="#复制节点" class="headerlink" title="复制节点"></a>复制节点</h3><p>node.cloneNode()</p>
<p>把node节点复制一份，如果括号参数为空或者false，默认是浅拷贝，只复制标签，不复制内容</p>
<h3 id="三种方式动态创建元素区别"><a href="#三种方式动态创建元素区别" class="headerlink" title="三种方式动态创建元素区别"></a>三种方式动态创建元素区别</h3><ul>
<li>document.write()直接将内容写入页面的内容流，但是如果文档流已经执行完毕，则它会导致页面全部重绘</li>
<li>innerHTML如果采取拼接字符串的方式，需要大量拼接字符串，效率较低，如果采用数组格式拼接，效率高，结构稍微复杂</li>
<li>creatElement创建多个元素效率稍低一点点，但是结果更清晰</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>创建</p>
<p>document.write</p>
<p>innerHTML</p>
<p>createElement</p>
<p>增</p>
<p>appendchild</p>
<p>insertBefore</p>
<p>删</p>
<p>removeChild</p>
<p>改</p>
<ol>
<li>修改元素属性：src、href、title</li>
<li>修改普通元素内容：innerHTML、innerText</li>
<li>修改表单元素: value、type、disabled</li>
<li>修改元素样式：style、className</li>
</ol>
<p>查</p>
<ol>
<li>DOM提供的API:getElementById、getElementByTagName</li>
<li>H5提供的新方法 querySelector querySelectAll</li>
<li>利用节点操作：parentNode、children、previousElementSibling、nextElementSibling</li>
</ol>
<p>属性操作</p>
<ol>
<li>setAttribute:</li>
<li>getAttribute:</li>
<li>removeAttribute:</li>
</ol>
<p>事件操作</p>
<p>鼠标事件–</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS-3-高级事件</title>
    <url>/2021/03/11/JS-3-%E9%AB%98%E7%BA%A7%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<p>获取事件和处理事件的第二种方式：事件监听</p>
<p>如何获取和处理鼠标与键盘的基本事件？</p>
<span id="more"></span>

<h2 id="事件监听方式"><a href="#事件监听方式" class="headerlink" title="事件监听方式"></a>事件监听方式</h2><p>eventTarget.addEventListener(type,listener[,useCapture])</p>
<ul>
<li>type：事件类型 如click</li>
<li>listener：事件处理函数</li>
<li>useCapture：布尔值</li>
</ul>
<p>ie9以前的版本支持</p>
<p>eventTarget.attachEvent()将制定的监听器注册到eventTarget上，当对象触发指定事件时，指定的回调函数就会执行</p>
<p>该方法接收两个参数：</p>
<ul>
<li>eventNameWithOn:事件类型字符串 如onclick</li>
<li>callback：事件处理函数，</li>
</ul>
<h2 id="删除事件"><a href="#删除事件" class="headerlink" title="删除事件"></a>删除事件</h2><ol>
<li>传统方式</li>
</ol>
<p>eventTarget.onclick=null;</p>
<ol>
<li>方法监听注册方式</li>
</ol>
<p>eventTarget.removeEventListener(type,listener[,useCapture]);</p>
<h2 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h2><p>事件流描述的是从页面中接收事件 的顺序</p>
<p>事件发生时会在元素节点之间按照特定的顺序传播，这个传播过程即DOM事件流</p>
<p>DOM事件流分为3个阶段：</p>
<ol>
<li>捕获阶段  自顶向下</li>
<li>当前目标阶段</li>
<li>冒泡阶段  从下往上</li>
</ol>
<p>JS代码只能执行捕获或者冒泡其中一个阶段</p>
<p>onclick和attachment只能得到冒泡阶段</p>
<p>addEventListener第三个参数如果是true，表示在事件捕获阶段调用事件处理程序，如果是false表示在事件冒泡阶段调用</p>
<h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><p>div.onclick=function(event) {}</p>
<ol>
<li>event就是一个事件对象，写到我们的侦听函数里的小括号里面，当形参来看</li>
<li>事件对象只有有了事件才会存在，它是系统给我们自动创建的，不需要我们传递参数</li>
<li>事件对象使我们事件的一系列相关数据的集合  跟事件相关的  比如鼠标点击里面就包含了鼠标的相关信息如鼠标坐标等</li>
<li>事件对象可以自己命名 如evt、e、</li>
<li>有兼容性问题 ie678通过window.event获取事件对象</li>
</ol>
<h3 id="事件对象常见属性和方法"><a href="#事件对象常见属性和方法" class="headerlink" title="事件对象常见属性和方法"></a>事件对象常见属性和方法</h3><p>a.target  返回触发事件的对象（点了谁返回谁） 标准  this返回的是绑定事件的对象</p>
<p>a.currentTarget和this一样，但是只适用于ie9以上（了解即可）</p>
<p>e.srcElement  返回触发事件的对象 非标准 ie6-8常用</p>
<p>e.type  返回事件的类型</p>
<ul>
<li>阻止默认事件 有时候需要阻止链接跳转</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a.returnValue;  &#x2F;&#x2F;ie678阻止默认事件的方法  也可以直接用</span><br><span class="line">a.preventDefault(); &#x2F;&#x2F;阻止默认事件 可以让链接不跳转</span><br><span class="line">return false;  &#x2F;&#x2F;阻止事件跳转（无兼容性问题）</span><br></pre></td></tr></table></figure>

<ul>
<li>冒泡会导致当多个盒子重叠并同时监听时，由于冒泡原理会一层一层执行，因此有时需要考虑阻止冒泡</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a.cancelBubble&#x3D;true;  &#x2F;&#x2F;非标准</span><br><span class="line">a.stopPropagation();  &#x2F;&#x2F;重点，标准写法，有兼容性问题</span><br></pre></td></tr></table></figure>

<h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>事件冒泡本身的特性，会带来坏处，也会带来好处，需要我们灵活掌握。</p>
<p>事件委托也称为事件代理，在jQuery里称为事件委派</p>
<p><strong>不要给每个子节点单独设置事件监听器，而是事件监听器设置在其父节点上，然后利用冒泡原理影响设置每个子节点</strong></p>
<p>例如ul里有很多个li都需要监听事件，可以给ul设定监听器，因为点击li，事件会冒泡到ul上，就会触发事件监听器，可以利用对象的target找到当前点击的li</p>
<p>可以实现找到这个li后改变它的背景颜色，大大简化了代码</p>
<p>作用：</p>
<p>只操作了一次DOM，提高了程序的性能</p>
<h2 id="常用的鼠标事件"><a href="#常用的鼠标事件" class="headerlink" title="常用的鼠标事件"></a>常用的鼠标事件</h2><h3 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h3><p>click：单击事件<br>dblclick：双击事件<br>mousedown：按下鼠标键时触发<br>mouseup：释放按下的鼠标键时触发<br>mousemove：鼠标移动事件<br>mouseover：移入事件<br>mouseout：移出事件<br>mouseenter：移入事件<br>mouseleave：移出事件<br>contextmenu：右键事件, 可以使用preventDefault禁用右键菜单</p>
<p>selectstart: 选中事件，可以使用selectstart禁用选中文字（不准复制~）</p>
<h3 id="鼠标事件对象"><a href="#鼠标事件对象" class="headerlink" title="鼠标事件对象"></a>鼠标事件对象</h3><p>现阶段主要使用鼠标事件对象和键盘事件对象</p>
<p>clientX,clientY永远是相对于可视窗口的坐标，不会随着滚轮拖动而改变</p>
<p>e.pageX、e.pageY是相对于文档页面的X、Y坐标，IE9+支持</p>
<p>e.screenX、e.screenY相对于电脑屏幕的X、Y坐标</p>
<h2 id="常用键盘事件"><a href="#常用键盘事件" class="headerlink" title="常用键盘事件"></a>常用键盘事件</h2><h3 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h3><p>onkeyup  某个按键松开</p>
<p>onkeydown 按下时</p>
<p>onkeypress  按下时触发，但是它不识别功能键，比如ctrl、shift、箭头</p>
<p>三个都写时有执行顺序区别，先执行down再执行press然后是up</p>
<h3 id="键盘事件对象"><a href="#键盘事件对象" class="headerlink" title="键盘事件对象"></a>键盘事件对象</h3><p>key：‘1’  直接告诉是哪个键，但是兼容性问题较大</p>
<p>keyCode：可以得到用户按键的ASCii码值</p>
<p>keyup和keydowm事件不区分字母大小写，大写和小写的ASCii码都是小写的码，而keypress区分字母大小写</p>
<p>案例：可以实现按键搜索框自动获取焦点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用keyCode判断用户是否按下了s键，利用search.focus()实现搜索框获取焦点</span><br><span class="line">最好用keydown判断，防止&#39;s&#39;进入了输入框</span><br></pre></td></tr></table></figure>

<p>案例：京东快递单号输入时上面自动放大</p>
<p><img src="C:\Users\LiJing\AppData\Local\Temp\1615474218343.png" alt="1615474218343"></p>
<ol>
<li><p>快递单号输入内容时，上面的大盒子显示</p>
</li>
<li><p>表单检测用户输入：给表单添加键盘事件</p>
</li>
<li><p>同时把快递单号表单里的值获取过来赋值给盒子</p>
</li>
<li><p>如果快递单号里面内容为空，则隐藏盒子 con.style.display=’none’</p>
</li>
<li><p>当文本框失去焦点，隐藏盒子  </p>
<p>blur  diplay=none </p>
<p> focus  {if this.value!=’’ display=block}//获得焦点时还需要检测输入是否为空</p>
</li>
<li><p><strong>注意：</strong>此处应该使用keyup，弹起时文字已经在文本框出现了       keydown和keypress触发的时候，文本框的字还没有出现，并不能实现同时放大的效果</p>
</li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS-5-PC端网页特效</title>
    <url>/2021/03/12/JS-5-PC%E7%AB%AF%E7%BD%91%E9%A1%B5%E7%89%B9%E6%95%88/</url>
    <content><![CDATA[<p>常见offset系列属性作用</p>
<p>常见client系列属性作用</p>
<p>常见scroll系列属性作用</p>
<p>封装简单动画函数</p>
<p>写出网页轮播图案例</p>
<span id="more"></span>

<h2 id="offset"><a href="#offset" class="headerlink" title="offset"></a>offset</h2><p>偏移量，使用offset相关属性可以动态的得到该元素的位置、大小等</p>
<ul>
<li>获得元素距离带有定位父元素的位置</li>
<li>获得元素自身的大小</li>
<li>注意：返回的数值不带单位</li>
</ul>
<p>offsetParent: 返回作为该元素带有定位的父级元素，如果父级都没有定位则返回body</p>
<p>offsetWidth：获取元素的宽，包括内边距、边框、内容</p>
<p>offsetHeight：获取元素的高，包括内边距、边框、内容</p>
<p>offsetLeft:获取元素距离左边位置的值，以带有定位的父亲为准，如果没有父亲或者父亲没有定位则相对body</p>
<p>offsetTop;获取元素距离上面位置的值，以带有定位的父亲为准，如果没有父亲或者父亲没有定位则相对body</p>
<h3 id="offset与style区别"><a href="#offset与style区别" class="headerlink" title="offset与style区别"></a>offset与style区别</h3><ul>
<li>offset可以得到任意样式表的样式值  style只能得到内嵌样式的样式值</li>
<li>offset得到的是数字型，不带单位  style是字符串带单位</li>
<li>offset包含整个盒子，style得到的只是width，不包括padding和border</li>
<li>offset只能读不能写，而width可以赋值</li>
<li>因此，读属性值一般用offset，写属性一般用width</li>
</ul>
<p>案例：获取鼠标在盒子里的坐标</p>
<ol>
<li>获取鼠标在页面内的坐标</li>
<li>获取盒子在页面内的坐标</li>
<li>相减</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var box&#x3D;document.querySelector(&#39;.box&#39;);</span><br><span class="line">box.addEventListener(&#39;mousemove&#39;,function()&#123;&#x2F;&#x2F;鼠标移动事件</span><br><span class="line">    var x&#x3D;e.pageX-this.offsetLeft;</span><br><span class="line">    var y&#x3D;e.pageY-this.offsetTop;</span><br><span class="line">    this.innerHTML&#x3D;&#39;X坐标是&#39;+x+&#39;y坐标是&#39;+y;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>##元素可视区client系列</p>
<p>client是客户端，可动态得到元素边框大小，元素大小等，与offset最大的区别就是不包含边框</p>
<p>clientTop  上边框</p>
<p>clientLeft  左边框</p>
<p>clientWidth</p>
<p>clientHeight  包括padding、内容，不包括边框，返回数值不带单位</p>
<h3 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a>立即执行函数</h3><p>不需要调用立马能够自己执行的函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(function()&#123;&#125;)()    或者  (function()&#123;&#125;())</span><br></pre></td></tr></table></figure>

<ul>
<li>第二个小括号可以看做是调用函数，可以传递参数，外面括号是实参，里面小括号是形参</li>
<li>两种方法使用方法一致</li>
<li>最大的作用就是独立创建了一个作用域，所有变量都是局部变量，不会有命名冲突</li>
</ul>
<p>###淘宝源码分析</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">flexible</span>(<span class="params"><span class="built_in">window</span>, <span class="built_in">document</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> docEl = <span class="built_in">document</span>.documentElement</span><br><span class="line">    <span class="keyword">var</span> dpr = <span class="built_in">window</span>.devicePixelRatio || <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// adjust body font size</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setBodyFontSize</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">document</span>.body) &#123;</span><br><span class="line">            <span class="built_in">document</span>.body.style.fontSize = (<span class="number">12</span> * dpr) + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">document</span>.addEventListener(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, setBodyFontSize)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    setBodyFontSize();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set 1rem = viewWidth / 10</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setRemUnit</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> rem = docEl.clientWidth / <span class="number">10</span></span><br><span class="line">        docEl.style.fontSize = rem + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setRemUnit()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reset rem unit on page resize</span></span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;resize&#x27;</span>, setRemUnit)</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;pageshow&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (e.persisted) &#123;</span><br><span class="line">            setRemUnit()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// detect 0.5px supports</span></span><br><span class="line">    <span class="keyword">if</span> (dpr &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> fakeBody = <span class="built_in">document</span>.createElement(<span class="string">&#x27;body&#x27;</span>)</span><br><span class="line">        <span class="keyword">var</span> testElement = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line">        testElement.style.border = <span class="string">&#x27;.5px solid transparent&#x27;</span></span><br><span class="line">        fakeBody.appendChild(testElement)</span><br><span class="line">        docEl.appendChild(fakeBody)</span><br><span class="line">        <span class="keyword">if</span> (testElement.offsetHeight === <span class="number">1</span>) &#123;</span><br><span class="line">            docEl.classList.add(<span class="string">&#x27;hairlines&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        docEl.removeChild(fakeBody)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;(<span class="built_in">window</span>, <span class="built_in">document</span>))</span><br></pre></td></tr></table></figure>



<ul>
<li>前进后退、a标签、刷新都会触发load，但是火狐浏览器使用load事件时存在往返缓存，后退按钮不能刷新页面，可以使用pageshow事件触发，这个事件在页面显示时触发，无论页面是否来自缓存，可以根据事件对象的persisted判断是否缓存中页面触发的pageshow事件，这个事件要给window添加</li>
</ul>
<h2 id="元素滚动scroll系列"><a href="#元素滚动scroll系列" class="headerlink" title="元素滚动scroll系列"></a>元素滚动scroll系列</h2><p>scrollTop:  返回被卷去的上侧距离，返回数值不带单位（隐藏的高度）</p>
<p>scrollLeft:  左侧距离，同上</p>
<p>scrollWidth: 返回自身实际宽度，不含边框，返回数值不带单位，包含内容超出盒子的部分</p>
<p>scrollHeight：高度 同上</p>
<p><strong>scroll事件：</strong></p>
<p>‘scroll’  滚动触发的事件</p>
<p><strong>window.pageXOffset:页面被卷曲的头部</strong></p>
<p>兼容性问题：</p>
<ol>
<li>声明了DTD，使用document.documentElement.scrollTop</li>
<li>未声明DTD，使用document.body.scrollTop</li>
<li>新方法window.pageYOffset和window.pageXOffset,IE9开始支持</li>
</ol>
<p>兼容性方案（了解）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getScroll() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        left: window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0,</span><br><span class="line">        top: window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三大系列总结"><a href="#三大系列总结" class="headerlink" title="三大系列总结"></a>三大系列总结</h2><ul>
<li><p>offset包含边框，scroll包括文字超出部分</p>
</li>
<li><p>offset一般用于获取元素位置，client常用与获取元素大小，获取滚动距离一般用scroll</p>
</li>
</ul>
<h2 id="mouseenter和mouseover"><a href="#mouseenter和mouseover" class="headerlink" title="mouseenter和mouseover"></a>mouseenter和mouseover</h2><p>mouseover：经过自身盒子会触发，经过子盒子还会触发一次</p>
<p>mouseenter只有经过自身盒子才会触发，因为mouseenter不会冒泡</p>
<h2 id="动画函数封装"><a href="#动画函数封装" class="headerlink" title="动画函数封装"></a>动画函数封装</h2><h3 id="动画实现原理"><a href="#动画实现原理" class="headerlink" title="动画实现原理"></a>动画实现原理</h3><p>通过定时器setInterval()不断移动盒子位置</p>
<ol>
<li>获取盒子当前位置</li>
<li>在盒子当前位置上加移动距离</li>
<li>利用定时器不断重复操作</li>
<li>加一个结束定时器的条件</li>
<li>此元素一定要加定位，因为要使用element.left实现移动</li>
</ol>
<h3 id="动画函数简单封装"><a href="#动画函数简单封装" class="headerlink" title="动画函数简单封装"></a>动画函数简单封装</h3><p>需要传递两个参数，动画对象和移动的距离</p>
<p>可以实现某个对象右移移动到某个位置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function animate(obj,target)&#123;</span><br><span class="line">	clearInterval(obj.timer)&#x2F;&#x2F;</span><br><span class="line">    obj.timer&#x3D;setInterval(function()&#123;</span><br><span class="line">        if(obj.offsetLeft&gt;&#x3D;target)&#123;</span><br><span class="line">            clearInterval(obj.timer);</span><br><span class="line">        &#125;</span><br><span class="line">        obj.style.left&#x3D;obj.offsetLeft+1+&#39;px&#39;;</span><br><span class="line">    &#125;,30);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>var timer=每次开辟空间浪费资源，且使用obj.timer避免不同调用使用相同的变量timer，因此通过添加属性实现给不同元素添加不同定时器</li>
<li>注意要先清除原来的定时器，只保留当前定时器，避免多次触发动画时创建很多定时器造成不正常现象</li>
</ul>
<h3 id="缓动动画"><a href="#缓动动画" class="headerlink" title="缓动动画"></a>缓动动画</h3><p>让元素的运动速度有所变化，最常见的是让速度慢慢减下来</p>
<p>思路：</p>
<ol>
<li>让盒子每次移动的距离慢慢变小</li>
<li>（目标值-现在的位置）/10   作为每次移动的距离步长即可</li>
<li>停止的条件：让当前盒子位置等于目标位置时停止定时器</li>
</ol>
<p>把每次+1的步长改为慢慢变小的值 即</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function animate(obj,target)&#123;</span><br><span class="line">	clearInterval(obj.timer)&#x2F;&#x2F;</span><br><span class="line">    obj.timer&#x3D;setInterval(function()&#123;</span><br><span class="line">    	var step&#x3D;target-obj.offsetLeft)&#x2F;10;&#x2F;&#x2F;计算步长，要注意不要出现小号,还要考虑负值</span><br><span class="line">    	step&gt;0?Math.ceil(step):Math.floor(step)</span><br><span class="line">        if(obj.offsetLeft&#x3D;&#x3D;target)&#123;&#x2F;&#x2F;修改为等于号</span><br><span class="line">            clearInterval(obj.timer);</span><br><span class="line">        &#125;</span><br><span class="line">        obj.style.left&#x3D;obj.offsetLeft+step+&#39;px&#39;;</span><br><span class="line">    &#125;,30);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了实现在多个目标间移动，需要考虑步长正负</p>
<p>###动画函数添加回调函数（重要）</p>
<p>回调函数原理：函数可以作为一个参数，将这个参数传到另一个函数里，当那个函数执行完之后再执行传进去的这个函数，这个过程称为回调</p>
<p>操作方法：输入添加一个函数作为参数，函数执行写在计时器停止的内容里，即可实现执行完动画后执行回调函数</p>
<p>if(callback){</p>
<p>callback()}</p>
<p>如下代码即可实现运动完毕后盒子变颜色</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animate</span>(<span class="params">obj, target, callback</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// console.log(callback);  callback = function() &#123;&#125;  调用的时候 callback()</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 先清除以前的定时器，只保留当前的一个定时器执行</span></span><br><span class="line">            <span class="built_in">clearInterval</span>(obj.timer);</span><br><span class="line">            obj.timer = <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="comment">// 步长值写到定时器的里面</span></span><br><span class="line">                <span class="comment">// 把我们步长值改为整数 不要出现小数的问题</span></span><br><span class="line">                <span class="comment">// var step = Math.ceil((target - obj.offsetLeft) / 10);</span></span><br><span class="line">                <span class="keyword">var</span> step = (target - obj.offsetLeft) / <span class="number">10</span>;</span><br><span class="line">                step = step &gt; <span class="number">0</span> ? <span class="built_in">Math</span>.ceil(step) : <span class="built_in">Math</span>.floor(step);</span><br><span class="line">                <span class="keyword">if</span> (obj.offsetLeft == target) &#123;</span><br><span class="line">                    <span class="comment">// 停止动画 本质是停止定时器</span></span><br><span class="line">                    <span class="built_in">clearInterval</span>(obj.timer);</span><br><span class="line">                    <span class="comment">// 回调函数写到定时器结束里面</span></span><br><span class="line">                    <span class="keyword">if</span> (callback) &#123;</span><br><span class="line">                        <span class="comment">// 调用函数</span></span><br><span class="line">                        callback();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 把每次加1 这个步长值改为一个慢慢变小的值  步长公式：(目标值 - 现在的位置) / 10</span></span><br><span class="line">                obj.style.left = obj.offsetLeft + step + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line"></span><br><span class="line">            &#125;, <span class="number">15</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> span = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;span&#x27;</span>);</span><br><span class="line">        <span class="keyword">var</span> btn500 = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.btn500&#x27;</span>);</span><br><span class="line">        <span class="keyword">var</span> btn800 = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.btn800&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        btn500.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 调用函数</span></span><br><span class="line">            animate(span, <span class="number">500</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">        btn800.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="comment">// 调用函数</span></span><br><span class="line">                animate(span, <span class="number">800</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                    <span class="comment">// alert(&#x27;你好吗&#x27;);</span></span><br><span class="line">                    span.style.backgroundColor = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;)</span><br></pre></td></tr></table></figure>

<h2 id="返回顶部"><a href="#返回顶部" class="headerlink" title="返回顶部"></a>返回顶部</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.scroll(0, 0);&#x2F;&#x2F;x,y不跟单位直接写数字就好</span><br></pre></td></tr></table></figure>

<ol>
<li><p>快速滚动到顶端</p>
</li>
<li><p>编写垂直运动的动画函数，点击后目标设为0（y坐标）</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">goBack.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            animate(<span class="built_in">window</span>, <span class="number">0</span>);<span class="comment">//窗口动画，对象是window</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">animate</span>(<span class="params">obj, target, callback</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// console.log(callback);  callback = function() &#123;&#125;  调用的时候 callback()</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 先清除以前的定时器，只保留当前的一个定时器执行</span></span><br><span class="line">            <span class="built_in">clearInterval</span>(obj.timer);</span><br><span class="line">            obj.timer = <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="comment">// 步长值写到定时器的里面</span></span><br><span class="line">                <span class="comment">// 把我们步长值改为整数 不要出现小数的问题</span></span><br><span class="line">                <span class="comment">// var step = Math.ceil((target - obj.offsetLeft) / 10);</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">var</span> step = (target - <span class="built_in">window</span>.pageYOffset) / <span class="number">10</span>;</span><br><span class="line">                step = step &gt; <span class="number">0</span> ? <span class="built_in">Math</span>.ceil(step) : <span class="built_in">Math</span>.floor(step);</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">window</span>.pageYOffset == target) &#123;</span><br><span class="line">                    <span class="comment">// 停止动画 本质是停止定时器</span></span><br><span class="line">                    <span class="built_in">clearInterval</span>(obj.timer);</span><br><span class="line">                    <span class="comment">// 回调函数写到定时器结束里面</span></span><br><span class="line">                    callback &amp;&amp; callback();<span class="comment">//如果有参数传入才会调用callback</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 把每次加1 这个步长值改为一个慢慢变小的值  步长公式：(目标值 - 现在的位置) / 10</span></span><br><span class="line">                <span class="comment">// obj.style.left = obj.offsetLeft + step + &#x27;px&#x27;;</span></span><br><span class="line">                <span class="built_in">window</span>.scroll(<span class="number">0</span>, <span class="built_in">window</span>.pageYOffset + step);</span><br><span class="line"></span><br><span class="line">            &#125;, <span class="number">15</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS-4-BOM浏览器对象模型</title>
    <url>/2021/03/11/JS-4-BOM%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>什么是BOM</p>
<p>浏览器的顶级对象</p>
<p>页面加载事件以及注意事项</p>
<p>定时器函数</p>
<p>JS执行机制</p>
<p>页面跳转、刷新</p>
<p>history、navigator对象</p>
<span id="more"></span>

<h2 id="什么是BOM"><a href="#什么是BOM" class="headerlink" title="什么是BOM"></a>什么是BOM</h2><p>浏览器对象模型(Browser Object Model)，主要作用是提供独立于内容而与浏览器窗口进行交互的对象，核心是window，BOM缺乏标准</p>
<p>###对比</p>
<p>DOM                                    BOM</p>
<p>文档对象模型                                浏览器对象模型</p>
<p>顶级对象的document                        顶级对象是window</p>
<p>主要学习操作元素                            主要和浏览器窗口交互，刷新跳转等</p>
<p>W3C                                    BOM是浏览器厂商各自定义的，兼容性差</p>
<h3 id="BOM的构成"><a href="#BOM的构成" class="headerlink" title="BOM的构成"></a>BOM的构成</h3><p>window对象是浏览器的顶级对象，具有双重角色</p>
<ul>
<li>是JS访问浏览器窗口的一个接口</li>
<li>是一个全局对象，定义在全局作用域中的变量、函数都会变成window对象的方法和属性</li>
<li>在调用的时候可以省略window，前面学习的对话框alert()、prompt()等</li>
<li>window下不要直接定义变量为name，因为有个特殊属性window.name</li>
</ul>
<h2 id="window对象常见事件"><a href="#window对象常见事件" class="headerlink" title="window对象常见事件"></a>window对象常见事件</h2><p>###窗口加载事件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.onload&#x3D;function()&#123;&#125;</span><br><span class="line">window.addEventListener&#x3D;(&quot;load&quot;,function()&#123;&#125;)</span><br></pre></td></tr></table></figure>

<p>window.onload是窗口加载事件，当文档enrich完全加载完成会触发该事件（包括图像、脚本文件、CSS文件等），就调用的处理函数</p>
<ol>
<li>有了window.onload就可以把JS代码写到页面元素的上方，但是写了多个后只处理最后一个</li>
<li>如果用addEventListener则没有限制</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.addEventListener(&#39;DOMContentLoaded&#39;,function()&#123;&#125;)</span><br></pre></td></tr></table></figure>

<p>仅当DOM加载完成时才会触发，不包含样式表、图片、flash等，ie9以上才支持</p>
<p>在页面图片很多加载很慢的时候，可以提前获取交互，保证用户体验</p>
<h3 id="调整窗口大小事件"><a href="#调整窗口大小事件" class="headerlink" title="调整窗口大小事件"></a>调整窗口大小事件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.onresize&#x3D;function()&#123;&#125;</span><br><span class="line">window.addEventListener&#x3D;(&quot;resize&quot;,function()&#123;&#125;)</span><br></pre></td></tr></table></figure>

<p>调整窗口大小事件</p>
<ol>
<li>只要窗口带下发生像素变化时，就会触发</li>
<li>用于响应式布局；window.innerWidth可以获得屏幕宽度</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var div &#x3D; document.querySelector(&#39;div&#39;);</span><br><span class="line">window.addEventListener(&#39;resize&#39;, function () &#123;</span><br><span class="line">    if (window.innerWidth &lt;&#x3D; 800) &#123;</span><br><span class="line">        div.style.display &#x3D; &#39;none&#39;;</span><br><span class="line">    &#125;	else &#123;</span><br><span class="line">        div.style.display &#x3D; &#39;block&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><h3 id="两种定时器"><a href="#两种定时器" class="headerlink" title="两种定时器"></a>两种定时器</h3><p><strong>setTimeOut()</strong></p>
<p>window.setTimeout(调用函数，[延迟的毫秒数]);</p>
<ul>
<li>延迟时间可以省略</li>
<li>调用函数可以直接写函数，还可以写函数名</li>
<li>还有一个写法’函数名()’,不提倡</li>
<li>页面中可能有很多定时器，我们经常给定时器加标识符</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function callback() &#123;</span><br><span class="line">          console.log(&#39;111&#39;);</span><br><span class="line">      &#125;</span><br><span class="line">      var time1 &#x3D; setTimeout(callback, 3000);</span><br><span class="line">      var time2 &#x3D; setTimeout(callback, 1000);</span><br></pre></td></tr></table></figure>

<p>回调函数callback：需要等待时间，时间到了才去调用这个函数以前的.onclick=function()里面的函数也是回调函数</p>
<p>案例：5s后自动隐藏广告</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var ad &#x3D; document.querySelector(&#39;.ad&#39;);</span><br><span class="line">setTimeout(function () &#123;</span><br><span class="line">    ad.style.display &#x3D; &#39;none&#39;;</span><br><span class="line">&#125;, 5000)</span><br></pre></td></tr></table></figure>

<p><strong>计时器停止：</strong></p>
<p>window.clearTimeout(timeoutID)</p>
<p>setInterval()定时器</p>
<p>window.setInterval(回调函数，[间隔的毫秒数])</p>
<p>执行过程不同，本函数是每间隔一定时间就执行一次，会不断执行，setTimeout只执行一次</p>
<p>案例：秒杀倒计时</p>
<ul>
<li>这个倒计时是不断变化的  ，因此需要定时器来自动变化（setInterval）</li>
<li>三个盒子分别存放时分秒</li>
<li>三个黑色盒子利用innerHTML放入计算的小时分钟秒数</li>
<li>最好先调用一次函数，防止刚刷新页面时出现空白</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var hour &#x3D; document.querySelector(&#39;.hour&#39;);</span><br><span class="line">var minute &#x3D; document.querySelector(&#39;.minute&#39;);</span><br><span class="line">var second &#x3D; document.querySelector(&#39;.second&#39;);</span><br><span class="line">var inputTime &#x3D; +new Date(&#39;2021-3-13 18:00:00&#39;);&#x2F;&#x2F;用户想输入的时间</span><br><span class="line">countDown();&#x2F;&#x2F;最好先调用一次函数，防止刚刷新页面时出现空白</span><br><span class="line">&#x2F;&#x2F;开启定时器 每秒都调用该函数</span><br><span class="line">setInterval(countDown, 1000);</span><br><span class="line">function countDown(time) &#123;</span><br><span class="line">    var nowTime &#x3D; +new Date();&#x2F;&#x2F;当前时间总的毫秒数</span><br><span class="line">    var times &#x3D; (inputTime - nowTime) &#x2F; 1000;&#x2F;&#x2F;秒数</span><br><span class="line">    var h &#x3D; parseInt(times &#x2F; 60 &#x2F; 60 % 24);</span><br><span class="line">    h &#x3D; h &lt; 10 ? &#39;0&#39; + h : h;</span><br><span class="line">    hour.innerHTML &#x3D; h;</span><br><span class="line">    var m &#x3D; parseInt(times &#x2F; 60 % 60);</span><br><span class="line">    m &#x3D; m &lt; 10 ? &#39;0&#39; + m : m;</span><br><span class="line">    minute.innerHTML &#x3D; m;</span><br><span class="line">    var s &#x3D; parseInt(times % 60);</span><br><span class="line">    s &#x3D; s &lt; 10 ? &#39;0&#39; + s : s;</span><br><span class="line">    second.innerHTML &#x3D; s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>window.clearInterval();停止定时器</p>
<ul>
<li>有时外界需要内部的变量，需要在函数外定义对象，可以定义为null</li>
</ul>
<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>指向<strong>调用</strong>它的对象</p>
<ol>
<li><p>全局作用域下或者普通函数下this指向window；（定时器里面的this指向window）</p>
</li>
<li><p>方法调用中this指向的是调用它的对象</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">btn.addEventListener(&#39;click&#39;,function()&#123;&#125;)</span><br><span class="line">btn.onclick&#x3D;function()&#123;&#125;;</span><br><span class="line">&#x2F;&#x2F;都指向btn</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>构造函数中this指向构造函数的实例</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var fun&#x3D;new Fun();&#x2F;&#x2F;this指向fun</span><br></pre></td></tr></table></figure>

<h2 id="JS执行队列"><a href="#JS执行队列" class="headerlink" title="JS执行队列"></a>JS执行队列</h2><h3 id="JS单线程"><a href="#JS单线程" class="headerlink" title="JS单线程"></a>JS单线程</h3><p>JS是单线程语言，同一时间只能做一件事。</p>
<p>单线程意味着所有任务需要排队，如果JS执行事件过长，会造成其他代码等待时间过长</p>
<p>为了解决这个问题，HTM5提出了Web Worker标准，允许JS创建多个线程，因此出现了同步和异步</p>
<p>###同步和异步</p>
<p><strong>同步</strong>：</p>
<p>前一个任务结束后再执行后一个任务，程序的执行顺序和任务的排列顺序是一致的、同步的</p>
<p><strong>异步：</strong></p>
<p>做一件事情的时候同时还可以做其他事情</p>
<p>本质区别：这条流水线上各个流程执行顺序不同</p>
<p><strong>同步任务</strong>：同步任务都在主线程上进行，行程一个执行栈</p>
<p><strong>异步任务</strong>：JS的异步是通过回调函数实现的，</p>
<ol>
<li>普通事件：如click、resize等</li>
<li>资源加载，如load、error等</li>
<li>定时器，如setinterval、setTimeout等</li>
</ol>
<p>异步任务相关回调函数添加到任务队列（消息队列）中。</p>
<h3 id="JS执行机制"><a href="#JS执行机制" class="headerlink" title="JS执行机制"></a>JS执行机制</h3><ol>
<li>先执行执行栈中同步任务</li>
<li>异步任务放入任务队列中</li>
<li>一旦执行栈中所有同步任务执行完毕，系统就会按次序读取任务队列中的异步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行</li>
</ol>
<p>由于主线程不断的获取任务、执行任务、再获取任务、再执行任务，这种机制被称为<strong>事件循环</strong></p>
<h2 id="Location对象"><a href="#Location对象" class="headerlink" title="Location对象"></a>Location对象</h2><p>window对象给我们提供了一个location属性用于获取或设置窗体的URL，并且可以用于解析URL。该属性返回的是一个对象，因此也称为Location对象</p>
<p>URL</p>
<p>统一资源定位符(Uniform Resource Locator)，是互联网标准资源的地址，互联网每个文件都有位移的URL，包含的信息之处文件的位置以及浏览器该如何处理它</p>
<p>URL一般格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protocol:&#x2F;&#x2F;host[:port]&#x2F;path&#x2F;[?query]#fragment</span><br><span class="line">http:&#x2F;&#x2F;www.itcast.cn&#x2F;index.html?name&#x3D;andy&amp;age&#x3D;18#link</span><br></pre></td></tr></table></figure>

<ul>
<li>protocol  通信协议 常用的http、ftp、maito等</li>
<li>host  主机（域名）</li>
<li>port  端口号 可选，省略时使用方案的默认端口，如http的默认端口为80</li>
<li>path路径 由零或多个’/‘符号隔开的字符串，一般用来表示主机上的一个目录或文件地址</li>
<li>query 参数 以键值对的形式，用&amp;号分割开</li>
<li>fragment 片段 #后面内容，常见于连接锚点</li>
</ul>
<h3 id="Location对象的属性"><a href="#Location对象的属性" class="headerlink" title="Location对象的属性"></a>Location对象的属性</h3><p><strong>location.href</strong>  获取或设置整个URL  可以实现点击某位置跳转其他页面</p>
<p>location.host  返回主机（域名）</p>
<p>location.port 返回端口号</p>
<p>location.pathname返回路径</p>
<p><strong>location.search</strong>  返回参数(query)</p>
<p>location.hash 返回片段 #后面内容常见于链接 锚点</p>
<p>案例：5s后自动跳转页面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var timer&#x3D;5;</span><br><span class="line">setInterval(function()&#123;</span><br><span class="line">if(timer&#x3D;&#x3D;0)&#123;</span><br><span class="line">    location.href&#x3D;&#39;http:&#x2F;&#x2F;www.itcast.cn&#39;;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    div.innerHTML&#x3D;&#39;将在&#39;+timeer+&#39;s 后跳转首页&#39;; </span><br><span class="line">    timer--;&#125;</span><br><span class="line">&#125;,1000)</span><br></pre></td></tr></table></figure>

<p>案例：提交表单后跳转到另一个页面并显示</p>
<ol>
<li>第一个登陆页面，里有提交表单，利用action=’index.html’提交到第二个页面，input表单必须有name属性，作为提交的属性</li>
<li>第二个页面，可以使用第一个页面的参数，利用了参数的传递，从location.search可以得到</li>
<li>location.search得到的是形如 ?name=Andy 的样式，需要去掉问号（substr(开始的位置，位数)</li>
<li>还需要利用split(‘=’)分开参数和值</li>
</ol>
<h3 id="Location常用方法"><a href="#Location常用方法" class="headerlink" title="Location常用方法"></a>Location常用方法</h3><p>location.assign 跳转页面，记录浏览器历史，可以使用后退功能</p>
<p>location.replace  跳转页面，但是不记录历史，无法后退</p>
<p>location.reload 重新加载，相当于刷新页面，如果参数为true表示强制刷新（不读取缓存中图片，机载较慢），不填表示类似于F5直接刷新</p>
<h2 id="navigator对象"><a href="#navigator对象" class="headerlink" title="navigator对象"></a>navigator对象</h2><p>navigator.userAgent显示浏览器信息、系统信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if((navigator.userAgent.match(&#x2F;(iPhone|iPod|Android|ios|iPad|hpwOS|SysbianOS|Windows Phone|UCWEB|BlackBerry|Nokia|RIM|IEMobile|Mobile)&#x2F;i)&#123;</span><br><span class="line">location.href&#x3D;&quot;http:&#x2F;&#x2F;www.cnblogs.com&#x2F;dying&quot;&#125;</span><br><span class="line">else&#123;</span><br><span class="line">    location.href&#x3D;&quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>##history对象</p>
<p>history.forward()  前进功能</p>
<p>history.back()后退</p>
<p>go()  参数是2表示前进2个页面，-2表示后退2个页面</p>
<p>一些OA办公系统有可能会用到</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS案例-仿京东放大镜效果</title>
    <url>/2021/03/12/JS%E6%A1%88%E4%BE%8B-%E4%BB%BF%E4%BA%AC%E4%B8%9C%E6%94%BE%E5%A4%A7%E9%95%9C%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<p>本案例可以实现：当鼠标放在图片上时，图片上出现跟随鼠标移动的遮挡层，同时右边会出现一个放大的图片，展现出放大镜效果</p>
<span id="more"></span>

<ol>
<li>鼠标经过小盒子，黄色的遮挡层和大图片盒子显示，离开隐藏</li>
<li>遮挡层跟随鼠标</li>
<li>移动黄色遮挡层，大盒子跟着移动</li>
</ol>
<p>*如果js分开一个文件写，必须加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.addEventListener(&#39;load&#39;,function()&#123;&#125;)</span><br></pre></td></tr></table></figure>

<p>先加载完再执行js</p>
<ul>
<li>比例关系：大图片移动距离=遮挡层移动距离*大图片移动距离/遮挡层最大移动距离</li>
<li>注意大盒子中图片移动应该与小盒子中遮罩反向移动</li>
</ul>
<p>完整代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot;&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .box &#123;</span><br><span class="line">            position: relative;</span><br><span class="line">            width: 400px;</span><br><span class="line">            height: 400px;</span><br><span class="line">            background-color: yellowgreen;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .box&gt;img &#123;</span><br><span class="line">            max-width: 100%;</span><br><span class="line">            max-height: 100%;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .mask &#123;</span><br><span class="line">            display: none;</span><br><span class="line">            position: absolute;</span><br><span class="line">            width: 100px;</span><br><span class="line">            height: 100px;</span><br><span class="line">            background-color: wheat;</span><br><span class="line">            opacity: .8;</span><br><span class="line">            top: 0;</span><br><span class="line">            left: 0;</span><br><span class="line">            border: 1px solid #ccc;</span><br><span class="line">            cursor: move;</span><br><span class="line">            &#x2F;* 鼠标样式变化 *&#x2F;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .big &#123;</span><br><span class="line">            &#x2F;* display: none; *&#x2F;</span><br><span class="line">            overflow: hidden;</span><br><span class="line">            position: absolute;</span><br><span class="line">            width: 500px;</span><br><span class="line">            height: 500px;</span><br><span class="line">            top: 0px;</span><br><span class="line">            left: 410px;</span><br><span class="line">            z-index: 10;</span><br><span class="line">            border: 1px solid #ccc;</span><br><span class="line">            &#x2F;* 保证优先级 *&#x2F;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .big img &#123;</span><br><span class="line">            position: absolute;</span><br><span class="line">            top: 0;</span><br><span class="line">            left: 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;box&quot;&gt;</span><br><span class="line">        &lt;img src&#x3D;&quot;images&#x2F;s3.png&quot; alt&#x3D;&quot;&quot;&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;mask&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;big&quot;&gt;&lt;img src&#x3D;&quot;images&#x2F;big.jpg&quot; alt&#x3D;&quot;&quot; class&#x3D;&quot;bigImg&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">	&#x2F;&#x2F;js部分见下个代码框</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">box = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.box&#x27;</span>);</span><br><span class="line">mask = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.mask&#x27;</span>);</span><br><span class="line">big = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.big&#x27;</span>);</span><br><span class="line">box.addEventListener(<span class="string">&#x27;mouseover&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="comment">//鼠标放在盒子里时让mask和big出现</span></span><br><span class="line">    mask.style.display = <span class="string">&#x27;block&#x27;</span>;</span><br><span class="line">    big.style.display = <span class="string">&#x27;block&#x27;</span>;</span><br><span class="line">&#125;);</span><br><span class="line">box.addEventListener(<span class="string">&#x27;mousemove&#x27;</span>, move);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//获取鼠标在盒子内坐标</span></span><br><span class="line">    <span class="keyword">var</span> x = e.pageX - <span class="built_in">this</span>.offsetLeft;</span><br><span class="line">    <span class="keyword">var</span> y = e.pageY - <span class="built_in">this</span>.offsetTop;</span><br><span class="line">    <span class="keyword">var</span> maskX = x - mask.offsetWidth / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">var</span> maskY = y - mask.offsetHeight / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">var</span> maskMax = box.offsetWidth - mask.offsetWidth;<span class="comment">//遮挡层的最大移动距离</span></span><br><span class="line">    <span class="keyword">if</span> (maskX &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        maskX = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (maskX &gt; maskMax) &#123;</span><br><span class="line">        maskX = maskMax;<span class="comment">//x的上限距离左侧的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (maskY &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        maskY = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (maskY &gt; maskMax) &#123;</span><br><span class="line">        maskY = maskMax;<span class="comment">//y的上限距离左侧的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    mask.style.left = maskX + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">    mask.style.top = maskY + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">    <span class="comment">//大图片移动距离=遮挡层移动距离*大图片移动距离/遮挡层最大移动距离</span></span><br><span class="line">    <span class="keyword">var</span> bigImg = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.bigImg&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> bigMax = bigImg.offsetWidth - big.offsetWidth;<span class="comment">//大图片最大移动距离</span></span><br><span class="line">    <span class="keyword">var</span> bigX = maskX * bigMax / maskMax;</span><br><span class="line">    <span class="keyword">var</span> bigY = maskY * bigMax / maskMax;</span><br><span class="line">    bigImg.style.left = -bigX + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">    bigImg.style.top = -bigY + <span class="string">&#x27;px&#x27;</span>;<span class="comment">//应该相反,鼠标左移时图片右移</span></span><br><span class="line">&#125;</span><br><span class="line">box.addEventListener(<span class="string">&#x27;mouseout&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="comment">//鼠标放在盒子外时让mask和big隐藏</span></span><br><span class="line">    mask.style.display = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">    big.style.display = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS案例-模态框拖动</title>
    <url>/2021/03/12/JS%E6%A1%88%E4%BE%8B-%E6%A8%A1%E6%80%81%E6%A1%86%E6%8B%96%E5%8A%A8/</url>
    <content><![CDATA[<p>本案例可以实现：点击即可弹出一个登录框，该登录框有点叉号关闭，鼠标拖动的功能</p>
<span id="more"></span>

<p>获取元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var login &#x3D; document.querySelector(&#39;.login&#39;);</span><br><span class="line">var mask &#x3D; document.querySelector(&#39;.login-bg&#39;);</span><br><span class="line">var link &#x3D; document.querySelector(&#39;#link&#39;);</span><br><span class="line">var closeBtn &#x3D; document.querySelector(&#39;#closeBtn&#39;);</span><br><span class="line">var title &#x3D; document.querySelector(&#39;#title&#39;);</span><br></pre></td></tr></table></figure>

<ol>
<li>点击弹出层，模态框和遮挡层就会显示出来display:block</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">link.addEventListener(&#39;click&#39;, function() &#123;</span><br><span class="line">        mask.style.display &#x3D; &#39;block&#39;;</span><br><span class="line">        login.style.display &#x3D; &#39;block&#39;;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>点击关闭按钮，隐藏遮挡层和模态框</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">closeBtn.addEventListener(&#39;click&#39;, function() &#123;</span><br><span class="line">        mask.style.display &#x3D; &#39;none&#39;;</span><br><span class="line">        login.style.display &#x3D; &#39;none&#39;;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>实现拖拽</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">title.addEventListener(<span class="string">&#x27;mousedown&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;<span class="comment">//鼠标按下，得到鼠标在盒子内坐标</span></span><br><span class="line">    <span class="keyword">var</span> x = e.pageX - login.offsetLeft;</span><br><span class="line">    <span class="keyword">var</span> y = e.pageY - login.offsetTop;</span><br><span class="line">    <span class="comment">// (2) 鼠标移动的时候，把鼠标在页面中的坐标，减去 鼠标在盒子内的坐标就是模态框的left和top值</span></span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">&#x27;mousemove&#x27;</span>, move)</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        login.style.left = e.pageX - x + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">        login.style.top = e.pageY - y + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// (3) 鼠标弹起，就让鼠标移动事件移除</span></span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">&#x27;mouseup&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">document</span>.removeEventListener(<span class="string">&#x27;mousemove&#x27;</span>, move);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>注意：直接把鼠标坐标给盒子会导致盒子左上角跟随鼠标，不可以，因此需要考虑盒子的坐标，同时不能通过offsetleft求盒子坐标，而鼠标在盒子内的坐标是不变的，因此<strong>鼠标在页面坐标-鼠标在盒子内坐标=盒子坐标</strong></p>
<p>完整代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .login-header &#123;</span><br><span class="line">            width: <span class="number">100</span>%;</span><br><span class="line">            text-align: center;</span><br><span class="line">            height: 30px;</span><br><span class="line">            font-size: 24px;</span><br><span class="line">            line-height: 30px;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ul,</span><br><span class="line">        li,</span><br><span class="line">        ol,</span><br><span class="line">        dl,</span><br><span class="line">        dt,</span><br><span class="line">        dd,</span><br><span class="line">        div,</span><br><span class="line">        p,</span><br><span class="line">        span,</span><br><span class="line">        h1,</span><br><span class="line">        h2,</span><br><span class="line">        h3,</span><br><span class="line">        h4,</span><br><span class="line">        h5,</span><br><span class="line">        h6,</span><br><span class="line">        a &#123;</span><br><span class="line">            padding: 0px;</span><br><span class="line">            margin: 0px;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        .login &#123;</span><br><span class="line">            display: none;</span><br><span class="line">            width: 512px;</span><br><span class="line">            height: 280px;</span><br><span class="line">            position: fixed;</span><br><span class="line">            border: #ebebeb solid 1px;</span><br><span class="line">            left: <span class="number">50</span>%;</span><br><span class="line">            top: <span class="number">50</span>%;</span><br><span class="line">            background: #ffffff;</span><br><span class="line">            box-shadow: 0px 0px 20px #ddd;</span><br><span class="line">            z-index: <span class="number">9999</span>;</span><br><span class="line">            transform: translate(-<span class="number">50</span>%, -<span class="number">50</span>%);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        .login-title &#123;</span><br><span class="line">            width: <span class="number">100</span>%;</span><br><span class="line">            margin: 10px 0px 0px 0px;</span><br><span class="line">            text-align: center;</span><br><span class="line">            line-height: 40px;</span><br><span class="line">            height: 40px;</span><br><span class="line">            font-size: 18px;</span><br><span class="line">            position: relative;</span><br><span class="line">            cursor: move;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        .login-input-content &#123;</span><br><span class="line">            margin-top: 20px;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        .login-button &#123;</span><br><span class="line">            width: <span class="number">50</span>%;</span><br><span class="line">            margin: 30px auto 0px auto;</span><br><span class="line">            line-height: 40px;</span><br><span class="line">            font-size: 14px;</span><br><span class="line">            border: #ebebeb 1px solid;</span><br><span class="line">            text-align: center;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        .login-bg &#123;</span><br><span class="line">            display: none;</span><br><span class="line">            width: <span class="number">100</span>%;</span><br><span class="line">            height: <span class="number">100</span>%;</span><br><span class="line">            position: fixed;</span><br><span class="line">            top: 0px;</span><br><span class="line">            left: 0px;</span><br><span class="line">            background: rgba(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">.3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        a &#123;</span><br><span class="line">            text-decoration: none;</span><br><span class="line">            color: #000000;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        .login-button a &#123;</span><br><span class="line">            display: block;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        .login-input input.list-input &#123;</span><br><span class="line">            float: left;</span><br><span class="line">            line-height: 35px;</span><br><span class="line">            height: 35px;</span><br><span class="line">            width: 350px;</span><br><span class="line">            border: #ebebeb 1px solid;</span><br><span class="line">            text-indent: 5px;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        .login-input &#123;</span><br><span class="line">            overflow: hidden;</span><br><span class="line">            margin: 0px 0px 20px 0px;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        .login-input label &#123;</span><br><span class="line">            float: left;</span><br><span class="line">            width: 90px;</span><br><span class="line">            padding-right: 10px;</span><br><span class="line">            text-align: right;</span><br><span class="line">            line-height: 35px;</span><br><span class="line">            height: 35px;</span><br><span class="line">            font-size: 14px;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        .login-title span &#123;</span><br><span class="line">            position: absolute;</span><br><span class="line">            font-size: 12px;</span><br><span class="line">            right: -20px;</span><br><span class="line">            top: -30px;</span><br><span class="line">            background: #ffffff;</span><br><span class="line">            border: #ebebeb solid 1px;</span><br><span class="line">            width: 40px;</span><br><span class="line">            height: 40px;</span><br><span class="line">            border-radius: 20px;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;login-header&quot;</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">&quot;link&quot;</span> <span class="attr">href</span>=<span class="string">&quot;javascript:;&quot;</span>&gt;</span>点击，弹出登录框<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span>&lt;/div&gt;</span><br><span class="line">    &lt;div id=<span class="string">&quot;login&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;login&quot;</span>&gt;</span><br><span class="line">        &lt;div id=<span class="string">&quot;title&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;login-title&quot;</span>&gt;登录会员</span><br><span class="line">            &lt;span&gt;<span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">&quot;closeBtn&quot;</span> <span class="attr">href</span>=<span class="string">&quot;javascript:void(0);&quot;</span> <span class="attr">class</span>=<span class="string">&quot;close-login&quot;</span>&gt;</span>关闭<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span>&lt;/span&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;login-input-content&quot;</span>&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;login-input&quot;</span>&gt;</span><br><span class="line">                &lt;label&gt;用户名：&lt;/label&gt;</span><br><span class="line">                &lt;input type=<span class="string">&quot;text&quot;</span> placeholder=<span class="string">&quot;请输入用户名&quot;</span> name=<span class="string">&quot;info[username]&quot;</span> id=<span class="string">&quot;username&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;list-input&quot;</span>&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;login-input&quot;</span>&gt;</span><br><span class="line">                &lt;label&gt;登录密码：&lt;/label&gt;</span><br><span class="line">                &lt;input type=<span class="string">&quot;password&quot;</span> placeholder=<span class="string">&quot;请输入登录密码&quot;</span> name=<span class="string">&quot;info[password]&quot;</span> id=<span class="string">&quot;password&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;list-input&quot;</span>&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div id=<span class="string">&quot;loginBtn&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;login-button&quot;</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:void(0);&quot;</span> <span class="attr">id</span>=<span class="string">&quot;login-button-submit&quot;</span>&gt;</span>登录会员<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span>&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- 遮盖层 --&gt;</span><br><span class="line">    &lt;div id=<span class="string">&quot;bg&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;login-bg&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="comment">// 1. 获取元素</span></span><br><span class="line">        <span class="keyword">var</span> login = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.login&#x27;</span>);</span><br><span class="line">        <span class="keyword">var</span> mask = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.login-bg&#x27;</span>);</span><br><span class="line">        <span class="keyword">var</span> link = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#link&#x27;</span>);</span><br><span class="line">        <span class="keyword">var</span> closeBtn = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#closeBtn&#x27;</span>);</span><br><span class="line">        <span class="keyword">var</span> title = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#title&#x27;</span>);</span><br><span class="line">        <span class="comment">// 2. 点击弹出层这个链接 link  让mask 和login 显示出来</span></span><br><span class="line">        link.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                mask.style.display = <span class="string">&#x27;block&#x27;</span>;</span><br><span class="line">                login.style.display = <span class="string">&#x27;block&#x27;</span>;</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="comment">// 3. 点击 closeBtn 就隐藏 mask 和 login </span></span><br><span class="line">        closeBtn.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                mask.style.display = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">                login.style.display = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="comment">// 4. 开始拖拽</span></span><br><span class="line">            <span class="comment">// (1) 当我们鼠标按下， 就获得鼠标在盒子内的坐标</span></span><br><span class="line">        title.addEventListener(<span class="string">&#x27;mousedown&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> x = e.pageX - login.offsetLeft;</span><br><span class="line">            <span class="keyword">var</span> y = e.pageY - login.offsetTop;</span><br><span class="line">            <span class="comment">// (2) 鼠标移动的时候，把鼠标在页面中的坐标，减去 鼠标在盒子内的坐标就是模态框的left和top值</span></span><br><span class="line">            <span class="built_in">document</span>.addEventListener(<span class="string">&#x27;mousemove&#x27;</span>, move)</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">                login.style.left = e.pageX - x + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">                login.style.top = e.pageY - y + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// (3) 鼠标弹起，就让鼠标移动事件移除</span></span><br><span class="line">            <span class="built_in">document</span>.addEventListener(<span class="string">&#x27;mouseup&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">document</span>.removeEventListener(<span class="string">&#x27;mousemove&#x27;</span>, move);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS案例-网页轮播图</title>
    <url>/2021/03/13/JS%E6%A1%88%E4%BE%8B-%E7%BD%91%E9%A1%B5%E8%BD%AE%E6%92%AD%E5%9B%BE/</url>
    <content><![CDATA[<ol>
<li>鼠标经过轮播图模块，左右按钮提示，离开隐藏左右按钮</li>
<li>点击右侧按钮一次，图片往左播放一张，以此类推，左侧按钮同理</li>
<li>图片播放的同事，下面小圆圈模块跟随一起变化</li>
<li>点击小圆圈，可以播放相应图片</li>
<li>鼠标不经过轮播图，轮播图也会自动播放图片</li>
<li>鼠标经过，轮播图模块自动播放停止</li>
</ol>
<span id="more"></span>

<p>第一步  鼠标经过显示按钮 鼠标离开按钮消失</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取元素</span></span><br><span class="line"><span class="keyword">var</span> arrow_l = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.arrow-l&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> arrow_r = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.arrow-r&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> focus = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.focus&#x27;</span>);</span><br><span class="line"><span class="comment">//鼠标经过显示按钮</span></span><br><span class="line">focus.addEventListener(<span class="string">&#x27;mouseenter&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    arrow_l.style.display = <span class="string">&#x27;block&#x27;</span>;</span><br><span class="line">    arrow_r.style.display = <span class="string">&#x27;block&#x27;</span>;</span><br><span class="line">&#125;)</span><br><span class="line">focus.addEventListener(<span class="string">&#x27;mouseleave&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    arrow_l.style.display = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">    arrow_r.style.display = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>第二步：考虑如何动态生成小圆圈 让小圆圈个数与图片个数一致</p>
<p>首先得到ul里图片个数，利用循环动态生成小圆圈，创建节点并插入节点，然后给第一个小圆圈插入current类</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">   <span class="comment">//动态生成小圆圈</span></span><br><span class="line">   <span class="keyword">var</span> ul = focus.querySelector(<span class="string">&#x27;ul&#x27;</span>);<span class="comment">//必须限定focus里面的</span></span><br><span class="line">   <span class="keyword">var</span> ol = focus.querySelector(<span class="string">&#x27;.circle&#x27;</span>);</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; ul.children.length; i++) &#123;</span><br><span class="line">       <span class="keyword">var</span> li = <span class="built_in">document</span>.createElement(<span class="string">&#x27;li&#x27;</span>);</span><br><span class="line">       ol.appendChild(li);</span><br><span class="line">       <span class="comment">//[]</span></span><br><span class="line">   &#125;</span><br><span class="line">ol.children[<span class="number">0</span>].className = <span class="string">&#x27;current&#x27;</span>;<span class="comment">//第一个小圆圈默认变色</span></span><br></pre></td></tr></table></figure>

<p>第三步：利用排他思想，实现点击小圆圈变色</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可以直接在生成小圆圈的同时绑定点击事件</span></span><br><span class="line">li.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; ol.children.length; i++) &#123;</span><br><span class="line">        ol.children[i].className = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.className = <span class="string">&#x27;current&#x27;</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>第四步：点击小圆圈滚动图片</p>
<p>注意是ul在移动</p>
<p>当点击某个小圆圈，就让图片滚动，移动距离为图片索引号*图片宽度</p>
<p>知识点：索引号如何得到？</p>
<ul>
<li>通过给每个li设定自定义属性点击时获取自定义属性</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ul = focus.querySelector(<span class="string">&#x27;ul&#x27;</span>);<span class="comment">//必须限定focus里面的</span></span><br><span class="line"><span class="keyword">var</span> ol = focus.querySelector(<span class="string">&#x27;.circle&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; ul.children.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> li = <span class="built_in">document</span>.createElement(<span class="string">&#x27;li&#x27;</span>);</span><br><span class="line">    <span class="comment">//通过自定义属性记录小圆圈索引号</span></span><br><span class="line">    li.setAttribute(<span class="string">&#x27;index&#x27;</span>, i);</span><br><span class="line">    ol.appendChild(li);</span><br><span class="line">    <span class="comment">//可以直接在生成小圆圈的同时绑定点击事件</span></span><br><span class="line">    li.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; ol.children.length; i++) &#123;</span><br><span class="line">            ol.children[i].className = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.className = <span class="string">&#x27;current&#x27;</span>;</span><br><span class="line">        <span class="comment">//点击小圆圈移动图片</span></span><br><span class="line">        <span class="keyword">var</span> index = <span class="built_in">this</span>.getAttribute(<span class="string">&#x27;index&#x27;</span>);</span><br><span class="line">        <span class="keyword">var</span> focusWidth = focus.offsetWidth;</span><br><span class="line">        animate(ul, -index * focusWidth);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第五步：点击左右按钮滚动</p>
<p>思路：声明一个变量，每点击一次number++</p>
<p>但是当点击次数过多会走到空白区域</p>
<p>如何实现无缝滚动？</p>
<ul>
<li>把ul第一个li复制一份，放到ul后面，当图片滚动到克隆的最后一张的时候不做动画直接快速跳回第一张：left=0，同时num=0；</li>
</ul>
<p>如何克隆第一张图片？</p>
<ul>
<li>利用节点的克隆和添加操作</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ol.children[<span class="number">0</span>].className = <span class="string">&#x27;current&#x27;</span>;<span class="comment">//第一个小圆圈默认变色</span></span><br><span class="line"><span class="keyword">var</span> firstLi = ul.children[<span class="number">0</span>].cloneNode(<span class="literal">true</span>);</span><br><span class="line">ul.appendChild(firstLi);<span class="comment">//克隆第一张图</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line">arrow_r.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num == ul.children.length - <span class="number">1</span>) &#123;</span><br><span class="line">        ul.style.left = <span class="number">0</span>;</span><br><span class="line">        num = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    num++;</span><br><span class="line">    animate(ul, -num * focusWidth);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>第六步：点击按钮小圆圈跟随变化</p>
<p>再定义一个变量circle，每次点击一次按钮则++，如果circle==4，说明走到最后这张图片，使circle复原</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> circle = <span class="number">0</span>;</span><br><span class="line">arrow_r.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num == ul.children.length - <span class="number">1</span>) &#123;</span><br><span class="line">        ul.style.left = <span class="number">0</span>;</span><br><span class="line">        num = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    num++;</span><br><span class="line">    animate(ul, -num * focusWidth);</span><br><span class="line">    <span class="comment">//实现点击按钮小圆圈跟随变化</span></span><br><span class="line">    circle++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (circle == ol.children.length) &#123;</span><br><span class="line">        circle = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; ol.children.length; i++) &#123;</span><br><span class="line">        ol.children[i].className = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ol.children[circle].className = <span class="string">&#x27;current&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>第七步：此时有两个bug</p>
<p>按钮的点击操作和圆点的点击是不同变量，无法共同使用,两个事件的变量需要同步</p>
<p>应该在点击小圆点事件中添加</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">num = index;</span><br><span class="line">circle = index;</span><br></pre></td></tr></table></figure>

<p>第八步:左侧按钮同理</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrow_l.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">            num = ul.children.length - <span class="number">1</span>;</span><br><span class="line">            ul.style.left = -num * focusWidth + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        num--;</span><br><span class="line">        animate(ul, -num * focusWidth);</span><br><span class="line">        <span class="comment">//实现点击按钮小圆圈跟随变化</span></span><br><span class="line">        circle--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (circle &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            circle = ol.children.length - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; ol.children.length; i++) &#123;</span><br><span class="line">            ol.children[i].className = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ol.children[circle].className = <span class="string">&#x27;current&#x27;</span>;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<p>第十步 代码优化 相同的可以封装函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">circleChange</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; ol.children.length; i++) &#123;</span><br><span class="line">        ol.children[i].className = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ol.children[circle].className = <span class="string">&#x27;current&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>三元表达式简化</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">circle = circle &lt; <span class="number">0</span> ? ol.children.length - <span class="number">1</span> : circle;</span><br><span class="line"><span class="comment">// if (circle &lt; 0) &#123;</span></span><br><span class="line"><span class="comment">//     circle = ol.children.length - 1;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<p>最后：自动播放！</p>
<p>发现自动播放时和点击右侧按钮很类似</p>
<p>可以手动调用右侧按钮点击事件arrow_r.click()</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">focus.addEventListener(<span class="string">&#x27;mouseenter&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    arrow_l.style.display = <span class="string">&#x27;block&#x27;</span>;</span><br><span class="line">    arrow_r.style.display = <span class="string">&#x27;block&#x27;</span>;</span><br><span class="line">    <span class="built_in">clearInterval</span>(timer);<span class="comment">//鼠标经过停止定时器</span></span><br><span class="line">    timer = none;</span><br><span class="line">&#125;)</span><br><span class="line">focus.addEventListener(<span class="string">&#x27;mouseleave&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    arrow_l.style.display = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">    arrow_r.style.display = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">    timer = <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="comment">//鼠标离开开启定时器</span></span><br><span class="line">        arrow_r.click();<span class="comment">//手动调用点击事件</span></span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>补充：节流阀</p>
<p>防止轮播图按钮连续点击造成播放过快</p>
<p>目的：当上一个函数动画执行完毕，再去执行下一个函数动画，让事件无法连续触发</p>
<p>利用回调函数，添加一个变量来控制，锁住函数和解锁函数</p>
<ul>
<li>开始设置一个变量var flag=true</li>
<li>if(flag) {flag=false;do something}关闭水龙头</li>
</ul>
<p>利用回调函数  动画执行完毕（使用回调函数），false=true 打开水龙头</p>
<p>完整js代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;load&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//获取元素</span></span><br><span class="line">    <span class="keyword">var</span> arrow_l = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.arrow-l&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> arrow_r = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.arrow-r&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> focus = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.focus&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> focusWidth = focus.offsetWidth;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//鼠标经过显示按钮</span></span><br><span class="line">    focus.addEventListener(<span class="string">&#x27;mouseenter&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        arrow_l.style.display = <span class="string">&#x27;block&#x27;</span>;</span><br><span class="line">        arrow_r.style.display = <span class="string">&#x27;block&#x27;</span>;</span><br><span class="line">        <span class="built_in">clearInterval</span>(timer);<span class="comment">//鼠标经过停止定时器</span></span><br><span class="line">        timer = none;</span><br><span class="line">    &#125;)</span><br><span class="line">    focus.addEventListener(<span class="string">&#x27;mouseleave&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        arrow_l.style.display = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">        arrow_r.style.display = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">        timer = <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="comment">//鼠标离开开启定时器</span></span><br><span class="line">            arrow_r.click();<span class="comment">//手动调用点击事件</span></span><br><span class="line">        &#125;, <span class="number">2000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//动态生成小圆圈</span></span><br><span class="line">    <span class="keyword">var</span> ul = focus.querySelector(<span class="string">&#x27;ul&#x27;</span>);<span class="comment">//必须限定focus里面的</span></span><br><span class="line">    <span class="keyword">var</span> ol = focus.querySelector(<span class="string">&#x27;.circle&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; ul.children.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> li = <span class="built_in">document</span>.createElement(<span class="string">&#x27;li&#x27;</span>);</span><br><span class="line">        <span class="comment">//通过自定义属性记录小圆圈索引号</span></span><br><span class="line">        li.setAttribute(<span class="string">&#x27;index&#x27;</span>, i);</span><br><span class="line">        ol.appendChild(li);</span><br><span class="line">        <span class="comment">//可以直接在生成小圆圈的同时绑定点击事件</span></span><br><span class="line">        li.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; ol.children.length; i++) &#123;</span><br><span class="line">                ol.children[i].className = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">this</span>.className = <span class="string">&#x27;current&#x27;</span>;</span><br><span class="line">            <span class="comment">//点击小圆圈移动图片</span></span><br><span class="line">            <span class="keyword">var</span> index = <span class="built_in">this</span>.getAttribute(<span class="string">&#x27;index&#x27;</span>);</span><br><span class="line">            <span class="comment">//当我们点击了某个li，就要把这个li的索引号给num//////////////////////////////bug必须改</span></span><br><span class="line">            num = index;</span><br><span class="line">            circle = index;</span><br><span class="line">            animate(ul, -index * focusWidth);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    ol.children[<span class="number">0</span>].className = <span class="string">&#x27;current&#x27;</span>;<span class="comment">//第一个小圆圈默认变色</span></span><br><span class="line">    <span class="keyword">var</span> firstLi = ul.children[<span class="number">0</span>].cloneNode(<span class="literal">true</span>);</span><br><span class="line">    ul.appendChild(firstLi);<span class="comment">//克隆第一张图</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> circle = <span class="number">0</span>;<span class="comment">//全局变量</span></span><br><span class="line">    <span class="keyword">var</span> flag = <span class="literal">true</span>;</span><br><span class="line">    arrow_r.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;<span class="comment">//关闭节流阀</span></span><br><span class="line">            <span class="keyword">if</span> (num == ul.children.length - <span class="number">1</span>) &#123;</span><br><span class="line">                ul.style.left = <span class="number">0</span>;</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            num++;</span><br><span class="line">            animate(ul, -num * focusWidth, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                flag = <span class="literal">true</span>;<span class="comment">//打开节流阀</span></span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">//实现点击按钮小圆圈跟随变化</span></span><br><span class="line">            circle++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (circle == ol.children.length) &#123;</span><br><span class="line">                circle = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            circleChange();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    arrow_l.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">                num = ul.children.length - <span class="number">1</span>;</span><br><span class="line">                ul.style.left = -num * focusWidth + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            num--;</span><br><span class="line">            animate(ul, -num * focusWidth, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">//实现点击按钮小圆圈跟随变化</span></span><br><span class="line">            circle--;</span><br><span class="line">            circle = circle &lt; <span class="number">0</span> ? ol.children.length - <span class="number">1</span> : circle;</span><br><span class="line">            <span class="comment">// if (circle &lt; 0) &#123;</span></span><br><span class="line">            <span class="comment">//     circle = ol.children.length - 1;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            circleChange();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">circleChange</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; ol.children.length; i++) &#123;</span><br><span class="line">            ol.children[i].className = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ol.children[circle].className = <span class="string">&#x27;current&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> timer = <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        arrow_r.click();<span class="comment">//手动调用点击事件</span></span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>animate.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animate</span>(<span class="params">obj, target, callback</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// console.log(callback);  callback = function() &#123;&#125;  调用的时候 callback()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先清除以前的定时器，只保留当前的一个定时器执行</span></span><br><span class="line">    <span class="built_in">clearInterval</span>(obj.timer);</span><br><span class="line">    obj.timer = <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 步长值写到定时器的里面</span></span><br><span class="line">        <span class="comment">// 把我们步长值改为整数 不要出现小数的问题</span></span><br><span class="line">        <span class="comment">// var step = Math.ceil((target - obj.offsetLeft) / 10);</span></span><br><span class="line">        <span class="keyword">var</span> step = (target - obj.offsetLeft) / <span class="number">10</span>;</span><br><span class="line">        step = step &gt; <span class="number">0</span> ? <span class="built_in">Math</span>.ceil(step) : <span class="built_in">Math</span>.floor(step);</span><br><span class="line">        <span class="keyword">if</span> (obj.offsetLeft == target) &#123;</span><br><span class="line">            <span class="comment">// 停止动画 本质是停止定时器</span></span><br><span class="line">            <span class="built_in">clearInterval</span>(obj.timer);</span><br><span class="line">            <span class="comment">// 回调函数写到定时器结束里面</span></span><br><span class="line">            <span class="comment">// if (callback) &#123;</span></span><br><span class="line">            <span class="comment">//     // 调用函数</span></span><br><span class="line">            <span class="comment">//     callback();</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            callback &amp;&amp; callback();<span class="comment">//借助短路运算如果有参数传入才会调用callback</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把每次加1 这个步长值改为一个慢慢变小的值  步长公式：(目标值 - 现在的位置) / 10</span></span><br><span class="line">        obj.style.left = obj.offsetLeft + step + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    &#125;, <span class="number">15</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>相关html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;focus&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;arrow-l&quot;</span>&gt;</span><span class="symbol">&amp;lt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;arrow-r&quot;</span>&gt;</span><span class="symbol">&amp;gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;upload/focus1.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;upload/focus1.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;upload/focus2.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;upload/focus3.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ol</span> <span class="attr">class</span>=<span class="string">&quot;circle&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>相关css</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.focus</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">721px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">455px</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.arrow-l</span>,<span class="selector-class">.arrow-r</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: -<span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">24px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">color</span>:<span class="built_in">rgb</span>(<span class="number">175</span>, <span class="number">170</span>, <span class="number">170</span>);</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">z-index</span>: <span class="number">10</span>;</span><br><span class="line">    <span class="attribute">background</span>:<span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>, .<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.arrow-l</span> &#123;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">0</span> <span class="number">30px</span> <span class="number">30px</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.arrow-r</span> &#123;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">30px</span> <span class="number">0</span> <span class="number">0</span> <span class="number">30px</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.focus</span> <span class="selector-tag">ul</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">600%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.focus</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span>&#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.circle</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">18px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.circle</span> <span class="selector-tag">li</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">12px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">12px</span>;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">8px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#e4e4e4</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">4px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.current</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>:  <span class="number">#e4e4e4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Less基础</title>
    <url>/2021/03/17/Less%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="Less介绍"><a href="#Less介绍" class="headerlink" title="Less介绍"></a>Less介绍</h2><p>Less是一门CSS扩展语言，也称为CSS预处理器，没有减少CSS的功能，而是为CSS加入程序式语言特性，加入了变量、Mixin（混入），运算及函数等功能</p>
<p>Less中文网址： <a href="http://lesscss.cn/">http://lesscss.cn/</a></p>
<p>常见的CSS预处理器：Sass、Less、Stylus</p>
<p>Less是一门css预处理语言，扩展了CSS的动态特性</p>
<span id="more"></span>

<h2 id="Less使用"><a href="#Less使用" class="headerlink" title="Less使用"></a>Less使用</h2><p>新建文件 后缀名为less</p>
<h3 id="Less变量"><a href="#Less变量" class="headerlink" title="Less变量"></a>Less变量</h3><p>@变量名：值；</p>
<p>变量名不能包含特殊字符不能数字开头且大小写敏感</p>
<h3 id="Less编译"><a href="#Less编译" class="headerlink" title="Less编译"></a>Less编译</h3><p>Less包含一套自定义语法及一个解析器</p>
<p>vscode easyLess</p>
<h3 id="Less嵌套"><a href="#Less嵌套" class="headerlink" title="Less嵌套"></a>Less嵌套</h3><p>可以进行嵌套,子元素直接写在父元素里</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line"><span class="selector-tag">a</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>:<span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果遇见交集选择器，伪类选择器，伪元素选择器</p>
<p>内层选择器没有&amp;符号，则被解析为后代,有就被解析为父元素自身或父元素的伪类</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.header</span>&#123;</span><br><span class="line">    <span class="selector-tag">&amp;</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>:<span class="number">#ccc</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">&amp;</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">        <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Less运算"><a href="#Less运算" class="headerlink" title="Less运算"></a>Less运算</h3><ul>
<li>任何数字、颜色或者变量都可以参与运算，提供了加减乘除运算</li>
<li>运算符中间左右必须有空格隔开</li>
<li>如果只有一个数有单位，则最后结果以该单位为准</li>
<li>如果两个数都有单位，且两个单位不一样，则以第一个单位为准</li>
</ul>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>‘JS案例-跟随鼠标的天使’</title>
    <url>/2021/03/11/JS%E6%A1%88%E4%BE%8B-%E8%B7%9F%E9%9A%8F%E9%BC%A0%E6%A0%87%E7%9A%84%E5%A4%A9%E4%BD%BF/</url>
    <content><![CDATA[<ol>
<li>鼠标不断的移动，使用鼠标移动事件：mousemove</li>
<li>在页面中移动，所以要给document注册事件</li>
<li>图片要移动距离，而且不占位置，使用绝对定位</li>
<li>核心原理：每次鼠标移动，都会得到最新的鼠标坐标，把这个xy作为图片的top和left值</li>
</ol>
<span id="more"></span>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    &lt;style&gt;</span><br><span class="line">        img &#123;</span><br><span class="line">            position: absolute;</span><br><span class="line">            top: 2px;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;img src&#x3D;&quot;images&#x2F;angel.gif&quot; alt&#x3D;&quot;&quot;&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        var pic &#x3D; document.querySelector(&#39;img&#39;);</span><br><span class="line">        document.addEventListener(&#39;mousemove&#39;, function (e) &#123;</span><br><span class="line">            console.log(1);</span><br><span class="line">            &#x2F;&#x2F;mousemove鼠标每移动1px就会触发这个事件</span><br><span class="line">            var x &#x3D; e.pageX;</span><br><span class="line">            var y &#x3D; e.pageY;</span><br><span class="line">            pic.style.left &#x3D; x - 40 + &#39;px&#39;;&#x2F;&#x2F;减图片大小的一半，使鼠标居中</span><br><span class="line">            pic.style.top &#x3D; y - 50 + &#39;px&#39;;&#x2F;&#x2F;必须加单位</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery基础</title>
    <url>/2021/03/20/jQuery%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>jQuery基础知识和基本使用</p>
<span id="more"></span>



<p>#JQuery基本使用</p>
<p>##概念</p>
<p>jQuery就是为了方便操作DOM，里面都是函数，内部用JS实现的</p>
<p>优点：轻量级、跨浏览器兼容、链式编程隐式迭代、对事件样式动画支持、免费开源</p>
<p>等DOM结构渲染完毕即可执行内部代码，不必等到所有外部资源加载完成，相当于原生js中的DOMContentLoaded，不同于load(全部加载完成)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(document).ready(function () &#123;</span><br><span class="line">    $(&#39;div&#39;).hide();&#x2F;&#x2F;隐藏div</span><br><span class="line">&#125;)</span><br><span class="line">$(function () &#123;</span><br><span class="line">    $(&#39;div&#39;).hide();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="顶级对象"><a href="#顶级对象" class="headerlink" title="顶级对象$"></a>顶级对象$</h2><p>$是jQuery的别称也是顶级对象</p>
<p>##jQuery对象和DOM对象</p>
<p>用jQuery获取的对象是jQuery对象，不同于DOM对象，本质是对DOM对象包装后产生的对象，用伪数组存储；二者的属性和方法不能混用，但是可以相互转换</p>
<p>DOM转化为jQuery  $(myDom)</p>
<p>jQuery转化为DOM  </p>
<p>$(myJquery)[index] ;// index是索引号,默认是0</p>
<p>$(myJquery).get(index);</p>
<h1 id="jQuery常用API"><a href="#jQuery常用API" class="headerlink" title="jQuery常用API"></a>jQuery常用API</h1><h2 id="jQuery选择器"><a href="#jQuery选择器" class="headerlink" title="jQuery选择器"></a>jQuery选择器</h2><p>$(“选择器”)//里面直接写CSS选择器即可</p>
<h2 id="jQuery改变样式"><a href="#jQuery改变样式" class="headerlink" title="jQuery改变样式"></a>jQuery改变样式</h2><p>$(“div”).css(“background-color”,”pink”);//把所有的div背景颜色改成粉色</p>
<h2 id="jQuery筛选选择器"><a href="#jQuery筛选选择器" class="headerlink" title="jQuery筛选选择器"></a>jQuery筛选选择器</h2><p>:first 选取第一个元素</p>
<p>:last</p>
<p>:eq(index)  选择第i个元素，第三个元素索引号为2</p>
<p>:odd 获取索引号为奇数</p>
<p>:even  索引号为偶数</p>
<h2 id="jQuery筛选方法"><a href="#jQuery筛选方法" class="headerlink" title="jQuery筛选方法"></a>jQuery筛选方法</h2><p><strong>parent()</strong>   父级</p>
<p><strong>children(selctor)</strong>  最近一级（亲儿子）</p>
<p><strong>find(selector)</strong>  后代选择器</p>
<p><strong>siblings(selector)</strong>  查找兄弟结点，<strong>不包括</strong>自己本身</p>
<p>nextAll([exptr]) 当前元素之后的所有同辈元素</p>
<p>prevtAll([expr]) 当前元素之前的所有同辈元素</p>
<p>hasClass(class)  检查当前元素是都含有某个特定类</p>
<p><strong>eq(index)</strong>  选择第i个元素，$(ul li).eq(2)相当于</p>
<p>​            $(“ul li:eq(2)”)但是更加灵活</p>
<h2 id="排他思想"><a href="#排他思想" class="headerlink" title="排他思想"></a>排他思想</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="string">&quot;button&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        $(<span class="built_in">this</span>).css(<span class="string">&quot;background&quot;</span>,<span class="string">&quot;pink&quot;</span>);</span><br><span class="line">        $(<span class="built_in">this</span>).siblings(<span class="string">&quot;button&quot;</span>).css(<span class="string">&quot;background&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>##获取索引号</p>
<p>$(this).index  获取索引号</p>
<h2 id="css方法样式操作"><a href="#css方法样式操作" class="headerlink" title="css方法样式操作"></a>css方法样式操作</h2><p>css方法：</p>
<ol>
<li>参数只写属性名，返回属性值 $(“div”).css(“width”);</li>
<li>参数是属性名，属性值，逗号分隔，修改属性值</li>
</ol>
<p>$(“div”).css(“width”,”300px”);//属性名必须加引号，如果值是数字可以不用写单位和引号</p>
<ol start="3">
<li>参数可以是对象的形式，不同属性逗号分开</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;div&quot;).css(&#123;</span><br><span class="line">    width:300px,</span><br><span class="line">    height:400;</span><br><span class="line">    backgroundColor: &quot;red&quot; </span><br><span class="line">    &#x2F;&#x2F;复合属性必须使用驼峰命名法，如果值不是数字则需要加引号</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>##添加删除类操作样式</p>
<p>$(“div”).addClass(“current”);</p>
<p>$(“this”).removeClass(“current”);</p>
<p>$(“this”).toggleClass(“current”);切换类（添加移除类）</p>
<p>jquery的类操作只会对指定类进行操作，不会覆盖原来类名</p>
<h2 id="jQuery效果"><a href="#jQuery效果" class="headerlink" title="jQuery效果"></a>jQuery效果</h2><p>###显示隐藏：</p>
<p>show([speed,[easing],[fn]])  一般情况都直接省略</p>
<p>速度(slow、normal、fast)或表示动画时长的毫秒值、第三个参数是回调函数</p>
<p>hide</p>
<p>toggle显示隐藏</p>
<p>###滑动</p>
<p>上拉滑动:slideUp(200)//200m下滑</p>
<p>下拉滑动:slideDown</p>
<h3 id="事件切换hover"><a href="#事件切换hover" class="headerlink" title="事件切换hover"></a>事件切换hover</h3><p>鼠标经过和离开的复合效果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;.nav&gt;li).hover(function()&#123;</span><br><span class="line">    $(this).children(&quot;ul&quot;).slideDown(200);</span><br><span class="line">    &#125;,function()&#123;</span><br><span class="line">        $(this).children(&quot;ul&quot;).slideUp(200);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>如果只写一个函数那么鼠标经过和鼠标离开都会触发这个函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;.nav&gt;li).hover(function()&#123;</span><br><span class="line">	$(this).children(&quot;ul&quot;).slideToggle();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>都可以实现下拉菜单的显示与隐藏，更简单一些</p>
<h3 id="动画队列及其停止排队方法"><a href="#动画队列及其停止排队方法" class="headerlink" title="动画队列及其停止排队方法"></a>动画队列及其停止排队方法</h3><p>动画或者效果一旦触发就会执行，如果多次触发，就会造成多个动画或者效果排队执行</p>
<p>将stop()写在动画或者效果的<strong>前面</strong>，相当于停止结束上一次的动画</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;.nav&gt;li).hover(function()&#123;</span><br><span class="line">	$(this).children(&quot;ul&quot;).stop().slideToggle();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="淡入淡出效果"><a href="#淡入淡出效果" class="headerlink" title="淡入淡出效果"></a>淡入淡出效果</h2><p>fadeIn(1000)  1000ms淡入</p>
<p>fadeOut()</p>
<p>fadeToggle</p>
<p>fadeTo(speed, opacity,[easing],[fn])修改透明度 速度和透明度必须写</p>
<h2 id="自定义动画animate"><a href="#自定义动画animate" class="headerlink" title="自定义动画animate"></a>自定义动画animate</h2><p>animate(params,[speed],[easing],[fn])</p>
<p>params:想要做动画的样式，以对象格式写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;div&quot;).animate(&#123;</span><br><span class="line">    left:500,&#x2F;&#x2F;想右走500</span><br><span class="line">    top:100,&#x2F;&#x2F;下走100</span><br><span class="line">    opacity:0.5&#x2F;&#x2F;边走边改透明度</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="jQuery属性操作"><a href="#jQuery属性操作" class="headerlink" title="jQuery属性操作"></a>jQuery属性操作</h1><h2 id="设置或获取元素固有属性值prop"><a href="#设置或获取元素固有属性值prop" class="headerlink" title="设置或获取元素固有属性值prop()"></a>设置或获取元素固有属性值prop()</h2><p>获取prop(“属性”)</p>
<p>设置$(“a”).prop(“title”,”current”)  //修改a的title属性为current</p>
<h2 id="属性改变事件"><a href="#属性改变事件" class="headerlink" title="属性改变事件"></a>属性改变事件</h2><p>$(“input”).change(function(){</p>
<p>})</p>
<h2 id="设置或获取自定义属性attr"><a href="#设置或获取自定义属性attr" class="headerlink" title="设置或获取自定义属性attr()"></a>设置或获取自定义属性attr()</h2><p>操作同prop</p>
<h2 id="数据缓存data"><a href="#数据缓存data" class="headerlink" title="数据缓存data()"></a>数据缓存data()</h2><p>可以在指定元素上存取数据，并不会修改DOM元素结构。一旦页面刷新数据就会被移除</p>
<p>获取H5自定义属性时不用写data-(Attr需要)，且返回的是数字型</p>
<h1 id="jQuery内容文本值"><a href="#jQuery内容文本值" class="headerlink" title="jQuery内容文本值"></a>jQuery内容文本值</h1><p>针对元素的内容还有表单的值进行操作</p>
<h2 id="普通元素内容html"><a href="#普通元素内容html" class="headerlink" title="普通元素内容html()"></a>普通元素内容html()</h2><p>相当于原生innerHTML</p>
<p>html(“值”)设置元素的内容</p>
<p>##普通元素文本内容text()</p>
<p>相当于原生innerText  忽略标签</p>
<p>##获取设置表单值val()  </p>
<p>相当于原生的value()</p>
<p>$(“input”).val(“123”);//将input的value改成123</p>
<h1 id="jQuery元素操作"><a href="#jQuery元素操作" class="headerlink" title="jQuery元素操作"></a>jQuery元素操作</h1><h2 id="遍历元素"><a href="#遍历元素" class="headerlink" title="遍历元素"></a>遍历元素</h2><p>隐式迭代可以对同一类元素做同样的操作，但是如果想要给同一类元素做不同操作，需要用到遍历</p>
<p>$(“div”.each(function(index,domEle){xxx;}))</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;把三个盒子设置不同颜色</span><br><span class="line">var arr&#x3D;[&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;]</span><br><span class="line">$(&quot;div&quot;).each(function(index,domEle))&#123;&#x2F;&#x2F;自动设置索引号，都是自己命名的</span><br><span class="line">    &#x2F;&#x2F;第二个参数一定是dom元素对象</span><br><span class="line">    $(domEle).css(&quot;color&quot;,arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>$.each(object,function(index,element){xxx;})</p>
<p>可以实现对数组、对象的遍历</p>
<h2 id="创建元素"><a href="#创建元素" class="headerlink" title="创建元素"></a>创建元素</h2><p>var li=$(“li”);</p>
<p>##添加元素</p>
<p>$(“ul”).append(“li”);//内部添加并且放在内容最后面</p>
<p>$(“ul”).prepend(“li”);//内部添加并且放在内容最前面</p>
<p>$(“.test”).after(“div”);//把内容放在目标元素后面</p>
<p>$(“.test”).before(“div”);//把内容放在目标元素前面</p>
<p>内部元素添加后是父子关系；外部添加后是兄弟关系</p>
<h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><p>$(“ul”).remove()//删除本身</p>
<p>$(“ul”).empty()//删除所有孩子</p>
<p>$(“ul”).html(“”)//删除所有孩子</p>
<p>#jQuery事件操作</p>
<h2 id="单个事件注册"><a href="#单个事件注册" class="headerlink" title="单个事件注册"></a>单个事件注册</h2><p>$(“div”).click(function(){</p>
<p>})</p>
<h2 id="事件处理on-绑定事件"><a href="#事件处理on-绑定事件" class="headerlink" title="事件处理on()绑定事件"></a>事件处理on()绑定事件</h2><p>element.on(events,[selector],fn)</p>
<p>selector是选择器，用于实现事件委托</p>
]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title>数据链路层组成和原理</title>
    <url>/2021/04/01/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E7%BB%84%E6%88%90%E5%92%8C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>​    数据链路层定义了在单个链路上如何传输数据。这些协议与被讨论的各种介质有关。</p>
<p>​    数据链路层必须具备一系列相应的功能，主要有：如何将数据组合成数据块，在数据链路层中称这种数据块为帧，帧是数据链路层的传送单位；如何控制帧在物理信道上的传输，包括如何处理传输差错，如何调节发送速率以使与接收方相匹配；以及在两个网络实体之间提供数据链路通路的建立、维持和释放的管理。 </p>
<span id="more"></span>

<p>#1.为网络层提供服务</p>
<p>计算机网络分层结构的基本要求包括要保持下层对上层的独立性，上层单向使用下层提供的服务。</p>
<p>数据链路层的上层是网络层，因此数据链路层需要上上层提供三种服务：</p>
<ul>
<li>无确认的无连接服务。适用于实时通信或误码率较低的通信信道，如以太网服务</li>
<li>有确认的无连接服务。适用于误码率较高的通信信道，如无线通信</li>
<li>有确认的面向连接服务。适合于通信要求较高的场合</li>
</ul>
<p>#2.链路管理</p>
<p>主要用于面向连接的服务，链路两端的结点要通信，需要进行数据链路层连接的建立、维持和释放等过程。</p>
<p>#3.帧定界、帧同步与透明传输</p>
<p>为了把每帧区分开来，一般在一段数据的首尾添加首部和尾部字符串。</p>
<p><strong>帧定界</strong>就是指确定帧的界限，<strong>帧同步</strong>就是让接收方能够区分帧的起始和终止，<strong>透明传输</strong>就是不管传的数据是怎样的组合都能在链路上正常传送(不被首尾字符串干扰)</p>
<p>怎样实现上述功能？组帧，一般常用的是零比特填充的首尾标志法和违规编码法</p>
<p>组帧的四种方法：</p>
<ul>
<li>字符计数法(头部使用一个技术字段表明帧内字符数，但是无法解决计数字段出错问题)</li>
<li>字符填充的首尾定界符法(首部用SOH，尾部用EOT，中间特殊字符用ESC转义)</li>
<li>零比特填充的首尾标志法(01111110标志帧开始和结束，中间遇到5个1则填0，接收方收到5个1去0)</li>
<li>违规编码法(曼彻斯特编码，使用高-高或低-低用于表示首尾)</li>
</ul>
<p>#4.流量控制与可靠传输</p>
<p>防止发送能力大于接收方的接收能力，对于数据链路层来说，控制的是相邻两节点之间数据链路上的流量。</p>
<p>常见有两种方式：停止-等待协议和滑动窗口协议</p>
<p><strong>停止等待协议</strong>：发送方每发送一帧都要等待接收方的应答信号，再发送下一帧；接收方收到就反馈一个应答帧，效率很低；</p>
<p><strong>滑动窗口协议</strong>：设置一个发送窗口和一个接收窗口，用于控制哪些帧可以发送或者接收；</p>
<p>​    发送方在未收到确认的情况下只能发送发送窗口里的帧；接收方只有接收到在接收窗口里的帧时才会手下，其他的全部舍弃。</p>
<p>​    发送方每收到一个确认帧，发送窗口就向前移动；接收端收到一个数据帧就前移</p>
<p><strong>可靠传输：</strong>确认和超时重传</p>
<p>​    某些情况下将确认捎带到一个回复帧中，称为捎带确认</p>
<p>​    发送某个数据帧后开启一个定时器，如果时间到后没回复，就重新发送直到发送成功，称为超时重传。</p>
<p><strong>自动重传请求</strong>：</p>
<p>​    是指接收方请求发送方重传出错的数据帧，是常用处理差错的方法之一。包括停止-等待ARQ、后退N帧ARQ和选择性重传ARQ。</p>
<p>​    <strong>停止等待协议：</strong>①计时器满未收到确认重新发送②确认帧被破坏，发送方重新发送数据帧，接收方收到后丢弃重复帧，并重传一个确认帧。缺点：信道利用率低</p>
<p>​    <strong>后退N帧协议(GBN)：</strong>①累积确认。连续收到好几个正确帧后一起确认，确认表明该帧及之前的帧都正确收到</p>
<p>​    ②接收方只按序接收数据帧，不按序的数据帧无情丢弃</p>
<p>​    ③接收方只确认序列号最大的按序发送的帧</p>
<p>​    ④接收窗口长度为1，实现有序接收,发送窗口长度小于2^n^-1</p>
<p>​    缺点：重传时必须把原来已经正确传送的数据帧重传</p>
<p>​    <strong>选择重传协议(SR)</strong>:①对数据帧逐一确认，收一个确认一个</p>
<p>​    ②接收方怀疑出错就会发送NAK帧，要求发送方重传NAK中指定的帧，只重传出错帧</p>
<p>​    ③失序的帧先缓存，有序后一起后移窗口(缓冲区数目等于窗口大小)</p>
<p>​    ④接收窗口和发送窗口的最大长度为2^n-1^</p>
<p>#5.差错控制</p>
<p>由于信道噪声等因素，传输中可能出现差错</p>
<p>如何实现差错控制的呢？主要是检错编码和纠错编码</p>
<p>​    检错编码包括奇偶校验码和循环冗余码，其中CRC码只使用检错功能，出错就直接丢弃；循环冗余码使用模2除运算余数即为冗余位。</p>
<p>​    纠错编码主要是海明码，可以纠正单比特错误，发现双比特错误，海明码纠错d位，需要码距为2d+1的编码方案，检错d位，需要码距为d+1。</p>
<h1 id="介质访问控制"><a href="#介质访问控制" class="headerlink" title="介质访问控制"></a>介质访问控制</h1><p>​    在广播信道中，可能有很多结点之间需要传送数据，但是同一个信道同时如果有多对结点在传送数据且不加处理就会发生冲突，因此就需要介质访问控制。用来决定广播信道中信道分配的协议属于数据链路层的一个子层，称为介质访问控制子层。</p>
<p>##信道划分介质访问控制</p>
<p>​    实质是通过分时、分频、分码等方法把原来的一条广播信道，逻辑上分为几条用于两个结点间通信的互不干扰的子信道，实际上就是把广播通信转变为点对点通信。</p>
<p>​    频分多路复用(FDM)</p>
<p>​    时分多路复用(TDM)</p>
<p>​    波分多路复用(WDM)：利用光纤中信号波长的不同</p>
<p>​    <strong>码分多路复用(CDM)</strong>:采用不同的编码来区分各路原始信号</p>
<p>​        码分多址(CDMA Code Division Multiple Access),将每个比特时间再划分为m个短的时间槽，称为码片，发送1时，站点发送它的码片序列；发送0时，站点发送该码片序列的反码，多站点同时发送时，要求各个站点的码片序列相互正交。实质就是让每个站点码片分为不同相互正交的向量，接收端收到后再通过一定计算拆成各个分量。</p>
<h2 id="随机访问介质访问控制"><a href="#随机访问介质访问控制" class="headerlink" title="随机访问介质访问控制"></a>随机访问介质访问控制</h2><p>​    不采用集中控制的方式解决发送信息的次序问题，所有用户能够根据自己的意愿发送信息，占用信道全部速率。又称争用型协议。实质是广播信道转化为点对点信道。</p>
<h3 id="ALOHA协议"><a href="#ALOHA协议" class="headerlink" title="ALOHA协议"></a>ALOHA协议</h3><p>纯ALOHA协议：</p>
<p>不进行检测就发送数据，超时没收到确认就是发生了冲突，<strong>随机</strong>等待一定时间后重新发送，直到发送成功</p>
<p>时隙ALOHA协议：</p>
<p>将时间划分为一段段等长的时隙，只有在每个时隙开始时才能发送一个帧，避免了用户发送数据的随意性，减少了数据产生冲突的可能性，提高了信道的利用率。</p>
<h3 id="CSMA协议-Carrier-Sense-Multiple-Access"><a href="#CSMA协议-Carrier-Sense-Multiple-Access" class="headerlink" title="CSMA协议(Carrier Sense Multiple Access)"></a>CSMA协议(Carrier Sense Multiple Access)</h3><p>每个站点发送前先侦听一下共用信道，发现信道空闲后再发送。</p>
<p>根据侦听方式和侦听到信道忙后的处理方式不同，CSMA协议分为三种。</p>
<table>
<thead>
<tr>
<th>信道状态</th>
<th>1-坚持</th>
<th>非坚持</th>
<th>p-坚持</th>
</tr>
</thead>
<tbody><tr>
<td>空闲</td>
<td>立即发送数据</td>
<td>立即发送数据</td>
<td>以p概率发送数据，以1-p概率推迟到下一个时隙</td>
</tr>
<tr>
<td>忙</td>
<td>等待，坚持侦听，直到空闲，冲突则随机等待一段时间后重新开始侦听</td>
<td>放弃侦听，等待一个随机时间后再侦听</td>
<td>持续侦听，直至信道空闲</td>
</tr>
<tr>
<td>特点</td>
<td>容易冲突，受传播延迟影响大</td>
<td>降低了冲突概率，但是增加了平均延迟</td>
<td>前面两种的折中方案</td>
</tr>
</tbody></table>
<h3 id="CSMA-CD协议-Carrier-Sense-Multiple-Access-with-Collision-Dection"><a href="#CSMA-CD协议-Carrier-Sense-Multiple-Access-with-Collision-Dection" class="headerlink" title="CSMA/CD协议(Carrier Sense Multiple Access with Collision Dection)"></a>CSMA/CD协议(Carrier Sense Multiple Access with Collision Dection)</h3><p>CSMA协议的改进方案，适用于总线型网络或半双工网络环境，如以太网。</p>
<p>先听后发，边听边发，冲突停发，随机重发</p>
<p>经过两倍的传输时延就额可以直到发送的帧没有发生碰撞，2τ称为<strong>争用期</strong>。</p>
<p><strong>最小帧长</strong>=总线传播时延*数据传输速率 *2；</p>
<p><strong>二进制指数退避算法(用于解决碰撞问题)：</strong></p>
<p>k=min[重传次数，10]，从[0,1,…,2^k^]中随机取出一个数r，重传所需要退避的时间就是r倍的基本退避时间，即2rτ，重传16次后说明网络太拥挤，认为此帧无法发出，抛弃此帧并向高层报错</p>
<h3 id="CSMA-CA协议"><a href="#CSMA-CA协议" class="headerlink" title="CSMA/CA协议"></a>CSMA/CA协议</h3><p>适用于无线局域网</p>
<p>无线局域网并非所有站点都能听见对方，存在隐蔽站问题，且无线介质上信号强度动态变化范围很大，难以实现碰撞检测。所以把碰撞检测改为碰撞避免。</p>
<p>在发送数据时广播告知其他结点，让其他结点在某段时间内不要发送数据</p>
<h3 id="CSMA-CD与CSMA-CA区别"><a href="#CSMA-CD与CSMA-CA区别" class="headerlink" title="CSMA/CD与CSMA/CA区别"></a>CSMA/CD与CSMA/CA区别</h3><ul>
<li>CSMA/CD可以检测冲突但无法避免；CA不能检测只能尽量避免</li>
<li>CSMA/CD用于总线型以太网，CA用于无线局域网等</li>
<li>检测方式不同，CD通过电缆中电压的变化来检测，CA采用能量检测、载波检测和能量载波混合检测等</li>
</ul>
]]></content>
      <categories>
        <category>408</category>
      </categories>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>京东移动端仿制html+css流式布局</title>
    <url>/2021/03/16/%E6%A1%88%E4%BE%8B-%E4%BA%AC%E4%B8%9C%E7%A7%BB%E5%8A%A8%E7%AB%AF%E4%BB%BF%E5%88%B6html-css%E6%B5%81%E5%BC%8F%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<p>练习京东移动端页面的制作</p>
<p>使用流式布局</p>
<span id="more"></span>

<p>##顶端app栏</p>
<p><img src="C:\Users\LiJing\AppData\Local\Temp\1615899040327.png" alt="1615899040327"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;images/close.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;images/logo.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>打开京东app，购物更轻松<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>立即打开<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>分为四块</p>
<p>##搜索框栏</p>
<p><img src="C:\Users\LiJing\AppData\Local\Temp\1615899108579.png" alt="1615899108579"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;search-wrap&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;search-btn&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;search&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;jd-icon&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;sou&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;search-login&quot;</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>中间搜索栏不固定宽度，用margin调边距，即可实现随屏幕变化改变长度，旁边两块用定位</li>
</ul>
<p>##广告栏</p>
<p><img src="C:\Users\LiJing\AppData\Local\Temp\1615899276613.png" alt="1615899276613"></p>
<ul>
<li>让搜索盒子出现在大图上面，改成fixed（固定定位），同时固定定位必须给宽度，设为100%</li>
<li>清除图片下缝隙：vertical-align:middle</li>
</ul>
<p><img src="C:\Users\LiJing\AppData\Local\Temp\1615899748360.png" alt="1615899748360"></p>
<p>由三个图片组成，三个div每个33.33%，图片设为宽度100%</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main-content&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;slider&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;upload/banner.dpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;brand&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;upload/pic1.dpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;upload/pic2.dpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;upload/pic3.dpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="京东DPG图片压缩"><a href="#京东DPG图片压缩" class="headerlink" title="京东DPG图片压缩"></a>京东DPG图片压缩</h2><p>节省百分之五十的浏览流量，提升了用户的网页打开速度，压缩后的图片和webp的清晰度对比没有差距</p>
<p>webp图片格式加快图片加载速度</p>
<h2 id="导航图标栏"><a href="#导航图标栏" class="headerlink" title="导航图标栏"></a>导航图标栏</h2><p>其中一个图标</p>
<p><img src="C:\Users\LiJing\AppData\Local\Temp\1615902249000.png" alt="1615902249000"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;upload/nav1.webp&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>京东超市<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="新闻快报"><a href="#新闻快报" class="headerlink" title="新闻快报"></a>新闻快报</h2><p><img src="C:\Users\LiJing\AppData\Local\Temp\1615903109661.png" alt="1615903109661"></p>
<p>三个盒子分别50%、25%、25%</p>
<p>竖线通过边框实现，可以使用CSS3盒子模型box-sizing防止加边框后掉下去</p>
<h2 id="CSS代码"><a href="#CSS代码" class="headerlink" title="CSS代码"></a>CSS代码</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">*&#123;</span><br><span class="line">    -webkit-tap-highlight-<span class="attribute">color</span>: transparent;</span><br><span class="line">    -webkit-appearance: none;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">img</span>,<span class="selector-tag">a</span>&#123;-webkit-touch-callout:none;&#125;</span><br><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">min-width</span>: <span class="number">320px</span>;</span><br><span class="line">    <span class="attribute">max-width</span>: <span class="number">640px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">    <span class="attribute">font-family</span>: -apple-system, Helvetica,sans-serif;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#666</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">1.5</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#666</span>;</span><br><span class="line">    <span class="attribute">text-decoration</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">ul</span>&#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">list-style</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">    <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.app</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">45px</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.app</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span>&#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">45px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#333</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">45px</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.app</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">8%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.app</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child</span>(<span class="number">1</span>) <span class="selector-tag">img</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.app</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>)&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">10%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.app</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>) <span class="selector-tag">img</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">    <span class="comment">/* 图片默认和文字的基线对齐，图片是行内块元素 需要用这种方式对齐 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.app</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child</span>(<span class="number">3</span>)&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">57%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.app</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child</span>(<span class="number">4</span>)&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">25%</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#f63515</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.search-wrap</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: fixed;</span><br><span class="line">    <span class="attribute">min-width</span>: <span class="number">320px</span>;</span><br><span class="line">    <span class="attribute">max-width</span>: <span class="number">640px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    <span class="comment">/* 外边距塌陷 */</span></span><br><span class="line">    <span class="attribute">height</span>: <span class="number">44px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.search-btn</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">44px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.search-btn</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">18px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">../images/s-btn.png</span>) no-repeat;</span><br><span class="line">    <span class="attribute">background-size</span>: <span class="number">20px</span> <span class="number">18px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">14px</span> <span class="number">0</span> <span class="number">0</span> <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.search</span> &#123;</span><br><span class="line">    <span class="comment">/* 不给宽度会自动铺满，通过margin调整边距 */</span></span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>:<span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">7px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.search-login</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">44px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">44px</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.jd-icon</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">8px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">13px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">../images/jd.png</span>) no-repeat;</span><br><span class="line">    <span class="attribute">background-size</span>: <span class="number">20px</span> <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.jd-icon</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="attribute">right</span>: -<span class="number">8px</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">1px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.sou</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">8px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">18px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: powderblue;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">../images/jd-sprites.png</span>) no-repeat -<span class="number">81px</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">background-size</span>: <span class="number">200px</span> auto;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.slider</span> <span class="selector-tag">img</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.brand</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    <span class="comment">/* 切掉图片圆角 */</span></span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">10px</span> <span class="number">10px</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.brand</span> <span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">33.33%</span>;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.brand</span> <span class="selector-tag">div</span> <span class="selector-tag">img</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">nav</span> &#123;</span><br><span class="line">    <span class="attribute">padding-top</span>: <span class="number">10px</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">nav</span> <span class="selector-tag">a</span>&#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">20%</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">nav</span> <span class="selector-tag">a</span> <span class="selector-tag">img</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">10px</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">nav</span> <span class="selector-tag">a</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.news</span> &#123;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.news</span> <span class="selector-tag">img</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.news</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="comment">/* 边框不会撑大盒子 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.news</span> <span class="selector-tag">a</span><span class="selector-pseudo">:nth-child</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.news</span> <span class="selector-tag">a</span><span class="selector-pseudo">:nth-child</span>(n+<span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">/* 选出第二、三个 */</span></span><br><span class="line">    <span class="attribute">width</span>: <span class="number">25%</span>;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>苏宁首页移动端仿制-rem布局</title>
    <url>/2021/03/18/%E6%A1%88%E4%BE%8B-%E8%8B%8F%E5%AE%81%E9%A6%96%E9%A1%B5%E7%A7%BB%E5%8A%A8%E7%AB%AF%E4%BB%BF%E5%88%B6-rem%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<p>使用rem适配布局仿制苏宁移动端首页练习</p>
<p>总结：使用rem布局时需要使用rem单位，需要较多的单位转换，一般设置默认字体为@basefont，方便后期维护；Less布局的嵌套变量都具有很高的实用性，提高了代码的逻辑性。</p>
<span id="more"></span>

<p>成品图：</p>
<img src="https://www.hualigs.cn/image/6052c6b08add1.jpg"/>

<ol>
<li>common.css</li>
</ol>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置常见的屏幕尺寸 修改里面的html文字大小</span></span><br><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">text-decoration</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 一定要写到最上面</span></span><br><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 我们此次定义的划分的份数 为 15</span></span><br><span class="line"><span class="variable">@no:</span> <span class="number">15</span>;</span><br><span class="line"><span class="comment">// 320</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">320px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">html</span> &#123;</span><br><span class="line">        <span class="attribute">font-size</span>: (<span class="number">320px</span> / <span class="variable">@no</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 360</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">360px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">html</span> &#123;</span><br><span class="line">        <span class="attribute">font-size</span>: (<span class="number">360px</span> / <span class="variable">@no</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 375 iphone 678</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">375px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">html</span> &#123;</span><br><span class="line">        <span class="attribute">font-size</span>: (<span class="number">375px</span> / <span class="variable">@no</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 384</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">384px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">html</span> &#123;</span><br><span class="line">        <span class="attribute">font-size</span>: (<span class="number">384px</span> / <span class="variable">@no</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 400</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">400px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">html</span> &#123;</span><br><span class="line">        <span class="attribute">font-size</span>: (<span class="number">400px</span> / <span class="variable">@no</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 414</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">414px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">html</span> &#123;</span><br><span class="line">        <span class="attribute">font-size</span>: (<span class="number">414px</span> / <span class="variable">@no</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 424</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">424px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">html</span> &#123;</span><br><span class="line">        <span class="attribute">font-size</span>: (<span class="number">424px</span> / <span class="variable">@no</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 480</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">480px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">html</span> &#123;</span><br><span class="line">        <span class="attribute">font-size</span>: (<span class="number">480px</span> / <span class="variable">@no</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 540</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">540px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">html</span> &#123;</span><br><span class="line">        <span class="attribute">font-size</span>: (<span class="number">540px</span> / <span class="variable">@no</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 720</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">720px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">html</span> &#123;</span><br><span class="line">        <span class="attribute">font-size</span>: (<span class="number">720px</span> / <span class="variable">@no</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 750</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">750px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">html</span> &#123;</span><br><span class="line">        <span class="attribute">font-size</span>: (<span class="number">750px</span> / <span class="variable">@no</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>在index.less中导入common.less</strong></li>
</ol>
<p>可以把一个样式文件导入另一个样式文件，导入后不需要在html中引入原CSS文件</p>
<p>link是把一个样式文件引入到html页面里面</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">&quot;common&quot;</span>;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>header</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;search-content&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">class</span>=<span class="string">&quot;classify&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;search&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;search&quot;</span> <span class="attr">value</span>=<span class="string">&quot;厨卫保暖记 每千减百&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">class</span>=<span class="string">&quot;login&quot;</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Less</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@basefont:</span><span class="number">50</span>;</span><br><span class="line"><span class="selector-class">.search-content</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">position</span>: fixed;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: translateX(-<span class="number">50%</span>);</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">15rem</span>;</span><br><span class="line">    <span class="attribute">height</span>: (<span class="number">88rem</span> / <span class="variable">@basefont</span>);</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#ffc001</span>;</span><br><span class="line">    <span class="selector-class">.classify</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: (<span class="number">44rem</span>/<span class="variable">@basefont</span>);</span><br><span class="line">        <span class="attribute">height</span>: (<span class="number">70rem</span> / <span class="variable">@basefont</span>);</span><br><span class="line">        <span class="attribute">background</span>: url(<span class="string">../images/classify.png</span>) no-repeat;</span><br><span class="line">        <span class="attribute">background-size</span>: (<span class="number">44rem</span>/<span class="variable">@basefont</span>) (<span class="number">70rem</span> / <span class="variable">@basefont</span>);</span><br><span class="line">        <span class="attribute">margin</span>: (<span class="number">11rem</span>/<span class="variable">@basefont</span>) (<span class="number">25rem</span>/<span class="variable">@basefont</span>) (<span class="number">7rem</span>/<span class="variable">@basefont</span>) (<span class="number">24rem</span>/<span class="variable">@basefont</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.search</span> &#123;</span><br><span class="line">        <span class="attribute">flex</span>:<span class="number">1</span> ;</span><br><span class="line">        <span class="selector-tag">input</span> &#123;</span><br><span class="line">            <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">            <span class="attribute">border</span>: <span class="number">0</span>;</span><br><span class="line">            <span class="attribute">height</span>: (<span class="number">66rem</span>/<span class="variable">@basefont</span>);</span><br><span class="line">            <span class="attribute">border-radius</span>: (<span class="number">33rem</span>/<span class="variable">@basefont</span>);</span><br><span class="line">            <span class="attribute">background-color</span>: <span class="number">#fff3cc</span>;</span><br><span class="line">            <span class="attribute">margin-top</span>: (<span class="number">12rem</span>/<span class="variable">@basefont</span>);</span><br><span class="line">            <span class="attribute">font-size</span>: (<span class="number">25rem</span>/<span class="variable">@basefont</span>);</span><br><span class="line">            <span class="attribute">padding-left</span>: (<span class="number">55rem</span>/<span class="variable">@basefont</span>);</span><br><span class="line">            <span class="attribute">color</span>: <span class="number">#757575</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.login</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: (<span class="number">75rem</span>/<span class="variable">@basefont</span>);</span><br><span class="line">        <span class="attribute">height</span>: (<span class="number">70rem</span>/<span class="variable">@basefont</span>);</span><br><span class="line">        <span class="attribute">margin</span>: (<span class="number">10rem</span>/<span class="variable">@basefont</span>);</span><br><span class="line">        <span class="attribute">font-size</span>: (<span class="number">25rem</span>/<span class="variable">@basefont</span>);</span><br><span class="line">        <span class="attribute">text-align</span>: center;</span><br><span class="line">        <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">        <span class="attribute">line-height</span>: (<span class="number">70rem</span>/<span class="variable">@basefont</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>banner</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;banner&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;upload/banner.gif&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Less</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.banner</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: (<span class="number">750rem</span>/<span class="variable">@basefont</span>);</span><br><span class="line">    <span class="attribute">height</span>: (<span class="number">368rem</span>/<span class="variable">@basefont</span>);</span><br><span class="line">    <span class="selector-tag">img</span>&#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.ad</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="selector-tag">a</span>&#123;</span><br><span class="line">        <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">        <span class="selector-tag">img</span>&#123;</span><br><span class="line">            <span class="comment">// 记得盒子限制大小后还要限制图片</span></span><br><span class="line">            <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>广告栏</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ad&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;upload/ad1.gif&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;upload/ad2.gif&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;upload/ad3.gif&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Less</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.ad &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    a&#123;</span><br><span class="line">        flex: 1;</span><br><span class="line">        img&#123;</span><br><span class="line">            &#x2F;&#x2F; 记得盒子限制大小后还要限制图片</span><br><span class="line">            width: 100%;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>导航栏</li>
</ol>
<p>使用浮动布局，十个大小相同的盒子排为两行</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;nav&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;upload/nav1.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>爆款手机<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    省略</span><br></pre></td></tr></table></figure>

<p>Less</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.nav</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: (<span class="number">750rem</span>/<span class="variable">@basefont</span>);</span><br><span class="line">    <span class="selector-tag">a</span> &#123;</span><br><span class="line">        <span class="attribute">float</span>: left;</span><br><span class="line">        <span class="attribute">width</span>: (<span class="number">150rem</span>/<span class="variable">@basefont</span>);</span><br><span class="line">        <span class="attribute">height</span>: (<span class="number">140rem</span>/<span class="variable">@basefont</span>);</span><br><span class="line">        <span class="attribute">text-align</span>: center;</span><br><span class="line">        <span class="selector-tag">img</span> &#123;</span><br><span class="line">            <span class="attribute">display</span>: block;</span><br><span class="line">            <span class="attribute">width</span>: (<span class="number">82rem</span>/<span class="variable">@basefont</span>);</span><br><span class="line">            <span class="attribute">height</span>: (<span class="number">82rem</span>/<span class="variable">@basefont</span>);</span><br><span class="line">            <span class="attribute">margin</span>: <span class="number">10px</span> auto <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="selector-tag">span</span> &#123;</span><br><span class="line">            <span class="attribute">font-size</span>: (<span class="number">25rem</span>/<span class="variable">@basefont</span>);</span><br><span class="line">            <span class="attribute">color</span>: <span class="number">#333</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>黑马面面布局开发</title>
    <url>/2021/03/18/%E6%A1%88%E4%BE%8B-%E9%BB%91%E9%A9%AC%E9%9D%A2%E9%9D%A2%E5%B8%83%E5%B1%80%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<p>实现黑马面面的布局开发，本次案例  flex + rem + + flexible.js +  LESS   </p>
<span id="more"></span>

<h3 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h3><h4 id="1-1-技术方案"><a href="#1-1-技术方案" class="headerlink" title="1.1  技术方案"></a>1.1  技术方案</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. 弹性盒子 + rem + LESS </span><br><span class="line"><span class="number">4</span>. 最小适配设备为iphone5 <span class="number">320px</span>  最大设配设备为iphone8plus(ipad能正常查看内容即可)</span><br></pre></td></tr></table></figure>

<h4 id="1-2-代码规范"><a href="#1-2-代码规范" class="headerlink" title="1.2 代码规范"></a>1.2 代码规范</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. 类名语义化,尽量精短、明确，必须以字母开头命名，且全部字母为小写，单词之间统一使用下划线“_” 连接</span><br><span class="line"><span class="number">2</span>. 类名嵌套层次尽量不超过三层</span><br><span class="line"><span class="number">3</span>. 尽量避免直接使用元素选择器</span><br><span class="line"><span class="number">4</span>. 属性书写顺序</span><br><span class="line">   布局定位属性：<span class="attribute">display</span> / <span class="attribute">position</span> / <span class="attribute">float</span> / <span class="attribute">clear</span> / <span class="attribute">visibility</span> / <span class="attribute">overflow</span></span><br><span class="line">   尺寸属性：<span class="attribute">width</span> / <span class="attribute">height</span> / <span class="attribute">margin</span> / <span class="attribute">padding</span> / <span class="attribute">border</span> / <span class="attribute">background</span></span><br><span class="line">   文本属性：<span class="attribute">color</span> / <span class="attribute">font</span> / <span class="attribute">text-decoration</span> / <span class="attribute">text-align</span> / <span class="attribute">vertical-align</span></span><br><span class="line">   其他属性（CSS3）：<span class="attribute">content</span> / <span class="attribute">cursor</span> / <span class="attribute">border-radius</span> / <span class="attribute">box-shadow</span> / <span class="attribute">text-shadow</span></span><br><span class="line"><span class="number">5</span>. 避免使用id选择器</span><br><span class="line"><span class="number">6</span>. 避免使用通配符*和!important</span><br></pre></td></tr></table></figure>

<h4 id="1-2-目录规范"><a href="#1-2-目录规范" class="headerlink" title="1.2 目录规范"></a>1.2 目录规范</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">项目文件夹：heimamm</span><br><span class="line">	样式文件夹：css</span><br><span class="line">	业务类图片文件夹：images</span><br><span class="line">	样式类图片文件夹： icons</span><br><span class="line">	字体类文件夹： fonts</span><br></pre></td></tr></table></figure>

<h3 id="二、流程开发"><a href="#二、流程开发" class="headerlink" title="二、流程开发"></a>二、流程开发</h3><h4 id="2-1-蓝湖-摹客协作平台"><a href="#2-1-蓝湖-摹客协作平台" class="headerlink" title="2.1 蓝湖/摹客协作平台"></a>2.1 蓝湖/摹客协作平台</h4><ul>
<li>UI设计师 psd效果图完成后，会上传到蓝湖//摹客里面，同时会拉前端工程师进入开发</li>
<li>大部分情况下，UI会把图片按照前端设计要求给切好</li>
<li>UI设计师 上传蓝湖到或者/摹客（了解）</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. /摹客官网地址： https://www.mockplus.cn/  注册一个账号</span><br><span class="line"><span class="number">2</span>. 下载moke  ps插件 </span><br><span class="line"><span class="number">3</span>. PS 安装/摹客/蓝湖插件</span><br><span class="line"><span class="number">3</span>. 打开PS/摹客/蓝湖插件</span><br><span class="line"><span class="number">4</span>. 上传（需要切图，需要先标注切图）</span><br><span class="line"><span class="number">5</span>. 查看项目</span><br><span class="line"><span class="number">6</span>. 邀请成员进入（分享按钮，链接地址）</span><br></pre></td></tr></table></figure>

<ul>
<li>前端设计师可以直接/摹客/蓝湖测量取值</li>
</ul>
<h4 id="2-2-适配方案"><a href="#2-2-适配方案" class="headerlink" title="2.2 适配方案"></a>2.2 适配方案</h4><ul>
<li>flex 布局  </li>
<li>百分比布局</li>
<li>rem布局</li>
<li>vw/vh布局</li>
<li>响应式布局</li>
<li>本次案例  flex + rem + + flexible.js +  LESS   </li>
</ul>
<h4 id="2-3-初始化文件"><a href="#2-3-初始化文件" class="headerlink" title="2.3  初始化文件"></a>2.3  初始化文件</h4><ul>
<li><p>引入  normalize.css</p>
</li>
<li><p>less 中 初始化body样式</p>
</li>
<li><p>约束范围</p>
</li>
<li><p>```css<br>@media screen and (min-width: 750px) {<br>  html {</p>
<pre><code>font-size: 37.5px !important;
</code></pre>
<p>  }<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### 2.4 布局模块</span><br><span class="line"></span><br><span class="line">1. 头部模块  .header    高度为 80px </span><br><span class="line"></span><br><span class="line">2. nav 模块制作  多用 flex</span><br><span class="line"></span><br><span class="line">3. 充电学习 阴影</span><br><span class="line"></span><br><span class="line">   &#96;&#96;&#96;css</span><br><span class="line">   box-shadow: 0 0px 10px rgba(0, 0, 0, 0.1)</span><br></pre></td></tr></table></figure>

<p> ​</p>
</li>
</ul>
<h4 id="2-5-swiper-插件使用"><a href="#2-5-swiper-插件使用" class="headerlink" title="2.5 swiper 插件使用"></a>2.5 swiper 插件使用</h4><p>可用于实现轮播图</p>
<p>官网地址：<a href="https://www.swiper.com.cn/">https://www.swiper.com.cn/</a></p>
<ul>
<li>下载需要的css和js文件  html页面中 引入相关文件</li>
<li>官网找到类似案例，复制html结构，css样式  js 语法</li>
<li>根据需求定制修改模块</li>
</ul>
<h4 id="2-6-图标字体上传下载"><a href="#2-6-图标字体上传下载" class="headerlink" title="2.6 图标字体上传下载"></a>2.6 图标字体上传下载</h4><p>上传步骤：</p>
<ol>
<li><p>让UI美工准备好 图标字体（必须是svg格式）</p>
</li>
<li><p>点上传按钮（保留颜色并提交）</p>
<p><img src="C:\Users\kandy\AppData\Local\Temp\1593317258207.png" alt="59331725820"></p>
</li>
<li><p>生成之后加入购物车即可</p>
</li>
<li><p>点击下载 — 下载代码</p>
</li>
</ol>
<p>小技巧：  如何批量下载全部字体图标呢？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> span = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;.icon-cover&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = span.length; i &lt; len; i++) &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(span[i].querySelector(<span class="string">&#x27;span&#x27;</span>).click());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-7-上传码云并发布部署静态网站"><a href="#2-7-上传码云并发布部署静态网站" class="headerlink" title="2.7  上传码云并发布部署静态网站"></a>2.7  上传码云并发布部署静态网站</h4><p>准备工作：  需要下载git软件    需要码云注册账号</p>
<p>git 可以把我们的本地网站提交上传到远程仓库（码云 gitee）里面    类似以前的   ftp  </p>
<p>码云  就是远程仓库， 类似服务器 </p>
<ol>
<li><p>码云创建新的仓库。   heimamm  </p>
</li>
<li><p>利用git 提交 把本地网站提交到 码云新建的仓库里面</p>
<ul>
<li><p>在网站根目录右键– Git Bash Here</p>
</li>
<li><p>如果是第一次利用git提交，请配置好全局选项</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">git config --<span class="built_in">global</span> user.name <span class="string">&quot;用户名&quot;</span></span><br><span class="line">git config --<span class="built_in">global</span> user.email <span class="string">&quot;你的邮箱地址&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>初始化仓库</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure></li>
<li><p>把本地文件放到暂存区</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure></li>
<li><p>把本地文件放到本地仓库里面</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">&#x27;提交黑马面面网站&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p>链接远程仓库</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">git remote add origin 你新建的仓库地址</span><br></pre></td></tr></table></figure></li>
<li><p>把本地仓库的文件推送到远程仓库 push</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>码云部署发布静态网站</p>
<ul>
<li>在当前仓库中，点击  “服务”   菜单 </li>
<li>选择 Gitee Pages</li>
<li>选择 “启动” 按钮</li>
<li>稍等之后，会拿到地址，就可以利用这个地址来预览网页了</li>
<li>当然你也可以利用  草料二维码 生成二维码    <a href="https://cli.im/">https://cli.im/</a></li>
</ul>
</li>
</ol>
<p>最后： 如果提交网站，你不愿意用git 提交， 可以直接找到仓库，里面有文件，选择上传本地文件即可。</p>
<p>但是，1个小时内，只能上传 20个以内的文件， 前端人员，git必备技能</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS移动端开发主要布局</title>
    <url>/2021/03/17/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91%E4%B8%BB%E8%A6%81%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<p>主要包括流式布局、flex布局、rem布局的内容</p>
<span id="more"></span>

<h2 id="移动端常见布局"><a href="#移动端常见布局" class="headerlink" title="移动端常见布局"></a>移动端常见布局</h2><h2 id="流式布局"><a href="#流式布局" class="headerlink" title="流式布局"></a>流式布局</h2><p>百分比布局，非固定像素布局</p>
<ul>
<li>通过盒子的宽度设置成百分比来根据屏幕伸缩</li>
<li>需要设定最大值最小值，防止影响内容显示max-width:  min-width</li>
</ul>
<h2 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h2><ul>
<li>传统布局兼容性好，但是布局繁琐，局限性高</li>
<li>伸缩布局=弹性布局=伸缩盒布局=弹性盒布局=flex布局</li>
<li>flex布局在PC端支持较差，移动端应用广泛</li>
<li>采用flex布局的元素称为flex容器，所有子元素自动成为容器成员，成为flex项目，简称项目</li>
</ul>
<h3 id="布局原理"><a href="#布局原理" class="headerlink" title="布局原理"></a>布局原理</h3><ul>
<li>任何一个容器都可以使用flex布局</li>
<li>父盒子设为flex布局后，子元素的float、clear、和vertical-align属性失效</li>
<li>原理：通过给父盒子添加flex属性，控制子盒子的位置和排列方式</li>
</ul>
<h3 id="flex父项常见属性"><a href="#flex父项常见属性" class="headerlink" title="flex父项常见属性"></a>flex父项常见属性</h3><ul>
<li>flex-direction:设置主轴的方向，默认是row，元素是跟着主轴排列的，设为column，则主轴变为y轴，实现从上到下排列</li>
<li>justify-content: 设置主轴上的子元素排列方式</li>
<li>flex-wrap:设置子元素是否换行</li>
<li>align-content:设置侧轴上子元素的排列方式（<strong>多行</strong>），只能用于出现换行的情况</li>
<li>align-items: 设置侧轴上的子元素排列方式（<strong>单行</strong>）</li>
<li>flex-flow: 复合属性，同时设置direction和wrap</li>
</ul>
<p>主轴是x轴方向，水平向右；侧轴是y轴方向，垂直向下</p>
<hr>
<p><strong>justify-content：</strong>一定要确定好主轴</p>
<ul>
<li>flex-start 靠左对齐</li>
<li>flex-end 靠右对齐</li>
<li>center: 子元素居中对齐</li>
<li>space-around：平分剩余空间(每个盒子都有左右边距)</li>
<li>space-between:先两边贴边再分配剩余空间</li>
</ul>
<p><strong>flex-wrap:</strong></p>
<p>默认不换行，当多个子盒子装不进去父盒子的时候，会强制放在一行，缩小子盒子</p>
<ul>
<li>warp：允许换行</li>
</ul>
<p><strong>align-items:</strong></p>
<ul>
<li>center:侧轴居中（侧轴为y时垂直居中）</li>
<li>flex-start: 贴着侧轴上沿</li>
<li>flex-end :贴着侧轴下沿</li>
<li>stretch ：拉伸，必须子盒子没有高度，会拉伸到和父盒子一样高（margin不影响）</li>
</ul>
<p><strong>align-contents:</strong></p>
<p>比items多space-around、space-between两个值，可以实现平分空间，在单行下没有效果</p>
<p>flex-flow:</p>
<p>是flex-direction和flex-wrap属性的复合属性</p>
<p><code>flex-flow: row wrap;</code></p>
<h3 id="flex子项常见属性"><a href="#flex子项常见属性" class="headerlink" title="flex子项常见属性"></a>flex子项常见属性</h3><ul>
<li>flex:定义子项目分配<strong>剩余空间</strong>，用flex表示子项目占的份数</li>
</ul>
<p>可用于布局两边固定盒子，中间盒子长度可随屏幕大小调整的情况（自适应）  //圣杯布局</p>
<ul>
<li>align-self:控制子项自己在侧轴上的排列方式</li>
</ul>
<p>允许某个项目有与其他项目不同的排列方式，可覆盖align-items属性，默认值为auto，相当于继承align-items属性，如果没有父元素则等同于stretch</p>
<ul>
<li>order：属性定义项目的排列顺序，移动的是左右排列，与z-index不同</li>
</ul>
<p>数值小的靠前排列</p>
<h2 id="rem布局"><a href="#rem布局" class="headerlink" title="rem布局"></a>rem布局</h2><h3 id="rem单位"><a href="#rem单位" class="headerlink" title="rem单位"></a>rem单位</h3><p>root em相对单位，em是父元素字体大小</p>
<p>rem是相对于html元素的字体大小</p>
<p>优点：可以通过修改html里面的文字大小来改变页面中元素的大小，可以整体控制</p>
<h3 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h3><p>媒体查询是CSS3新语法</p>
<ul>
<li>可以针对不同屏幕尺寸设置不同样式</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> mediatype <span class="keyword">and</span>|<span class="keyword">not</span>|<span class="keyword">only</span> (media feature)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>:<span class="number">500px</span>)&#123;</span><br><span class="line">    <span class="selector-tag">body</span>&#123;</span><br><span class="line">        <span class="attribute">background-color</span>:red</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>mediatype:媒体类型</strong></p>
<p>all：用于所有设备</p>
<p>print：用于打印机和打印预览</p>
<p>screen：用于电脑屏幕</p>
<p><strong>媒体特性</strong></p>
<p>width：定义</p>
<p>max-width:800 只有宽度小于800时，才执行下面样式</p>
<ul>
<li>screen还有and必须带上</li>
<li>必须带单位px</li>
<li>媒体查询+rem可以实现不同设备里尺寸动态变化，给html设定font-size，然后设置字体行高（rem单位）等随宽度变化</li>
</ul>
<p><strong>引入资源</strong></p>
<p>三星：大屏和小屏使用两个css文件，直接在link中判断设备的尺寸，然后引入不同的css文件</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;style320.css&quot; media=&quot;screen and (min-width:320px)&quot;</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;style640.css&quot; media=&quot;screen and (min-width:640px)&quot;</span><br></pre></td></tr></table></figure>

<h3 id="适配方案原理"><a href="#适配方案原理" class="headerlink" title="适配方案原理"></a>适配方案原理</h3><ol>
<li>让一些不能等比自适应的元素，达到当设备尺寸发生改变的时候，等比例适配当前设备</li>
<li>使用媒体查询根据不同设备按比例设置html字体大小，然后页面元素使用rem作为尺寸单位，当HTML字体大小变化元素尺寸也会变化，从而达到等比缩放的适配</li>
</ol>
<h4 id="技术方案1"><a href="#技术方案1" class="headerlink" title="技术方案1"></a><strong>技术方案1</strong></h4><p>less、媒体查询、rem</p>
<p>一般情况以一套或者两套效果图适应大部分屏幕，基本以750px宽度为准</p>
<p>假设设计稿是750px，把屏幕化为15等份（标准不一定是15），每一份作为html字体大小，这里为750/15=50px，那么在320px设备时，字体大小为320/15=21.33px，比例相同，本质是实现等比例缩放</p>
<ul>
<li><p>页面元素的rem值=页面元素值(px)/(屏幕宽度/划分份数)</p>
</li>
<li><p>屏幕宽度/划分份数就是HTML font-size的大小</p>
</li>
</ul>
<h4 id="技术方案2（更推荐）"><a href="#技术方案2（更推荐）" class="headerlink" title="技术方案2（更推荐）"></a><strong>技术方案2（更推荐）</strong></h4><p>flexible.js 、rem</p>
<p>两种方案都存在，方案2更简单</p>
<p>淘宝团队出品，在js里处理，不需要写不同屏幕的媒体查询，原理是将当前设备划分为10等份，我们只需要把html文字大小设置为75px，里面页面元素rem值=页面px值/75</p>
<p>插件：cssrem自动转换rem  在插件扩展设置里调整字体大小基准值为45</p>
<h2 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h2><p>###响应式开发原理</p>
<p>利用媒体查询针对不同宽度的设备进行布局和样式的设置，从而适配不同设备的目的</p>
<p>超小屏幕（手机）&lt;768  宽度设置为100%</p>
<p>小屏设备（平板）  &gt;=768~&lt;992  宽度设置为750</p>
<p>中等屏幕（桌面显示器）  &gt;=992~&lt;1200  宽度设置为970px</p>
<p>宽屏设备（大桌面显示器）&gt;1200  宽度设置为1170px</p>
<p>需要一个父级作为布局容器，在不同屏幕下，通过媒体查询改变这个布局容器排列方式和大小，从而实现不同屏幕下，看到不同的页面布局和样式</p>
<h2 id="Bootstrap"><a href="#Bootstrap" class="headerlink" title="Bootstrap"></a>Bootstrap</h2><p>基于HTML、CSS和JAVASCRIPT，使web开发更加快捷</p>
<p>版本3.xx放弃了IE6-7，偏向于开发响应式布局、移动设备优先的WEB项目</p>
<p>入门文档：<a href="https://bootstrap.css88.com/getting-started/#download">https://bootstrap.css88.com/getting-started/#download</a></p>
<ol>
<li>创建HTML骨架文件</li>
</ol>
<p>在head里meta后添加</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--[if lt IE 9]&gt;</span></span><br><span class="line"><span class="comment">      &lt;script src=&quot;https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="comment">      &lt;script src=&quot;https://oss.maxcdn.com/respond/1.4.2/respond.min.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="comment">    &lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>引入bootstrap样式文件</li>
<li>书写内容</li>
</ol>
<p>可以在原来的基础上更改，添加类名，要注意权重</p>
<h3 id="布局容器"><a href="#布局容器" class="headerlink" title="布局容器"></a>布局容器</h3><p>bootstrap使用container类定义好了响应式布局的容器大小；只需要div.container 内容写在里面即可；适合做响应式</p>
<p>container-fluid 类 流式布局容器；占据全部视口的容器，适合做单独的移动端页面</p>
<h3 id="栅格系统"><a href="#栅格系统" class="headerlink" title="栅格系统"></a>栅格系统</h3><p>说明 <a href="https://bootstrap.css88.com/css/#grid">https://bootstrap.css88.com/css/#grid</a></p>
<p>将<strong>页面布局</strong>划分成等宽的列</p>
<ul>
<li>不管屏幕有多宽，统一划分为12列（把container划分为12列</li>
</ul>
<p>例如类col-lg-3表示占3列（大桌面设备）</p>
<ul>
<li>如果孩子份数相加等于12，则孩子能占满整个container；小于12则会有空白；大于12则会换行</li>
</ul>
<p><img src="https://www.hualigs.cn/image/605374fe2a899.jpg"></p>
<p>col-md-4 表示中等屏幕下占4列</p>
<ul>
<li><p>可以多个类名同时，便于实现响应式</p>
</li>
<li><p>每一列默认有个15pxpadding值</p>
</li>
</ul>
<h3 id="列嵌套"><a href="#列嵌套" class="headerlink" title="列嵌套"></a>列嵌套</h3><p>为了使用内置的栅格将内容嵌套，通过添加一个新的<code>.row</code>和一系列<code>.col-md-*</code>列到已经存在的<code>.col-md-*</code>列内即可实现。嵌套row所包含的列加起来应该等于12。 </p>
<p>加row可以取消padding值并且和父亲一样高</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-sm-9&quot;</span>&gt;</span></span><br><span class="line">    Level 1: .col-sm-9</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-xs-8 col-sm-6&quot;</span>&gt;</span></span><br><span class="line">        Level 2: .col-xs-8 .col-sm-6</span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-xs-4 col-sm-6&quot;</span>&gt;</span></span><br><span class="line">        Level 2: .col-xs-4 .col-sm-6</span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="列偏移"><a href="#列偏移" class="headerlink" title="列偏移"></a>列偏移</h3><p>使用<code>.col-md-offset-*</code>可以将列偏移到右侧。这些class通过使用<code>*</code>选择器将所有列增加了列的左侧margin。例如，<code>.col-md-offset-4</code>将<code>.col-md-4</code>向右移动了4个列的宽度。 </p>
<p>可以计算实现右对齐、居中等</p>
<h3 id="列排序"><a href="#列排序" class="headerlink" title="列排序"></a>列排序</h3><p>通过使用<code>.col-md-push-*</code> 和 <code>.col-md-pull-*</code>就可以很容易的改变列的顺序。 </p>
<p><img src="https://www.hualigs.cn/image/6053792fd45c8.jpg"></p>
<h3 id="响应式工具"><a href="#响应式工具" class="headerlink" title="响应式工具"></a>响应式工具</h3><p><img src="https://www.hualigs.cn/image/605379d6b2351.jpg"></p>
<p>可以实现在不同屏幕下的显示(visible)或隐藏(hidden)</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>第一次创建博客附博客基本操作</title>
    <url>/2021/03/11/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>创建博客踩的最大的一个坑和写博客的基本操作</p>
<span id="more"></span>

<p>第一次创建博客，踩坑很多</p>
<p>最大的问题是分支命名问题，按照往常的教程在HEXO的配置文件的branch中写的是master，但是现在的github创建的默认分支名字应该是main了，以至于一直可以更新仓库但是博客内容不更新</p>
<p>参考文章：<a href="https://blog.csdn.net/Lu_xiuyuan/article/details/112056997">https://blog.csdn.net/Lu_xiuyuan/article/details/112056997</a></p>
<p><strong>创建新博客</strong></p>
<p>在建立仓库的文件夹下source/_post 文件夹是存放markdown文件的地方，我们只需要将需要更新的博客放进去，但是一般不推荐直接在这里创建md文件，因为不会自动生成日期格式</p>
<p><img src="https://www.hualigs.cn/image/6056fedc03b4e.jpg"></p>
<p><strong>创建文件</strong>：打开git bash，cd进入仓库根目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new &#39;文件名&#39;</span><br></pre></td></tr></table></figure>

<p><strong>生成博客并提交</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure>

<p>提交这里是有可能报错的，有时候疯狂443：time out 过段时间提交就好了–我也不懂</p>
<p>有时候还会报错OpenSSL SSL_read: Connection was reset, errno 10054</p>
<p>那就输入</p>
<p>git config http.sslVerify “false”</p>
<p>如果只想在<strong>本地查看</strong> 不想直接更新在博客上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo s --debug</span><br></pre></td></tr></table></figure>

<p>按提示进入给出的链接即可预览</p>
<ul>
<li>怎样设置博客的标签、目录和显示的内容(只显示一小段剩下的隐藏需要点开才能看）呢</li>
</ul>
<p>基于next主题的操作，其他主题可能有所不同</p>
<p><strong>设置标签目录：</strong></p>
<p><img src="https://www.hualigs.cn/image/60571ecd98651.jpg"></p>
<p>样式如图</p>
<p>tags和categories内容是可以自己定义的，支持中文</p>
<p><strong>显示隐藏内容</strong>：</p>
<p>在需要显示的内容后加以下语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--more--&gt;</span><br></pre></td></tr></table></figure>

<p><strong>编写博客</strong>：</p>
<p>使用markdown语法，很方便，具体操作百度一下</p>
<p><strong>插入图片的</strong>最方便方法：</p>
<p>使用图床<a href="https://www.hualigs.cn/">https://www.hualigs.cn/</a></p>
<p>需要的图片贴进去上传，将markdown代码复制贴过来</p>
<p>本地粘贴的图片直接上传后是不会显示的！具体实现上传本地图片比较复杂，于是乎我选择了图床</p>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-斐波那契非递归方法</title>
    <url>/2021/03/21/%E7%AE%97%E6%B3%95-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E9%9D%9E%E9%80%92%E5%BD%92%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>看到这道题上来就果断递归了……结果–超出时间限制了</p>
<p>想不到思路就去翻题解了，给出了一种动态规划的思路</p>
<span id="more"></span>

<p><img src="https://www.hualigs.cn/image/6056f8542b194.jpg"></p>
<p>递归是直接从表达式下手，不断执行函数，直到执行到终止条件即n=0或n=1；复杂度很高</p>
<p>动态规划则是完全相反的思路：我们已知了n=0和n=1时的值，那我们可以直到n=2，n=4，一直到n=输入，就是我们想要求得的值</p>
<p>有这个思路后代码实现就比较容易了，分别取两个值记录上一个值和上上个值，循环计算，直到计算到n，复杂度只有O(n)</p>
<p>同时还需要注意一个小细节：int是32位整型，当数字过大时必然会溢出，因此要对sum取模（题目要求1000000007 ）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">0</span>,b=<span class="number">1</span>,sum=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            sum=(a+b)%<span class="number">1000000007</span>;</span><br><span class="line">            a=b;</span><br><span class="line">            b=sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-链表中倒数第k个结点</title>
    <url>/2021/03/21/%E7%AE%97%E6%B3%95-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<p>求链表中倒数第k个结点，主要采用双指针法</p>
<span id="more"></span>

<p><img src="https://www.hualigs.cn/image/6056fac90e7ad.jpg"></p>
<p>双指针法核心思想：设置快慢指针，保持快的指针比慢的指针快k个结点，那么当快指针走到链表末尾的时候，慢的指针就会到达所需要的结点处</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">getKthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode* first=head,*second=head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            first=first-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(first-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            first=first-&gt;next;</span><br><span class="line">            second=second-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>双指针法还可以解决很多类似的链表问题：</p>
<p>###求链表中间位置元素</p>
<p>快指针一次走两步，慢指针一次走一步，那么慢指针就会永远保持在已经走过的链表的中间，当快指针走到头的时候，慢指针所在位置就是所需位置。当 n 为<strong>奇数</strong>时，slow 恰好<strong>指向中间结点</strong>，当 n 为 <strong>偶数</strong>时，slow 恰好<strong>指向中间两个结点的靠前一个</strong> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *p = head, *q = head;</span><br><span class="line">        <span class="keyword">while</span>(q != <span class="literal">nullptr</span> &amp;&amp; q-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            q = q-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="是否存在环"><a href="#是否存在环" class="headerlink" title="是否存在环"></a>是否存在环</h3><p>当一个链表存在环的时候，指针经过尾指针后还会继续走，在一个环内运动的两个不同速度的指针，必然会在某一时刻相遇</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *slow = head;</span><br><span class="line">        ListNode *fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                fast = fast-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="判断环的长度"><a href="#判断环的长度" class="headerlink" title="判断环的长度"></a>判断环的长度</h3><p>快慢指针相遇后，下一次相遇时慢指针走的次数就是环的长度了</p>
<p>参考文章：</p>
<p>作者：Time-Limit<br>链接：<a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/solution/yi-wen-gao-ding-chang-jian-de-lian-biao-wen-ti-h-3/">https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/solution/yi-wen-gao-ding-chang-jian-de-lian-biao-wen-ti-h-3/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络思维导图</title>
    <url>/2021/04/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>计算机组成原理框架和重点</title>
    <url>/2021/03/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E6%A1%86%E6%9E%B6%E5%92%8C%E9%87%8D%E7%82%B9/</url>
    <content><![CDATA[<h1 id="计算机系统概述"><a href="#计算机系统概述" class="headerlink" title="计算机系统概述"></a>计算机系统概述</h1><p><img src="https://www.hualigs.cn/image/605a9d3639c59.jpg"></p>
<p>冯诺依曼计算机特点：</p>
<ul>
<li>计算机由五大部件组成</li>
<li>指令和数据以<strong>同等地位</strong>存储</li>
<li>指令和数据用<strong>二进制</strong>表示</li>
<li>指令由<strong>操作码和地址码</strong>组成</li>
<li>存储程序</li>
<li>以运算器为中心</li>
</ul>
<span id="more"></span>

<p>软件和硬件的区别：</p>
<p>软件和硬件具有逻辑上的等效性，硬件实现具有更高的执行速度，软件实现具有更好的灵活性。执行频繁硬件实现代价不高的功能通常用硬件实现</p>
<h2 id="计算机系统层次结构"><a href="#计算机系统层次结构" class="headerlink" title="计算机系统层次结构"></a>计算机系统层次结构</h2><ol>
<li>完整的计算机系统应该包括配套的硬件设备和软件系统。</li>
</ol>
<p>只写运算器、存储器、控制器等是不完整的</p>
<ol start="2">
<li>冯诺依曼的基本工作方式是==控制流驱动方式==。</li>
<li>冯诺依曼计算机中指令和数据均以二进制形式存放在存储器中，CPU区分它们的依据是==指令周期的不同阶段==</li>
</ol>
<p>通常取指阶段取出的是指令，执行阶段取出的是数据</p>
<ol start="4">
<li>存放欲执行指令的寄存器是IR，存放下一条指令地址(跟踪下一条指令的地址）是PC</li>
<li>MAR、MDR的位数分别为地址码长度、存储字长</li>
<li>系列机的基本特性是指令向后兼容，即高版本可以执行低版本指令</li>
<li>计算机硬件能后直接执行的==只有==机器语言程序</li>
</ol>
<p>##计算机性能和指标</p>
<ol>
<li>汇编程序员可以通过指定待执行命令地址来设置PC的值，状态寄存器、通用寄存器使用汇编语言可见，而IR、MAR、MDR都是不透明的</li>
</ol>
<p>只有指令寄存器是完全透明的</p>
<ol start="2">
<li>时钟周期是计算机操作的最小单位时间</li>
<li>当前设计高性能计算机的重要技术途径是采用并行处理技术</li>
<li>评价计算机系统性能的综合参数是吞吐率</li>
<li>兼容指计算机软件或硬件的通用性，通常在同一系列不同型号的计算机间通用</li>
</ol>
<hr>
<p>#数据表示和运算</p>
<ol>
<li>国际通用的ASCII码是由7位二进制代码表示的，从0000000到1111111共128种编码，大写字母在英文字母前</li>
<li>数据的小端方案存储是指将最低有效字节存储在最小位置</li>
</ol>
<h2 id="定点数的表示和运算"><a href="#定点数的表示和运算" class="headerlink" title="定点数的表示和运算"></a>定点数的表示和运算</h2><ul>
<li><p>对0的处理：原码和反码有+0和-0，补码和移码只有一个0，补码的1000表示-7</p>
</li>
<li><p>原码表示的数据个数：2^n-1^-1个，补码能表示的最大负数是==-2^n-1^==</p>
</li>
<li><p>N位(不考虑符号位)2进制补码小数可以表示的数的个数为2^N^,N位十进制小数可以表示的数的个数为10^N^</p>
</li>
<li><p>==使用补码表示时，若符号位相同，则数值位越大码值越大==(正数补码是本身所以正数也成立，可以用于判断当补码需要满足某个范围时x的取值)</p>
</li>
<li><p><strong>模2补码和模4补码：</strong></p>
<p>​    模4补码具有模2补码的全部优点且更易检查加减运算中的溢出问题；存储模4补码仅需要一个符号位，因为任意一个正确的数值，模4补码的两个符号位总是相同的；只有在把两个模4补码的数送往ALU进行加减运算时，才把每个数的符号位的值同时送到ALU的双符号位中，即只在ALU中采取双符号位。</p>
</li>
<li><p><strong>溢出的三种判断方法</strong>：一位符号位(参加操作的两个数符号相同，结果与他们符号不同)、双符号位(某个数只有单符号位时可以直接将该位复制后进行判断，01正溢出10负溢出)、进位判断(符号位进位异或最高数位进位)</p>
</li>
<li><p><strong>乘除法：</strong>原码乘法符号位与数值位分开，最低位为1则加x后右移，最低位为0则加0后右移；补码乘法符号位则需要参与运算；原码除法单独计算符号位，补码除法一起计算</p>
</li>
<li><p>原码乘法移位和加法都是最多n次，补码一位乘法中，最多需要n次移位，n+1次加法</p>
</li>
<li><p>计算机中，通常用于表示主存地址的是无符号数</p>
</li>
<li><p><strong>逻辑移位和算术移位</strong>：逻辑移位左移和右移都补0，且所有数字移动；算术移位赌好玩不参加移位，右移补符号位，左移补0</p>
</li>
<li><p><strong>边界对齐</strong>：数据按边界对齐方式存储时，所有半字、字等占据的都是机器字长位数；如机器字长为32位时，则int占32位(一个机器字长);short定义的值会占据16位后，将剩下的16位填充，不用于写后面的数据，计算后面数据的地址是必须考虑到；</p>
</li>
</ul>
<h2 id="浮点数的表示与运算"><a href="#浮点数的表示与运算" class="headerlink" title="浮点数的表示与运算"></a>浮点数的表示与运算</h2><ul>
<li><p>浮点数表示中基数越大，范围越大，精度越低(变稀疏)；阶码越长范围越大；尾数越长精度越高</p>
</li>
<li><p>在浮点数编码表示中，==基数==在机器数中不出现是隐含的(一般是约定好的)</p>
</li>
<li><p>采用规格化浮点数最主要是为了增加数据的表示精度(规格化本质是使尾数最高位数是有效值)</p>
</li>
<li><p><strong>怎样判断数字是否规格化</strong></p>
<p>原码表示：0.1 1.1  尾数第一位为1  基数为2^n^时则尾数前n为必须有一个1  补码表示 0.1 1.0 尾数第一位与符号位相反  IEEE:   1.1 隐含1 尾数首位为1</p>
</li>
<li><p><strong>IEEE 754单精度浮点数格式</strong>：1数符+8移码+23尾数</p>
<p>该移码与一般的移码(补码符号位取反)有所不同，计算方式应该是原码+127；如3的移码为10000010</p>
</li>
<li><p><strong>IEEE 754最大值</strong>：尾数全取1时最大，此时尾数为1.1111111…小数点后23个1则可以表示为2-2^-23^,阶数为移码，最大为127,因此最大值为(2-2^-23^)*2^127^=2^128^-2^104^</p>
</li>
<li><p><strong>IEEE 754正数最小值</strong>：移码范围是1~254，阶码的值范围为-126到127,则最小的规格化正数为1.0*2^-126^</p>
</li>
<li><p>浮点运算中的上溢是指运算结果的==绝对值==大于机器所能表示的最大绝对值，下溢是结果绝对值小于最小绝对值</p>
</li>
<li><p><strong>对阶：</strong>小阶向大阶看齐，将阶码小的尾数右移，直到两个阶码相等，右移存在舍入问题</p>
</li>
<li><p><strong>移位</strong>：补码表示时，正数的符号位为0，左移最高位为0时数据不会丢失，负数符号位和左移最高位为1时数据不会丢失，即左移移走的最高位要与符号位相同；双符号位时，最高符号位代表真正的符号，低位符号用于参与移位操作以判断是否发生溢出，结果01表示结果正溢出，10表示结果负溢出</p>
</li>
<li><p><strong>舍入：</strong>只有浮点数需要考虑舍入的问题，定点数不需要；浮点数舍入的情况有两种：对阶和右规格化；舍入不一定产生误差，如11.000舍入到11.00没有误差  舍入包括0舍1入法和恒置1法。</p>
</li>
<li><p><strong>类型转换：</strong>double包容性最强，一般其他的转过去都不会有损失。float和int位数相同，但float包括阶数和尾数，表示的范围大但是精度低</p>
</li>
<li><p><strong>为什么要用移码表示阶码？</strong></p>
</li>
</ul>
<ol>
<li>浮点数进行加减运算经常需要比较阶码的大小，使用移码比较大小很方便</li>
<li>检验移码的特殊值容易，移码的特殊值分别是全0和全1，全0表示阶码为负无穷，相当于分母无穷大，整个数无限接近0，若尾数也为0则可以表示0；全1表示指数正无穷大，若尾数为0表示正负无穷，尾数不为0则表示运算错误</li>
</ol>
<h1 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a>存储系统</h1><p>计算机有多级存储系统：</p>
<p>CPU</p>
<hr>
<p>寄存器</p>
<p>Cache  </p>
<p>主存</p>
<p>磁盘</p>
<p>磁带  光盘</p>
<hr>
<p>Cache-主存 解决CPU与主存数据不匹配的问题</p>
<p>主存-辅存  解决存储系统的容量问题，形成了虚拟存储系统</p>
<p>主要思想是上一级存储器作为低一层存储器的高速缓存</p>
<p>##存储器</p>
<ul>
<li><p>存储器按存取方式分类可以分为**顺序存储(磁带)、直接存储(磁盘、光盘)、随机存储;**直接存储器既不像RAM那样随机的访问任何一个存储单元，又不像顺序存储那样完全按顺序存储，介于两者之间</p>
</li>
<li><p>注意单位换算 1MB=1024KB=2^10^ KB=2^20^B 如： 机器字长=64位=8B  按字编址=8B一个存储单元</p>
</li>
<li><p><strong>怎样计算RAM芯片的引脚数目？</strong></p>
<p>例：芯片容量为1024*8位，则芯片容量为1024B，且以字节为单位进行存取，所以需要10根地址线(1024B=2^10^B), 8位说明数据线需要8根，加上片选线1根和读写控制线2根，一共需要21根</p>
<p>注意：读写控制线有时只需要一根，需要看题目说明</p>
</li>
<li><p>RAM和ROM：</p>
<p>RAM是随机存储器；具有易失性；包括SRAM(触发器、不需要刷新、Cache)、DRAM(电容、刷新、主存)</p>
<p>ROM是只读存储器；具有非易失性；MROM、PROM、EPROM、Flash(U盘)、SSD固态硬盘</p>
<p>都采用随机存取的方式进行信息访问</p>
</li>
</ul>
<h2 id="主存储器与CPU连接"><a href="#主存储器与CPU连接" class="headerlink" title="主存储器与CPU连接"></a>主存储器与CPU连接</h2><ul>
<li>地址分配：</li>
</ul>
<p>例：用若干2k×4位的芯片组成一个8k×8位的存储器，地址如何划分？0B1FH所在芯片最小地址为？</p>
<p>每行两个芯片，每列4个芯片，地址分配如下：</p>
<p>第一行：0000H~07FFH</p>
<p>第二行：0800H~0FFFH</p>
<p>第三行：1000H~17FFH</p>
<p>第四行：1800H~1FFFH</p>
<p>0B1FH在第二行，最小地址为0800H</p>
<ul>
<li>MAR位数：只与主存储器容量有关，如64MB=2^26^B, MAR位数即为26，与主存实际大小无关(可能会拓展)</li>
<li>确定地址线实例</li>
</ul>
<p><img src="https://www.hualigs.cn/image/605df8c321686.jpg"></p>
<ul>
<li><p>设计DRAM芯片：</p>
<p>保证地址引脚数最少：采用行列地址线复用的方式，32*64只需要6根地址线</p>
<p>减少刷新开销：减小行数</p>
</li>
</ul>
<h2 id="双端口RAM和多模块存储器"><a href="#双端口RAM和多模块存储器" class="headerlink" title="双端口RAM和多模块存储器"></a>双端口RAM和多模块存储器</h2><ul>
<li><p>四位：四个存储器  高位交叉：顺序方式，一个存储器一个存储器排序  低位交叉：交叉方式，轮流编号</p>
</li>
<li><p><strong>例题：</strong>四位低位交叉存储器  ①读取6个连续地址单元中存放的存储字，重复80次②读取8个连续地址单元中存放的存储字，重复60次  其中①②所花费的时间之比为4:3</p>
<blockquote>
<p>情况②中第一轮可以按顺序读取完6个字，花费时间为3/2 T,但是重复第二次的时候，第一次的最后一次读取使用了M1还处于占用状态，必须等待1/2 T的时间，即共2T时间进入下一轮</p>
<p>情况②直接依次读完8个字并继续下一轮，不存在等待情况，每轮仍然需要2T时间</p>
<p>因此花费时间之比=80:60=4:3</p>
</blockquote>
</li>
<li><p><strong>例题：</strong>某计算机主存按字节编址, 由4个64M*8位的DRAM芯片采用交叉编址方式构成，并与宽度为32位的存储器总线相连，主存每次最多读写32位数据。若double型变量x的主存地址为804001AH，则读取x需要的存储周期数是()</p>
<blockquote>
<p>double型：64位  4个DRAM：一个存储周期可以读4个字节的数据  地址为804001A，末两位为10，说明从编号为2的芯片开始存储，因此需要3个存储周期</p>
<p>总线是32位，则每次连续读出32位数据，第一次实质上读出是模块2模块3的数据 第二次是0123 第三次是01 才能读出所有数据，共3次周期</p>
</blockquote>
</li>
</ul>
<h2 id="高速缓冲存储器"><a href="#高速缓冲存储器" class="headerlink" title="高速缓冲存储器"></a>高速缓冲存储器</h2><p>这一章看似不难理解，实际做题很需要细节，对地址的各位理解也要求较高；</p>
<ul>
<li><p>主存块和cache的块必须大小相同，有时候题目不会告诉cach块的大小。</p>
</li>
<li><p>直接映射的地址结构为：标记+行号+块内地址</p>
</li>
<li><p><strong>例题：直接映射</strong></p>
</li>
<li><p>某 32 位计算机的 cache 容量为 16KB，cache 块的大小为 16B，若主存与 cache 的地址映射采用直接映射方式，则主存地址为 1234E8F8（十六进制）的单元装入的 cache 地址为C。</p>
<p>A. 00 0100 0100 1101 (二进制)<br>B. 01 0010 0011 0100 (二进制)<br>C. 10 1000 1111 1000 (二进制)<br>D. 11 0100 1110 1000 (二进制)</p>
<blockquote>
<p>解：Cache大小为16KB，块大小为16B，所以Cache被分成16KB/16B=1024块，因210＝1024故需要10位来表示块数。</p>
<p>24＝16故块内地址需要4位来表示。所以Cache的地址线位置为14位。</p>
<p>由于采用直接映像的方式，所以==主存的后14位就是要装入的到Cache中的位置==。故选 C.</p>
</blockquote>
</li>
<li><p><strong>例题：直接映射读数据</strong></p>
</li>
<li><p>有如下C语言程序段： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(int k &#x3D; 0; k &lt; 1000; k++)</span><br><span class="line">&#123;</span><br><span class="line">    a[k] &#x3D; a[k]+32;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若数组a以及变量k均为int型，int型数据占4B，数据Cache采用直接映射 方式，数据区大小是1KB，块大小是16B，该程序段执行前Cache为空，则该程序段执行过程中，访问数组a的Cache的缺失率是：C <br>A. 1.25% <br>B. 2.5% <br>C. 12.5% <br>D. 25%</p>
<blockquote>
<p>首先读取a[k]需要访问一次a[k],之后将结果复制给a[k]需要访问一次，共访问两次</p>
<p>本题中一个数据占4B，一个块大小是16B，这说明一个块中有4个数据;</p>
<p>主存和块之间==按块==传数据，所以第一次读a[0]没找到，去主存中调数据时，实际是一次调了一个块的数据（4个int，即a[0]到a[3]）进cache。所以后面读写a[1]到a[3]时都已经在cache中了，算命中了 </p>
<p>因此前8次读顺序可以理解为读0 读0 读1 读1 读2 读2 读3 读3 ，读0的时候就将0.1.2.3的数据全部放入了cache，第一次无法命中，后续的7个操作全部命中，缺失率为1/8=12.5%</p>
</blockquote>
</li>
<li><p>全相联映射的地址结构：标记+块内地址  存储数据是以块为单位的，因此同一标记的内容会被一次读入到同一块中；后续访问这一标记的其他内容也视为命中</p>
</li>
<li><p>组相联映射的地址结构为：标记+组号+块内地址；标记一般是内存块号的前k位，k由地址总位数和后两部分所占位数决定；主存地址由三部分组成，存储对应的Cache块信息，而Cache存储的是标记+数据，标记用于判断命中。</p>
</li>
<li><p><strong>例题：相联映射</strong></p>
</li>
<li><p>某计算机的Cache共有16块，采用2路组相联映射方式(即每组2块)。每个主存块大小为32字节，按字节编址。主存129号单元所在主存块应装入到的Cache组号是( )。 </p>
<blockquote>
<p>解答：组相联映射方式下，主存块按模Q(Q为Cache组数)映射到Cache对应组中的任一块；</p>
<p>Cache共有16块，采用2路组相联映射，故Cache共分16/2=8组；</p>
<p>主存块大小为32字节，按字节编址，故主存129号单元所在主存块为第129/32=4块；</p>
<p>4 Mod 8=4，故129号单元所在主存块应装入Cache第4组中任一块。 </p>
</blockquote>
<p>注意题目中129是单元数，不是块数</p>
</li>
<li><p><strong>例题：相联映射</strong></p>
</li>
<li><p>有效容量为128KB的Cache，每块16B，采用8位组相联，字节地址为1234567H的单元调入该Cache，则其tag为()</p>
<blockquote>
<p>128KB每块16B，则共有2^13^块，采用8位组相联，则有2^10^组，因此组号为10位；</p>
<p>每块大小为16B，块内地址需要4位来表示；</p>
<p>1234567H共28位，则其中后14位是组号+块内地址，前14位为标记字段即0001 0010 0011 01 -&gt;048DH</p>
</blockquote>
</li>
<li><p>替换是以块为单位的，当映射到同一组，但是标记不同的时候，如果组满才需要替换，即将组中某一块取出，若未满直接插入</p>
</li>
<li><p>Cache容量计算</p>
</li>
</ul>
<p><img src="https://www.hualigs.cn/image/605ef6f2d35c4.jpg"></p>
<ul>
<li>对于由高速缓存、主存、硬盘构成的三级存储体系，CPU访问该存储系统时发送的地址为主存物理地址</li>
<li>采用指令Cache和数据Cache分离的主要目的是减少指令流水线资源冲突(取指和取数可以分别到不同的cache中寻找)</li>
</ul>
<h2 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h2><ul>
<li>虚拟存储系统利用的是局部性原理</li>
<li>在虚拟存储器中，当程序正在执行时，由操作系统完成地址映射，但也需要一部分硬件基础的支持</li>
<li>页式虚拟存储器中，页面过小会导致虚拟存储器包含页面数过多，页表体积过大，操作变慢；页面很大时没页面数减少，页面调度频率较高，换页次数增加，降低操作速度</li>
<li>快表采用的是<strong>相联存储器</strong>，按照查找内容访问，查找速度比慢表快；快表是单独的存储器，而慢表存储在主存中</li>
<li>取数：先访问cache，没有再访问快表，没有再访问慢表，最少访问主存0次；写回时如果采用直写方式，则必须访问ache和主存，访问主存次数最少为1</li>
<li>在请求分页系统中，当要访问的页面不在内存中时，CPU检测到异常变回产生<strong>缺页中断</strong>，请求<strong>操作系统</strong>将缺页调入内存。缺页中断处理程序会根据缺页故障的地址从外存读入缺失的页，完成后<strong>回到发生缺页的指令</strong>继续执行</li>
</ul>
<h1 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h1><p>##基本框架</p>
<p><img src="https://www.hualigs.cn/image/60601fd0007b0.jpg"></p>
<ul>
<li><p>堆栈计算机中，有些堆栈零地址的运算类指令在指令格式中不给出操作数的地址，参加的两个操作数来自堆栈的栈顶和次栈顶单元。</p>
<blockquote>
<p>堆栈指令的访存次数取决于采用的是硬堆栈(由寄存器实现，只需要取指时访问一次内存)还是软堆栈(由内存实现，需要访问四次内存，取指、取数1、取数2、存结果)</p>
</blockquote>
</li>
<li><p>指令的基本格式：操作码+地址码</p>
</li>
<li><p>例题：扩展操作码</p>
</li>
<li><p>一个计算机系统采用32条单字长指令，地址码为12位，若定义了250条二地址指令，则还可以有()条单地址指令</p>
<p>二地址指令=两个地址码，每个地址码12位，那么操作码占了32-12-12=8位；</p>
<p>250条二地址指令，则8位操作码共256个码剩余了6个；</p>
<p>若要变为单地址指令，则最多可以将操作码拓展12位，可以有6*2^12^=24K条单地址指令</p>
</li>
<li><p>特权指令通常用于实现系统软件，这类指令一般不提供给用户</p>
</li>
</ul>
<hr>
<p>##不同字长的区别</p>
<p><strong>机器字长：</strong>CPU一次能够处理的数据的位数。通常等于寄存器的位数。例子：windows 64位/32位，这里的64位和32位指的就是该操作系统的机器字长。</p>
<p><strong>存储字长</strong>：计算机存储器中一个存储单元可以存储的位数。例子：某某计算机按照字节编址，即说明该计算机的存储字长为1B=8位。</p>
<p><strong>指令字长</strong>：计算机内一条指令的位数。这里通常指的定长指令。</p>
<p>机器字长与存储字长：两者没有必然的联系</p>
<p>机器字长与指令字长：两者没有必然的联系。它既可以等于机器字长也可以大于或者小于机器字长。通常把等于机器字长的指令称为单字长指令。把等于半个机器字长的指令称为半字长指令。把等于两倍机器字长的指令称为双字长指令。</p>
<p>存储字长和指令字长。各位可能经常看到这样的字眼：某某计算机按字节编址，指令长度为16位/32位。通常为了方便取址<strong>规定指令字长为存储字长的整数倍</strong>。现在的计算机指令长度基本都是存储字长的整数倍。</p>
<hr>
<h2 id="指令的寻址方式"><a href="#指令的寻址方式" class="headerlink" title="指令的寻址方式"></a>指令的寻址方式</h2><ul>
<li><p>内存地址是无符号数，而相对偏移量可以有正负</p>
</li>
<li><p>不同寻址方式特点：简化地址结构可以选择隐地址(不占位置),缩短指令地址段位数可以用寄存器寻址(寄存器一共就那么多~几个位就表示了);最快速获取操作数选择立即寻址;处理数组选择变址寻址;多道程序设计中最重要的寻址方式是相对寻址(同时多个程序按一定顺序轮流执行，相对方便程序浮动)</p>
</li>
<li><p>相对寻址是以<strong>下条</strong>指令在内存中首地址为基准的偏移量</p>
</li>
<li><p>采用相对寻址进行转移指令的时候，要注意程序计数器数值的变化，根据题意取指令时PC会增加，增加的位数要考虑机器字长。(<strong>每当取出1字节时PC的值+1，要看指令是多少字节</strong>)</p>
</li>
<li><p>程序计数器(PC)给出下一条指令字的访存地址，长度取决于存储器的字数；指令寄存器(IR)用于接收取得的指令，长度取决于指令字长</p>
</li>
<li><p>基址寻址和变址寻址具体寻址操作：找到变址/基址寄存器内容和形式地址内容，相加，得到操作数的实际地址，再根据实际地址访问内存，获取操作数；基址寻址中程序员操作的是偏移地址，基址寄存器内容由操作系统控制；变址寻址中，程序员操作的是变址寄存器，偏移地址是固定不变的</p>
</li>
<li><p>注意区分题目中的寄存器间接寻址和一般的间接寻址，寄存器间接寻址不考虑嵌套，寄存器中存储的就是有效地址，间接寻址需要考虑首位，如果是1则是继续向下寻找</p>
</li>
<li><p><strong>堆栈寻址进出操作：</strong>进、出堆栈对栈顶指针的操作顺序相反，进栈先压数据再改指针，使指针指向栈顶空单元；出栈先改指针再出数据，因为指针要先指向数据才能把它推出去；</p>
</li>
</ul>
<h1 id="中央处理器"><a href="#中央处理器" class="headerlink" title="中央处理器"></a>中央处理器</h1><p>##CPU功能和基本结构</p>
<ul>
<li><p><strong>程序计数器：</strong>内容为指令在主存中的地址，所以程序计数器的位数与存储器地址的位数相等，而存储器地址取决于存储器的容量，因此程序计数器的位数取决于存储器的容量;其中存储的地址可能是本条指令的地址，也可能是下条指令，具体取决于是取指令前还是取指令后</p>
<blockquote>
<p>例：某计算机的主存空间为4GB，字长为32位，按字节编址，采用32位字长指令字格式。若指令按字边界对齐存放，内存的字数=4GB*8/32=2^30^，则程序计数器的位数=30；指令寄存器IR的位数取决于指令长度为32</p>
</blockquote>
</li>
<li><p><strong>指令译码</strong>是对指令的操作码字段进行译码</p>
</li>
<li><p>间址周期结束时，CPU内寄存器MDR中的内容为操作数地址。间址周期的作用是取操作数的有效地址，因此间址周期结束后，MDR中的内容为操作数的地址</p>
</li>
<li><p>溢出标志位根据溢出的三种判断方法来看，进位/借位标志位 如果是减法直接比较两个数大小即可判断，加法判断是否进位</p>
</li>
<li><p>计算机可以划分为控制部件和执行部件：控制部件包括指令寄存器、程序寄存器、操作寄存器；执行部件包括运算器、存储器、外围设备</p>
</li>
</ul>
<h2 id="指令执行过程"><a href="#指令执行过程" class="headerlink" title="指令执行过程"></a>指令执行过程</h2><ul>
<li>取指操作是控制器自动进行的，不需要得到相应指令，是所有指令周期的第一步</li>
<li>指令执行方案包括单指令周期、多指令周期、流水线方案</li>
<li>执行各条指令的机器周期数、各机器周期的长度都应该是可变的</li>
</ul>
<p>##不同周期的区分</p>
<p>时钟周期：机器节拍，主频的倒数 </p>
<p>CPU周期：同机器周期</p>
<p>机器周期：完成一个基本操作所需时间，基本操作包括：取值、间址、执行、中断等。==通常使用存取周期来确定机器周期，就是说可以认为机器周期等于存取周期==</p>
<p>指令周期：从主存中取出并执行一条指令所需完整时间； 指令周期划分为四个阶段：取址周期、间址周期、执行周期、中断周期。 </p>
<p>存取周期：存储器进行两次独立存储器操作所需最小的时间间隔。 </p>
<hr>
<h2 id="控制器的功能和工作原理"><a href="#控制器的功能和工作原理" class="headerlink" title="控制器的功能和工作原理"></a>控制器的功能和工作原理</h2><p><img src="https://www.hualigs.cn/image/606076e7e826d.jpg"></p>
<ul>
<li><p>每条微指令存放在控制器的一个控制存储器单元中，控制存储器由ROM构成，在CPU中，只需要读操作不需要写</p>
</li>
<li><p>微程序&gt;微指令&gt;微命令&gt;微操作</p>
<p>一条指令的功能由一段微程序实现；</p>
<p>微指令包含操作控制字段(微操作码)、顺序控制字段(微地址码)(存放<strong>下一条</strong>要执行的微指令地址);</p>
<p>微命令是控制部件向执行部件发出的各种控制命令，是构成控制序列的最小单位</p>
<p>微操作是计算机最基本的、不可再分解的操作</p>
</li>
<li><p><strong>微程序控制器基本组成</strong>：控制存储器、微指令寄存器、微地址形成部件、微地址寄存器</p>
</li>
<li><p><strong>微指令格式：</strong>水平型微指令(并行)、垂直型微指令、混合型</p>
</li>
<li><p><strong>微指令编码方式</strong>：直接编码(一个指令一位二进制)、字段直接编码(互斥命令组合在同一字段中，相容性微命令组合在不同字段中，每个字段独立编码，每个小段留出一个状态)、字段间接编码方式</p>
</li>
<li><p><strong>微指令地址形成方式：</strong>断定方式(微指令的下地址字段指出)、根据机器指令操作码形成</p>
</li>
<li><p><strong>硬布线和微程序控制器对比</strong></p>
</li>
</ul>
<p><img src="https://www.hualigs.cn/image/60609d767effd.jpg"></p>
<h2 id="指令流水线"><a href="#指令流水线" class="headerlink" title="指令流水线"></a>指令流水线</h2><ul>
<li><p>流水CPU是一种非常经济而实用的<strong>时间</strong>并行技术</p>
</li>
<li><p>题目中问的存在数据冒险的指令对是xx和xx，意思是这两个指令冲突–，不要理解成这两个指令和前面的冲突了</p>
</li>
<li><p>指令流水线数据通路包括程序计数器、算术逻辑运算部件、通用寄存器组、取指部件等，不包括控制部件</p>
</li>
<li><p>流水线冲突：对流水线影响最严重的是数据相关</p>
<p>资源冲突：同一时刻争抢同一资源  ①后指令暂停 ②设置不同存储器</p>
<p>数据冲突：下一条指令使用上一条结果 ①暂停，硬件阻塞和软件插入 ②数据旁路技术  ③编译器优化调整顺序</p>
<p>控制冲突：转移、调用、返回时冲突  ①分支预测②预测转移成功与不成功指令</p>
</li>
<li><p>超标量流水线：</p>
<p>超标量流水线技术：同一阶段并行执行多条指令；要求配置多个功能部件和指令译码电路</p>
<p>超流水线技术：每个周期分段，一个周期内每个部件使用多次；对cache容量要求更大，需要执行的指令长度很长</p>
<p>超长指令字：将多条能并行操作的指令组合成一条具有多个操作码字段的超长指令字</p>
</li>
<li><p>流水线按序流动，不会出现WAR、WAW，只有可能出现RAW相关</p>
</li>
<li><p>CPU时钟周期应该根据指令各功能部件执行的最大时间决定</p>
</li>
<li><p><strong>CPI</strong>表示执行指令所需的时钟周期数，对于一个程序或一套机器来说，其CPI是执行该程序或机器指令集中所有指令所需的平均时钟周期数。对于单周期CPU，指令周期=时钟周期，CPI=1；对于多周期CPU，CPU的执行分为几个阶段，每个阶段用一个时钟完成，每种指令所用的时钟数可以不同，CPI&gt;1；对于基本流水线CPU，让每个时钟周期流出一条指令，CPI=1；超标量流水线CPU，每个周期并发执行多条独立指令，CPI&lt;1</p>
</li>
</ul>
]]></content>
      <categories>
        <category>408</category>
      </categories>
      <tags>
        <tag>计组</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法全书易错分析(超详细)</title>
    <url>/2021/03/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%98%93%E9%94%99%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="1-绪论"><a href="#1-绪论" class="headerlink" title="1 绪论"></a>1 绪论</h1><ol>
<li>数据结构三要素：数据的逻辑结构，数据的存储结构，数据的运算</li>
<li>逻辑结构包括线性结构和非线性结构（集合、树形、图状）</li>
<li>存储结构也称物理结构，包括顺序存储，链式存储，索引存储和散列存储</li>
<li>数据的运算包括运算的定义和实现，定义是针对逻辑结构，实现是针对存储结构 </li>
</ol>
<span id="more"></span>

<h1 id="2-线性表"><a href="#2-线性表" class="headerlink" title="2 线性表"></a>2 线性表</h1><ol>
<li>顺序存储方式不仅仅可以用于存储线性结构，还可以用于存储图和树等</li>
<li>在对链表进行第i个元素的增删改除时，需要考虑的不仅仅是o(1)复杂度的增删改除，还有O(n)复杂度的查找</li>
<li>给定有n个元素的一维数组，建立一个有序单链表的最低时间复杂度是O(nlogn), 直接按顺序插入需要每次遍历一遍链表，复杂度为O(n²)；若先将数组排序（复杂度最好为O(logn)), 再建立链表(O(n)),总复杂度为O(nlogn);</li>
<li>头结点所在的结点不存储内容，不属于链表长度</li>
</ol>
<h1 id="3-栈和队列"><a href="#3-栈和队列" class="headerlink" title="3 栈和队列"></a>3 栈和队列</h1><p>##栈</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define MaxSize 50</span><br><span class="line">typedef struct&#123;</span><br><span class="line">    Elemtype data[MaxSize];</span><br><span class="line">    int top;</span><br><span class="line">&#125; SqStack;</span><br></pre></td></tr></table></figure>

<p>栈空条件： S.top==-1;  </p>
<p>栈满：S.top=MaxSize-1;</p>
<p>##<strong>队列</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define MaxSize 50</span><br><span class="line">typedef struct&#123;</span><br><span class="line">    ElemType data[MaxSize];</span><br><span class="line">    int front,rear;</span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure>

<p>队空：Q.front==Q.rear==0</p>
<ul>
<li><p>链式队列的实现：注意要实现对头、尾结点的快速操作</p>
</li>
<li><p>单链表实现队列时，队头设在链表的链头位置，便于删除队头元素</p>
</li>
<li><p>队列用链式存储时，删除元素从表头删除，通常需要修改头指针，但若队列仅有一个元素，则尾指针也需要被修改，当仅有一个元素时，删除后队列为空，则头、尾指针都需要修改，使rear=front</p>
</li>
<li><p>链队列入队时需要执行：尾指针的next指向新元素，新元素的next指向空，尾指向新元素</p>
</li>
</ul>
<p>##<strong>循环队列：</strong></p>
<p>队空：Q.front=Q.rear</p>
<p>入队：rear=(rear+1) mod maxSize(注意maxSize大小，可能有坑)，不会改变front指针</p>
<p><strong>队满如何判断？</strong></p>
<ol>
<li>牺牲一个单元来区分队空和队满  队满条件：(Q.rear+1)%MaxSize==Q.front</li>
<li>类型中增设表示元素个数的数据成员。这样Q.size==0为队空Q.size=MaxSize为满</li>
<li>类型中增设tag数据成员，以区分是队满还是队空。tag=0时，若因删除导致Q.front=Q.rear ,则为队空；tag等于1时，若因插入导致Q.front==Q.rear则队满</li>
</ol>
<h2 id="栈和队列的应用"><a href="#栈和队列的应用" class="headerlink" title="栈和队列的应用"></a>栈和队列的应用</h2><p>栈的应用包括：递归、进制转换、括号匹配、表达式求值</p>
<p>队列的应用包括：树的层次遍历、计算机缓冲区，页面替换算法（FIFO），广度优先搜索</p>
<ul>
<li>适用于压缩存储稀疏矩阵的两种存储结构是：邻接矩阵和十字链表</li>
</ul>
<h1 id="4-串"><a href="#4-串" class="headerlink" title="4 串"></a>4 串</h1><p>–</p>
<h1 id="5-树"><a href="#5-树" class="headerlink" title="5 树"></a>5 树</h1><h2 id="树的基本概念"><a href="#树的基本概念" class="headerlink" title="树的基本概念"></a>树的基本概念</h2><p>树中一个节点的孩子个数称为该节点的度，节点的最大度数为树的度</p>
<ul>
<li>树的节点数等于所有节点的度数之和+1</li>
<li>度为m的树第i层最多有m^(i-1)个节点</li>
<li>高度为h的m叉树至多有(m^h-1)/(m-1)个节点</li>
<li>具有n个结点的m叉树的最小高度为logm(n(m-1))+1</li>
<li>树的路径长度是从树根到每个结点的路径长度的总和</li>
</ul>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>二叉树可以为空，仅有一个子节点时也需要区分左右</p>
<p>满二叉树：每层含有最多的结点</p>
<p>完全二叉树：可能存在一部分倒数第二层的结点为叶子结点，只能有一个度为1的结点，其只能有左孩子</p>
<ul>
<li>非空二叉树的叶子结点数等于度为2的结点数+1</li>
<li>结点i的左孩子为2i,右孩子为2i+1</li>
</ul>
<h2 id="二叉树的遍历和线索二叉树"><a href="#二叉树的遍历和线索二叉树" class="headerlink" title="二叉树的遍历和线索二叉树"></a>二叉树的遍历和线索二叉树</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">二叉树的遍历：先序、中序、后序、层序</span><br><span class="line">线索二叉树：若无左子树，令lchild指向其前驱结点；若无右子树，则令rchild指向后继结点</span><br></pre></td></tr></table></figure>

<ul>
<li>使用后序遍历可以找到到某祖先的路径</li>
<li>二叉树是一种逻辑结构，但线索二叉树是加上线索后的链表结果，是二叉树在计算机内部的一种存储结构，是物理结构</li>
<li>后序线索二叉树不能有效解决求后序后继的问题，仅用指针无法实现遍历，需要栈的支持</li>
</ul>
<h2 id="树、森林"><a href="#树、森林" class="headerlink" title="树、森林"></a>树、森林</h2><ul>
<li>森林与树转化成二叉树时有所不同，森林存在第二颗树时，二叉链表的根结点的右指针指向的是森林中第二棵树的根结点</li>
<li>森林转化成二叉树时，原来的叶子结点还是叶子结点，除此之外，最后一棵树在不断称为前一个树的子树的时候，根结点变成了叶子结点，因此会<strong>增加一个</strong>右指针域为空的结点；而森林叶子结点的个数<strong>等于</strong>二叉树中左孩子指针域为空的结点个数</li>
<li>树转化为二叉树，先根序列等于先序遍历；后根序列变为二叉树中序序列</li>
<li>树转化为二叉树，若某节点转化为右孩子，那么它在树种一定有左兄弟</li>
<li>森林的先根遍历序列对应于其二叉树的先序遍历序列；中根遍历序列对应其二叉树的中序遍历序列，后序遍历也对应</li>
</ul>
<h2 id="树和二叉树的应用"><a href="#树和二叉树的应用" class="headerlink" title="树和二叉树的应用"></a>树和二叉树的应用</h2><p>本章是难点，主要包括二叉排序树、平衡二叉树、哈夫曼树和哈夫曼编码</p>
<h3 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h3><p>二叉排序树主要特性：左子树节点&lt;根节点&lt;右子树结点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 查找：递归算法，判断，小于结点值查找左子树，大于查找右子树</span><br><span class="line">- 插入：递归算法；空则直接插入，小于结点插入左子树，大于插入右子树</span><br><span class="line">- 构造：依次对每个值插入到树中</span><br><span class="line">- 删除：叶结点直接删；只有左右其中一颗子树则删除后让其继承；左右都有则令直接后继（中序遍历第一个子女）替代</span><br><span class="line">- 查找效率：平衡二叉树为log2n，最坏为O(n)</span><br></pre></td></tr></table></figure>

<ul>
<li>逐点插入时，若先后插入的关键字有序，则会生成链条状的二叉排序树，此时树的深度最大，查找效率最低</li>
<li>二叉排序树删除某个结点再插入时；叶结点会插入原位置；非叶结点不会插入原位置</li>
</ul>
<h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 平衡因子：左高度-右高度，值为-1、0、1</span><br><span class="line">2. 插入：平衡二叉树的插入需要考虑平衡，旋转节点，包括LL、RR、LR、RL四种旋转方式</span><br><span class="line">3. 查找：平均查找长度为O(log2n);</span><br></pre></td></tr></table></figure>

<ul>
<li>平衡二叉树的结点数递推公式为0，1,2,1+n(h-1)+n(h-2),所以构造平衡二叉树需要1,2,4,7,12(五层),20(6层)…个结点</li>
<li>平衡二叉树删除某个结点再插入时，叶结点有可能插入原位置也有可能不会（是否要平衡）；非叶结点也不一定</li>
</ul>
<h3 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 带权路径长度：某结点的权值和根结点到该结点的路径长度之积(WPL)</span><br><span class="line">2. 哈夫曼树：带权路径长度最小</span><br><span class="line">3. 构造：选最小的两个节点作为新结点左右子树，新结点权值等于二者之和，再将新结点放入其中继续找最小的两个结点</span><br><span class="line">4. 前缀编码：没有一个编码是另一个编码的前缀</span><br><span class="line">5. 哈夫曼编码：通过哈夫曼树实现都是前缀编码且WPL最小</span><br></pre></td></tr></table></figure>

<ul>
<li>构造哈夫曼树时并没有限制是谁做左子树谁做右子树，因此构造的哈夫曼树不唯一</li>
<li>哈夫曼树完全不局限于二叉树,也存在于多叉树中,即度为m的哈夫曼树,也叫最优m叉树,严格m叉树（注意不是完全m叉树），构造方法则是每次选取m个数据</li>
<li>判断两个路径是否是同一个哈夫曼树需要考虑的是：出发分往两个不同子树时的权值之和是否等于上一步，即24,10和24,14可以是同一棵树，24,5和24,10就不是</li>
</ul>
<h1 id="6-图"><a href="#6-图" class="headerlink" title="6 图"></a>6 图</h1><h2 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">有向图：</span><br><span class="line">无向图：</span><br><span class="line">简单图：不存在重复边；不存在顶点到自身的边</span><br><span class="line">完全图：无向完全图，任意两个顶点间都存在边，边有n(n-1)&#x2F;2条；有向则要求两个顶点间有反向的两条边，因此需要n(n-1)条边</span><br><span class="line">子图：边和顶点都是子集，顶点相同的是生成子图</span><br><span class="line">连通图：任意两个顶点连通</span><br><span class="line">连通分量：无向图的极大连通子图</span><br><span class="line">强连通图：任意一对顶点都是强连通（双向都有路径）</span><br><span class="line">生成树：包含图中全部顶点的一个极小连通子图；非连通图的不同生成树构成了生成森林</span><br><span class="line">顶点的度：依附于顶点v的边的条数；</span><br><span class="line">顶点入度、出度</span><br><span class="line">边的权和网：权是权值，带权值的图称为带权图，也称网</span><br><span class="line">稠密图&#x2F;稀疏图：边数很多&#x2F;少的图，是相对而言的，一般E&lt;VlogV时视为稀疏图</span><br><span class="line">路径、路径长度、回路：由顶点和相邻顶点序偶构成的边所形成的的</span><br><span class="line">简单路径、简单回路：顶点不重复出现的路径；除起点不重复出现的回路</span><br><span class="line">距离：两个顶点间的最短路径长度，不存在路径则为无穷</span><br><span class="line">有向树：顶点的入度为0，其余顶点的入度均为1的有向图</span><br></pre></td></tr></table></figure>

<ul>
<li>数据结构中默认的有向图无向图都是简单图，即不考虑重复边和自身的边的情况</li>
<li>判断无向图是否有环：边数==大于等于==顶点数必定有环(n个顶点和n-1条边恰好可以连通无环，再多一条则有环)</li>
<li>若顶点是子集，边也是子集，构成的图==不一定==是子图！！子图必须是边子集中关联的点，点子集中关联的边也都在图中的情况</li>
<li>极大连通子图和极小连通子图：</li>
</ul>
<blockquote>
<p>1.连通图只有一个极大连通子图，就是它本身。（是唯一的） </p>
<p>2.非连通图有多个极大连通子图。（非连通图的极大连通子图叫做连通分量，每个分量都是一个连通图） </p>
<p>1.一个连通图的生成树是该连通图顶点集确定的极小连通子图。（同一个连通图可以有不同的生成树，所以生成树不是唯一的）（极小连通子图只存在于连通图中）<br>2.用边把极小连通子图中所有节点给连起来，若有n个节点，则有n-1条边。如下图生成树有6个节点，有5条边。<br>3.之所以称为极小是因为此时如果删除一条边，就无法构成生成树，也就是说给极小连通子图的每个边都是不可少的。</p>
</blockquote>
<ul>
<li>无向图中，所以顶点的度数之和为偶数</li>
<li>n个顶点无向图一定连通最少有多少条边：边数&gt;n*(n-1)/2+1(先保证n-1个顶点占用最多的边，即n(n-1)/2,此时再加一条边必定构成连通图)</li>
<li>n个顶点图是连通无向图、强连通有向图需要的条件：连通有向图需要满足单向有路径，只需要n-1条边；强连通有向图则需要来回都有路径，那只需要形成一个环即可，需要n条边</li>
</ul>
<h2 id="图的存储及基本操作"><a href="#图的存储及基本操作" class="headerlink" title="图的存储及基本操作"></a>图的存储及基本操作</h2><h3 id="邻接矩阵法"><a href="#邻接矩阵法" class="headerlink" title="邻接矩阵法"></a>邻接矩阵法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1顶点使用一维矩阵存储；边使用二维矩阵存储</span><br><span class="line">2.简单应用中可以直接用二维数组作为图的邻接矩阵</span><br><span class="line">3.无向图的邻接矩阵是对称矩阵，实际存储只需要存储上三角或者下三角矩阵的元素</span><br><span class="line">4.稠密图适合使用邻接矩阵存储</span><br></pre></td></tr></table></figure>

<ul>
<li>有向图的入度是第i列的非零元素之和，出度是第i行的非零元素之和</li>
</ul>
<h3 id="邻接表法"><a href="#邻接表法" class="headerlink" title="邻接表法"></a>邻接表法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.为每个顶点建立一个单链表，包括顶点和邻接点</span><br><span class="line">2.有向图建立邻接表时只存储出去的边</span><br><span class="line">3.读取临边时较快，但是确定两个顶点间是否存在边效率很低</span><br><span class="line">4.求解出度很便捷，求解入度必须遍历所有邻接表</span><br><span class="line">5.稀疏图适合使用邻接表存储</span><br></pre></td></tr></table></figure>

<ul>
<li>邻接矩阵和邻接表都是适用于有向图和无向图的</li>
<li>无向图采用邻接表法时，每条边存储==两次==</li>
<li>边表结点是指邻接表某顶点链表中存储边的结点</li>
<li>有向图用邻接表表示时，若要删除与某顶点v相关的所有边：先删除下标为v的顶点表的所有边，最多n-1条，复杂度为O(n);再扫描所有边表结点，删除所有顶点v的入边，对应复杂度为O(e);总时间复杂度为O(n+e)</li>
</ul>
<h3 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.有向图的一种链式存储结构；每条弧有一个结点，每个顶点也有一个结点</span><br><span class="line">2.弧结点有5个域：尾域tailvex(弧尾的位置)、头域headvex(弧头的位置)、链域(弧头相同的下一条弧)、链域tlink（弧尾相同的下一条弧）、info(该弧的相关信息)</span><br><span class="line">3.顶点结点有3个域：data(顶点相关的数据信息)、firstin&#x2F;fistout(以该顶点为弧头弧尾的第一个弧结点)、</span><br></pre></td></tr></table></figure>

<p><img src="https://www.hualigs.cn/image/60549bdf08830.jpg"></p>
<h3 id="邻接多重表"><a href="#邻接多重表" class="headerlink" title="邻接多重表"></a>邻接多重表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 无向图的另一种链式存储结构。</span><br><span class="line">2. 与十字链表相似，在邻接多重表中</span><br><span class="line">3.每条边用一个结点表示，结点由mark标志域(标记该条边是否被搜索过)；ivex和jvex为该边依附的两个顶点在图中的位置；ilink指向下一条依附于顶点ivex的边；jlink指向下一条依附于顶点jvex的边；info指向与边相关的各种信息的指针域</span><br><span class="line">4. 每个顶点也用一个结点表示，它由data(存储该顶点的相关信息)域和firstedge域(指示第一条依附于该顶点的边)组成</span><br></pre></td></tr></table></figure>



<h3 id="图的基本操作"><a href="#图的基本操作" class="headerlink" title="图的基本操作"></a>图的基本操作</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">图的基本操作是独立于图的存储结构的</span><br><span class="line">图的基本操作包括：判断是否存在边、列出邻接边、在图中插入顶点x、从图中删除顶点x、添加边。删除边、找到第一个邻接点、找到下一个邻接点、获取边对应的权值、</span><br></pre></td></tr></table></figure>



<h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><p>###广度优先搜索（BFS）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">类似于树的层序遍历；</span><br><span class="line">以v为起点，访问所有邻接点并将其入队，再出队并访问其未访问过的邻接点，直到所有点都被访问过；</span><br><span class="line">性能分析：必须借助于辅助队列，n个顶点均需入队一次，在最坏的情况下，空间复杂度为O(|V|)</span><br><span class="line">邻接表存储时时间复杂度为O(V+E);邻接矩阵存储事件复杂度为O(n2)</span><br><span class="line">求解单源最短路径问题：因为广度优先搜索总是按照距离由远及近来遍历图中每个顶点，非带权图的单源最短路径问题可以直接用广度优先的原理</span><br><span class="line">广度优先生成树：广度遍历过程中，可以得到广度优先生成树；邻接矩阵法有唯一的生成树；邻接表法生成树不唯一</span><br></pre></td></tr></table></figure>

<ul>
<li>生成树不是连通分量；生成树是极小连通子图，连通分量是极大连通子图</li>
</ul>
<p>###深度优先搜索（DFS）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">类似于树的先序遍历</span><br><span class="line">访问顶点v，继续访问与v邻接但未访问过的任意顶点，使用递归，直到不能继续向下访问时退回，若还有邻接点未访问过，则从该点开始继续搜索</span><br><span class="line">性能分析：借助一个递归工作栈，空间复杂度为O(|V|)</span><br><span class="line">邻接矩阵表示时，时间复杂度为O(n2)；邻接表表示时，时间复杂度为O(V+E)</span><br><span class="line">生成树和生成森林：取决于是否是连通图，基于邻接表存储的图的生成树不唯一</span><br></pre></td></tr></table></figure>

<h3 id="图的遍历和连通性"><a href="#图的遍历和连通性" class="headerlink" title="图的遍历和连通性"></a>图的遍历和连通性</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对无向图，若图连通，则从任意结点触发一次遍历即可访问所有结点；有向图强连通则可以访问所有结点，弱连通不可以</span><br><span class="line">判断有向图是否存在回路，可以使用深度优先算法</span><br></pre></td></tr></table></figure>

<h2 id="图的应用"><a href="#图的应用" class="headerlink" title="图的应用"></a>图的应用</h2><h3 id="6-4-1最小生成树"><a href="#6-4-1最小生成树" class="headerlink" title="6.4.1最小生成树"></a>6.4.1最小生成树</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一个连通图的最小生成树包含图的所有顶点，并且包含尽可能少的边。对于生成树来说，若砍去一条边则会变成非连通图；增加一条边则会形成回路</span><br><span class="line">最小生成树的边数为顶点数-1</span><br></pre></td></tr></table></figure>

<h4 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h4><p>类似于寻找图的最短路径的Dijkstra算法</p>
<p>从图中任取一顶点加入T，此时树中只有一个顶点，之后选择一个与当前T中顶点距离最近的顶点，并且将该顶点和相应的边加入T，每次操作后T中的顶点数和边数都增1；直到所有顶点都并入T，得到的T就是最小生成树</p>
<p>时间复杂度为O(|v|^2^),适用于求<strong>边稠密</strong>的图的最小生成树</p>
<h4 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h4><p>按权值底层选择合适的边来构造最小生成树</p>
<p>不断选取当前未被选取过而且权值最小的边，若该边依附的两个顶点在==不同==的连通分量上，则将此边加入T，否则舍弃此边选择下一条权值最小的边。直到T中所有顶点都在一个连通分量上</p>
<p>一般采用堆来存放边的集合，每次选择最小权值的边只需要O(log|E|)的时间；采用并查集的数据结构描述T，因而总复杂度为O(|E|log|E|)</p>
<p>适合于求解<strong>边稀疏而顶点较多</strong>的图</p>
<hr>
<p>理解以下几点：</p>
<ol>
<li>只要无向连通图中没有权值相同的边，则其最小生成树唯一</li>
<li>最小生成树的代价唯一</li>
<li>当带权连通图的任意一个环中所包含的边的权值均不相同时，最小生成树唯一</li>
</ol>
<h3 id="6-4-2最短路径"><a href="#6-4-2最短路径" class="headerlink" title="6.4.2最短路径"></a>6.4.2最短路径</h3><p>无权图可以使用广度优先搜索方法寻找最短路径</p>
<p>对于带权有向图最短路径问题一般分为两类：一类是单源最短路径，即求图中某一顶点到其他顶点的最短路径，可通过Dijkstra（迪杰斯特拉）算法求解；二是求每队顶点间的最短路径，可通过Floyd（弗洛伊德）算法来求解</p>
<p>####Dijkstra算法</p>
<p><img src="https://www.hualigs.cn/image/6055ca9eb0f8b.jpg"></p>
<blockquote>
<p>1.初始化dist数组值为dist[i]=i到顶点间路径的权值，无路径则为无穷</p>
<p>2.选出dist里的最小值，标记为已找到，将该最小值对应的结点指向的结点的路径进行更新(可能会产生更短的路径)</p>
<p>3.继续选出剩下的最小值，直到全部顶点已找到最短路径</p>
</blockquote>
<p>Dijkstra复杂度为O(|v|^2^);计算的是一个顶点到其他所有顶点的最短路径；不适用于带有负权值的情况</p>
<p>####Floyd算法</p>
<blockquote>
<p>1.初始化最短路径矩阵为有向图邻接矩阵</p>
<p>2.每次加入一个新的中间结点，计算加入这个结点后是否会获得更短的路径</p>
<p>3.最后一次计算就是它的最短路径矩阵</p>
</blockquote>
<p>时间复杂度为O(|v|^3^);计算的是所有顶点间的最短路径；允许负权值但是不允许包含带负权值的边组成的回路</p>
<hr>
<p>理解以下几点：</p>
<ol>
<li>最短路径一定是简单路径</li>
</ol>
<h3 id="6-4-3有向无环图描述表达式"><a href="#6-4-3有向无环图描述表达式" class="headerlink" title="6.4.3有向无环图描述表达式"></a>6.4.3有向无环图描述表达式</h3><p>有向无环图简称DAG图</p>
<p>从变量开始写，每个变量一个顶点，符号一个顶点，重复的舍去</p>
<h3 id="6-4-4拓扑排序"><a href="#6-4-4拓扑排序" class="headerlink" title="6.4.4拓扑排序"></a>6.4.4拓扑排序</h3><p>AOV网：若用DAG图表示一个工程，其顶点表示活动，有向边表示活动的先后顺序，则这种有向图称为顶点表示活动的网络，即为AOV网</p>
<p>拓扑排序条件：</p>
<ol>
<li>每个顶点仅出现一次</li>
<li>若A顶点出现在B顶点前面，则图中不存在从顶点B到顶点A的路径</li>
</ol>
<p>对AOV网进行拓扑排序：</p>
<ol>
<li>从AOV网中选择一个没有前驱的顶点并输出</li>
<li>从网中删除该顶点和所有以它为起点的有向边</li>
<li>重复1和2直到AOV网为空或者不存在无前驱的顶点为止；后一种情况说明有向图中必然有环</li>
</ol>
<p>时间复杂度为O(|V|+|E|)</p>
<p>深度优先遍历也可以实现拓扑排序</p>
<p>逆拓扑排序则是选择没有后继的的顶点输出并删除以它为终点的边；</p>
<hr>
<ol>
<li><p>若有向图存在环路，则一定不存在拓扑排序</p>
</li>
<li><p>在拓扑排序算法中为暂存入度为0的顶点，可以使用栈，也可以使用队列</p>
</li>
<li><p>若有向图没有拓扑排序，则说明该有向图含有顶点数大于1的强连通分量</p>
</li>
</ol>
<h3 id="6-5-5关键路径"><a href="#6-5-5关键路径" class="headerlink" title="6.5.5关键路径"></a>6.5.5关键路径</h3><p>顶点表示事件，有向边表示活动，边上的权值表示完成该活动的开销，称之为用边表示活动的网络，简称AOE网。</p>
<ol>
<li>只有某顶点代表的事情发生后，从该顶点出发的各有向边所代表的活动才能开始</li>
<li>只有在进入某顶点的各有向边所代表的活动都已经结束时，该顶点所代表的事件才能发生</li>
<li>仅存在一个入度为0的点，称为开始顶点（源点），表示整个工程的开始，仅存在一个出度为0 的点，称为结束顶点（汇点），表示工程结束</li>
<li>从源点到汇点的所有路径中，具有最大路径长度的路径称为关键路径，而把关键路径上的活动称为关键活动</li>
</ol>
<p>求关键路径算法：第一部是逆拓扑排序求其余顶点的最早发生时间(略)</p>
<p>注意：关键路径上所有活动都是关键活动，可以通过加快关键活动来缩短整个工程的工期，但是不能任意缩短关键活动，一旦缩短到一定的程度就会变成非关键活动；关键路径并不唯一，有多条时必须同时加快所有关键路径上的关键活动才能缩短工期</p>
<hr>
<p>注意：</p>
<ol>
<li>深度优先、拓扑排序、求关键路径都可以判断图中是否有环，最短路径不可以</li>
</ol>
<h1 id="7-查找"><a href="#7-查找" class="headerlink" title="7 查找"></a>7 查找</h1><h2 id="7-1-查找基本概念"><a href="#7-1-查找基本概念" class="headerlink" title="7.1 查找基本概念"></a>7.1 查找基本概念</h2><p>在数据集合中寻找满足某种条件的数据元素的过程称为查找</p>
<p>查找表：用于查找的数据集合，主要操作有：查找是否在表中，查找特定元素属性，插入元素；删除元素</p>
<p>静态查找表/动态查找表：只需要进行查找无需动态修改，包括顺序查找，折半查找，散列查找等；适合动态查找的查找方法有二叉排序树、散列查找等</p>
<p>关键字：数据元素中唯一标识该元素的某个数据项的值，使用基于关键字的查找，查找结果唯一</p>
<p>平均查找长度：所有查找过程中进行关键字的比较次数的平均值</p>
<h2 id="7-2-顺序查找和折半查找"><a href="#7-2-顺序查找和折半查找" class="headerlink" title="7.2 顺序查找和折半查找"></a>7.2 顺序查找和折半查找</h2><h3 id="7-2-1顺序查找"><a href="#7-2-1顺序查找" class="headerlink" title="7.2.1顺序查找"></a>7.2.1顺序查找</h3><p>顺序表的线性查找：从一端查找到另一端，逐一判断</p>
<p>####一般线性表的顺序查找</p>
<p>成功查找的平均查找长度n+1/2，失败查找的平均查找长度ASL=n+1</p>
<p>缺点：当n较大时，平均查找长度较大，效率低；优点是对数据元素的存储没有要求，顺序存储或链式存储皆可</p>
<h4 id="有序表的顺序查找"><a href="#有序表的顺序查找" class="headerlink" title="有序表的顺序查找"></a>有序表的顺序查找</h4><p>查找成功的平均查找长度和一般的一样，失败时效率更高（失败判断条件不同），顺序存储和链式存储都可以</p>
<h3 id="7-2-2折半查找"><a href="#7-2-2折半查找" class="headerlink" title="7.2.2折半查找"></a>7.2.2折半查找</h3><p>又称二分查找，仅适用于有序的顺序表</p>
<p>将key与表中间位置比较，相等则查找成功，不相等则只能在中间元素以外的前半部分或后半部分，然后在缩小的范围内继续进行同样的查找</p>
<p>折半查找的过程可以用二叉树描述，称为判定树。树中每个圆形结点表示一个记录，结点中的值表示该记录的关键字值；树中最下面的叶结点都是方形的，表示查找不成功的情况。判定树是一颗二叉平衡树。</p>
<p><img src="https://www.hualigs.cn/image/6056b740e0157.jpg"></p>
<p>查找成功的平均查找长度为</p>
<p>ASL=log<del>2</del>(n+1)-1</p>
<p>要求线性表具有随机存取的特性，因此仅适合于顺序存储结构，不适合于链式存储结构，且要求元素按关键字有序排列</p>
<ul>
<li>折半查找和二叉排序树不同，二叉排序树有可能形成查找复杂度的单链条形式，最坏情况查找长度为O(n);但是折半判定树一定是平衡的</li>
<li>判断折半查找的平均查找长度数值可以画出判定树后计算</li>
<li>判定树的中序排列是顺序的，判断是否是判定树可以中序从小到大填入数字，再判断是否符合规则</li>
</ul>
<h3 id="7-2-3分块查找"><a href="#7-2-3分块查找" class="headerlink" title="7.2.3分块查找"></a>7.2.3分块查找</h3><p>又称索引查找</p>
<p>将查找表分为若干子块。块内元素可以无序，但块之间有序。再建立一个索引表，索引表中每个元素含有各块的最大关键字和各块的第一个元素的地址，索引表按关键字有序排列。</p>
<p>查找过程：在索引表中确定待查记录所在的块，可以顺序查找或折半查找索引表；在块内顺序查找</p>
<p>长度为n查找表均匀分为b块，每块s个记录，在块内和索引表均顺序查找，平均查找长度为ASL=(b+1)/2+(s+1)/2,当s=根号n的时候，平均查找长度最短</p>
<p>若对索引表折半查找，平均查找长度为log<del>2</del>(n+1)+(s+1)/2</p>
<p>如果都可以折半查找，平均查找长度为log<del>2</del>(n+1)+log<del>2</del>(s+1)</p>
<h2 id="7-3-B树和B-树"><a href="#7-3-B树和B-树" class="headerlink" title="7.3 B树和B+树"></a>7.3 B树和B+树</h2><p>###7.3.1 B树及其基本操作</p>
<p>B树又称多路平衡查找树，B树中所有结点的孩子个数最大值称为B树的阶</p>
<ol>
<li>树中每个结点至多有m棵子树，即至多有m-1个关键字</li>
<li>若根结点不是终端结点，则==至少有两颗子树==</li>
<li>==除根结点外==的所有非叶结点至少有ceil(m/2)棵子树，即至少有ceil(m/2)-1个关键字</li>
<li>每个结点内部关键字从小到大排序，指针所指的结点中关键字全都大于指针头左侧的关键字，大于右侧的关键字</li>
<li>所有叶结点都出现在同一层次上，并且不带信息（实际上这些结点不存在，指向他们的指针为空）</li>
</ol>
<p><img src="https://www.hualigs.cn/image/605713af67fe2.jpg"></p>
<p><strong>B树的高度</strong></p>
<p>B树的高度不包括最后叶节点那层</p>
<p>h≥log<del>m</del>(n+1)   n为关键字数</p>
<p>h≤log<del>cel(m/2)</del>((n+1)/2)+1</p>
<p><strong>B树的查找</strong></p>
<p>B树的查找包括两个操作：在B树中查找结点，在结点内查找关键字</p>
<p><strong>B树的插入</strong></p>
<ol>
<li><p>定位：利用B树查找法，找出插入该关键字的最低层的某个非叶结点</p>
</li>
<li><p>插入：插入后的关键字小于m，可以直接插入；插入后关键字个数大于m-1时，必须对结点进行分裂。分裂方法是在插入key后的结点，从中间位置ceil(m/2)位置将其中关键字分为两部分，左部分放在原结点中，右部分关键字放在新结点中，中间位置的结点插入原结点的父结点。如果父亲也溢出，则继续分裂</p>
<p><img src="https://www.hualigs.cn/image/60570af34d62d.jpg"></p>
</li>
</ol>
<p><strong>B树的删除</strong></p>
<p>B树删除要保证结点中关键字个数≥ceil(m/2)-1  涉及结点的合并问题</p>
<p>当被删关键字不在终端（最底层非叶结点）时，可以用k的前驱p来代替k，然后考虑在终端结点中删除p</p>
<p>在终端结点时删除有以下三种情况：</p>
<ol>
<li>直接删除。如果被删除关键字所在结点的关键字个数大于ceil(m/2),则直接删除</li>
<li>兄弟够借。删除后不满足条件，而兄弟够借，则调整左右兄弟节点及其双亲以达到平衡</li>
<li>兄弟不够借。则考虑将双亲节点调整到兄弟上去以满足要求。</li>
</ol>
<p>合并时双亲节点关键字会减少，如果减少过度就继续执行向上合并，如果双亲是根结点且关键字个数减少为0，则删除根结点，合并后的结点成为根结点。</p>
<ul>
<li>一定要注意根结点的特别性质，在计算最少关键字等时需要考虑根结点，它的关键字最少为1，子树至少为2</li>
</ul>
<h3 id="7-3-2-B-树"><a href="#7-3-2-B-树" class="headerlink" title="7.3.2 B+树"></a>7.3.2 B+树</h3><ol>
<li>具有n个关键字的结点含有n+1棵子树</li>
<li>叶结点包含信息，所有非叶结点仅起索引作用，非叶结点中每个索引项只含有对应子树的最大关键字和指向该子树的指针</li>
<li>每次查找都是一条从根结点到叶结点的路径</li>
</ol>
<p><img src="https://www.hualigs.cn/image/6057136a28298.jpg"></p>
<ul>
<li>B+树不同于B树的特点之一是支持顺序查找，因为叶结点包含了全部的关键字信息，且叶节点本身依关键字从小到大顺序链接，而B树不支持顺序查找</li>
</ul>
<h2 id="7-4-散列表"><a href="#7-4-散列表" class="headerlink" title="7.4 散列表"></a>7.4 散列表</h2><h3 id="7-4-1-散列表基本概念"><a href="#7-4-1-散列表基本概念" class="headerlink" title="7.4.1 散列表基本概念"></a>7.4.1 散列表基本概念</h3><p>散列函数：一个把查找表中关键字映射成该关键字对应的地址的函数，即为Hash(key)=Addr</p>
<p>散列函数可能把不同关键字映射到同一地址，称为冲突，这些碰撞的关键字称为同义词</p>
<p>散列表：根据关键字而直接进行访问的数据结构。建立了关键字和存储地址之间的一种直接影射关系</p>
<p>理想情况下，对散列表进行查找的时间复杂度为O(1)</p>
<h3 id="7-4-2-散列函数的构造方法"><a href="#7-4-2-散列函数的构造方法" class="headerlink" title="7.4.2 散列函数的构造方法"></a>7.4.2 散列函数的构造方法</h3><p>构造散列函数，必须注意以下几点：</p>
<ol>
<li>散列函数的定义域必须包含全部需要存储的关键字，而值域的范围则依赖于散列表的大小或地址范围。</li>
<li>散列函数计算出来的地址应该能等概率、均匀分布在地址空间</li>
<li>应尽量简单，复杂度低</li>
</ol>
<p><strong>直接定址法</strong></p>
<p>H(key)=key或H(key)=a*key+b;</p>
<p>适用于关键字基本连续的方法</p>
<p><strong>除留取余法</strong></p>
<p>H(key)=key%p是最简单最常用的方法</p>
<p><strong>数字分析法</strong></p>
<p>选取数码分布较为均匀的若干位作为散列地址</p>
<p><strong>平方取中法</strong></p>
<p>取平方值的中间几位作为散列地址，这种方法得到的散列地址分布较为均匀</p>
<p>适用于关键字的每位取值都不够均匀或均小于散列地址所需要的位数</p>
<p>###7.4.3 处理冲突的方法</p>
<p><strong>开放定址法</strong></p>
<p>H<del>i</del>=(H(key)+d<del>i</del>)%m</p>
<ol>
<li>当d<del>i</del>等于0,1,2，……k，称为<em>线性探测法</em> ，冲突时顺序查找下一个地址直到找到下一个空闲单元，可能出现堆积方法</li>
<li>当d<del>i</del>等于0^2^,1^2^,-1^2^,……,k^2^,-k^2^时，称为<em>平方探测法</em>，其中k≤m/2,散列表长度必须是一个可以表示成4*k+3的素数，又称二次探测法。缺点是不能探测到散列表上所以单元</li>
<li>当d=hash<del>2</del>(k)时，称为<em>再散列法</em></li>
<li>d<del>i</del>等于伪随机数序列时，称为<em>伪随机序列法</em></li>
</ol>
<p>拉链法(链接法)</p>
<p>把所有同义词存储在一个线性链表上，适用于经常插入删除的情况</p>
<h3 id="7-4-4-散列查找及性能分析"><a href="#7-4-4-散列查找及性能分析" class="headerlink" title="7.4.4 散列查找及性能分析"></a>7.4.4 散列查找及性能分析</h3><p>计算出散列地址后，查找该地址后发现不相等，则计算下一个散列地址，不断循环，若找到空地址则表示查找失败，找到相同的则查找成功</p>
<p>装填因子α：定义为一个表的装满程度，即α=表中记录数n/散列表长度m</p>
<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="8-1排序的基本概念"><a href="#8-1排序的基本概念" class="headerlink" title="8.1排序的基本概念"></a>8.1排序的基本概念</h2><p>算法的稳定性：如果两个相等的元素排序前和排序后顺序不变，则称这个算法是稳定的，否则是不稳定的</p>
<p>排序算法根据元素是否完全在内存中，可以分为两类：①内部排序②外部排序，排序器件元素无法同时存在在内存中，必须在排序的过程中不断内外移动</p>
<p>一般情况下，内部排序算法执行过程中都要进行两种操作:比较和移动</p>
<p>对任意n个关键字进行基于比较的排序，则至少需要进行ceil(log<del>2</del>(n!))次比较</p>
<h2 id="8-2插入排序"><a href="#8-2插入排序" class="headerlink" title="8.2插入排序"></a>8.2插入排序</h2><p>基本思想是将待排序的记录按关键字大小插入前面已经排好序的子序列，直到全部记录插入完成</p>
<h3 id="8-2-1直接插入排序"><a href="#8-2-1直接插入排序" class="headerlink" title="8.2.1直接插入排序"></a>8.2.1直接插入排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertionSort</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;n; j++)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i]&lt;A[i<span class="number">-1</span>])&#123;<span class="comment">//如果比前驱元素大则不需要更换顺序</span></span><br><span class="line">            A[<span class="number">0</span>]=A[i];<span class="comment">//哨兵，A[0]不存放元素</span></span><br><span class="line">            <span class="keyword">for</span>(j=i<span class="number">-1</span>;A[<span class="number">0</span>]&lt;A[j];--j)&#123;</span><br><span class="line">                A[j+<span class="number">1</span>]=A[j];<span class="comment">//元素后移让出位置</span></span><br><span class="line">            A[j+<span class="number">1</span>]=A[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>空间效率：O(1)</p>
<p>时间效率：在排序过程中，插入元素的操作进行了n-1趟，最好情况复杂度为O(n),最坏为∑i (i=2~n)</p>
<p>平均复杂度为O(n^2^)</p>
<p>稳定性：稳定</p>
<p>适用性：适用于顺序存储和链式存储的线性表，为链式存储时可以从前往后查找指定元素的位置</p>
<p>链表插入排序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">insertionSortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* newList=<span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">while</span>(head)&#123;</span><br><span class="line">        ListNode *p=newList;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;next &amp;&amp; p-&gt;next-&gt;val&lt;head-&gt;val) p=p-&gt;next;<span class="comment">//从前往后移动到待插入的位置</span></span><br><span class="line">        ListNode *temp=head;</span><br><span class="line">        head=head-&gt;next;</span><br><span class="line">        temp-&gt;next=p-&gt;next;</span><br><span class="line">        p-&gt;next=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newList-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="8-2-2-折半插入排序"><a href="#8-2-2-折半插入排序" class="headerlink" title="8.2.2 折半插入排序"></a>8.2.2 折半插入排序</h3><p>先折半查找出元素的待插入位置，然后统一的移动待插入位置之后的元素</p>
<p>仅仅减少了比较元素的次数，但元素的移动次数未改变，复杂度仍未O(n^2^)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="keyword">int</span> *A,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,low,high,mid;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        A[<span class="number">0</span>]=A[i];</span><br><span class="line">        low=<span class="number">1</span>;high=i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;=high)&#123;<span class="comment">//折半查找</span></span><br><span class="line">            mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(mid&gt;A[<span class="number">0</span>]) high=mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> low=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;=high+<span class="number">1</span>;--j)<span class="comment">//插入</span></span><br><span class="line">            A[j+<span class="number">1</span>]=A[j];</span><br><span class="line">        A[high+<span class="number">1</span>]=A[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-2-3希尔排序"><a href="#8-2-3希尔排序" class="headerlink" title="8.2.3希尔排序"></a>8.2.3希尔排序</h3><p>又称缩小增量排序，先将待排序表分割称为若干子表，即把相隔某个增量的记录组成一个子表，对各个子表进行直接插入排序，待子表都基本有序后，再对全体进行一次直接插入排序</p>
<p>空间复杂度O(1)</p>
<p>时间复杂度最坏情况O(n^2^)</p>
<p>稳定性：不稳定</p>
<p>适用性：仅适用于线性表为顺序存储的情况</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(ElemType A[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> dk=n/<span class="number">2</span>;dk&gt;=<span class="number">1</span>;dk=dk/<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=dk+<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            <span class="keyword">if</span>(A[i]&lt;A[i-dk])&#123;</span><br><span class="line">                A[<span class="number">0</span>]=A[i];</span><br><span class="line">                <span class="keyword">for</span>(j=i-dk;j&gt;<span class="number">0</span> &amp;&amp; A[<span class="number">0</span>]&lt;A[j];j-=dk)</span><br><span class="line">                    A[j+dk]=A[j];</span><br><span class="line">                A[j+dk]=A[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-3交换排序"><a href="#8-3交换排序" class="headerlink" title="8.3交换排序"></a>8.3交换排序</h2><p>通过比较结果对换两个元素的位置来实现排序</p>
<h3 id="8-3-1冒泡排序"><a href="#8-3-1冒泡排序" class="headerlink" title="8.3.1冒泡排序"></a>8.3.1冒泡排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span> *A,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        flag=<span class="literal">false</span>;<span class="comment">//设置标志位，当没有进行交换标志已经排序完毕直接退出</span></span><br><span class="line">        flor(j=n<span class="number">-1</span>;j&gt;i;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[j<span class="number">-1</span>]&gt;A[j])&#123;</span><br><span class="line">                swap(A[j<span class="number">-1</span>],A[j]);</span><br><span class="line">                flag=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>空间复杂度：O(1)</p>
<p>时间复杂度：O(n^2^)</p>
<p>稳定性：稳定</p>
<h3 id="8-3-2快速排序"><a href="#8-3-2快速排序" class="headerlink" title="8.3.2快速排序"></a>8.3.2快速排序</h3><p>基于分治法的思想，设置一个基准元素，通过一趟排序将待排序表划分为两部分，一半小于基准元素，一半大于，称为一次划分，递归执行直到每部分只有一个元素</p>
<p>通常取首元素为枢轴元素</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span> <span class="params">(<span class="keyword">int</span> *A,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low&lt;high)&#123;</span><br><span class="line">        <span class="keyword">int</span> pivotpos=Partition(A,low,high);</span><br><span class="line">        QucikSort(A,low,pivotpos<span class="number">-1</span>);</span><br><span class="line">        QuickSort(A,pivotpos+<span class="number">1</span>,high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> *A,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot=A[low];</span><br><span class="line">    <span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high &amp;&amp; A[high]&gt;=pivot) --high;<span class="comment">//左滑，指针滑动到第一个小于枢轴元素的值</span></span><br><span class="line">        A[low]=A[high];</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high &amp;&amp; A[low]&lt;=pivot) ++low;<span class="comment">//右滑，指针滑动到第一个大于枢轴元素的值</span></span><br><span class="line">        A[high]=A[low];</span><br><span class="line">    &#125;</span><br><span class="line">    A[low]=pivot;<span class="comment">//此时已经划分完毕，low=high在某一位置，让该点为枢轴元素</span></span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>空间效率：递归需要借助一个工作栈来保存每层递归调用的必要信息，其容量应与递归调用的最大深度一致，最好情况为O(log<del>2</del>n),最坏情况为O(n),平均情况下，栈的深度为O(log<del>2</del>n)</p>
<p>时间效率：理想情况时间复杂度为O(nlog<del>2</del>n), 最坏情况为O(n^2^),平均运行时间更接近与最佳情况；快速排序是所有内部排序方法中平均性能最优的排序算法</p>
<p>提高效率方法：选取尽量可以将数据中分的枢轴元素，如序列的头尾及中间选取三个元素，再取这三个元素的中间值作为最终的枢轴元素；或随机的从当前表中选取枢轴元素</p>
<p>稳定性：不稳定</p>
<ul>
<li>快速排序当每次枢轴都把表等分为长度相近的两个子表时，速度是最快的；当表本身已经有序或逆序时，速度最慢</li>
<li>快速排序第二趟后要注意4个子表是否按相同的顺序排列</li>
</ul>
<h2 id="8-4-选择排序"><a href="#8-4-选择排序" class="headerlink" title="8.4 选择排序"></a>8.4 选择排序</h2><p>每一趟在剩下待排序元素中选取关键字最小的元素。</p>
<h3 id="8-4-1-简单选择排序"><a href="#8-4-1-简单选择排序" class="headerlink" title="8.4.1 简单选择排序"></a>8.4.1 简单选择排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(<span class="keyword">int</span> *A,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        min=i;</span><br><span class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">            <span class="keyword">if</span>(A[j]&lt;A[min]) min=j;<span class="comment">//选出最小元素位置</span></span><br><span class="line">        <span class="keyword">if</span>(min!=i) swap(A[i],A[min]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>空间效率：O(1)</p>
<p>时间效率：O(n^2^)</p>
<p>稳定性：不稳定</p>
<ul>
<li>简单选择排序算法的比较次数和移动次数分别为O(n^2^)和O(n)</li>
<li>选择排序算法的比较次数与序列初始状态无关</li>
</ul>
<h3 id="8-4-2-堆排序"><a href="#8-4-2-堆排序" class="headerlink" title="8.4.2 堆排序"></a>8.4.2 堆排序</h3><p>堆满足L(i)&gt;=L(2i)且L(i)&gt;=L(2i+1)  大根堆(大顶堆)   或  L(i)&lt;=L(2i)且L(i)&lt;=L(2i+1) 小根堆(小顶堆)</p>
<p>构造时就依次倒序对结点进行筛选，看是否满足条件，将最大的称为父结点；删除元素时就让下面的元素补上再进行调整</p>
<p>建立大根堆：</p>
<p>从最后一个非叶元素开始调整堆排序；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildManHeap</span><span class="params">(<span class="keyword">int</span> *A,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=len/<span class="number">2</span>;i&lt;<span class="number">0</span>;i--)</span><br><span class="line">        HeadAdjust(A,i,len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeadAdjust</span><span class="params">(<span class="keyword">int</span> *A,<span class="keyword">int</span> k,<span class="keyword">int</span> len)</span></span>&#123;<span class="comment">//实现输入的根结点的子树形成堆</span></span><br><span class="line">    A[<span class="number">0</span>]=A[k];<span class="comment">//暂存输入的根结点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>*k;i&lt;=len;i*=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;len &amp;&amp; A[i]&lt;A[i+<span class="number">1</span>])</span><br><span class="line">            i++;<span class="comment">//筛选较大的子结点</span></span><br><span class="line">        <span class="keyword">if</span>(A[<span class="number">0</span>]&gt;A[i]) <span class="keyword">break</span>; <span class="comment">//符合堆排序，不用操作直接退出</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            A[k]=A[i];<span class="comment">//更换根结点</span></span><br><span class="line">            k=i;<span class="comment">//继续筛选</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    A[i]=A[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调整的时间与树高有关，为O(h);建立堆的时间复杂度为O(n)</p>
<p>堆排序算法：</p>
<p>参考<a href="https://blog.csdn.net/qq_36186690/article/details/82505569">https://blog.csdn.net/qq_36186690/article/details/82505569</a></p>
<p><strong>a.将无需序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;</strong></p>
<p><strong>b.将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端;</strong></p>
<p><strong>c.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span> *A,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    BuildMaxHeap(A,len);<span class="comment">//建立堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=len;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">        swap(A[i],A[<span class="number">1</span>]);<span class="comment">//交换到堆顶</span></span><br><span class="line">        HeadAdjust(A,<span class="number">1</span>,i<span class="number">-1</span>);<span class="comment">//调整</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>堆插入元素时，先将新结点放在堆的末端，再向上调整</p>
<p>空间复杂度：O(1)</p>
<p>时间复杂度：建堆时间为O(n),之后有n-1次向下调整操作，每次调整复杂度为O(h),最好最坏平均时间复杂度都为O(nlog<del>2</del>n)</p>
<p>稳定性：不稳定</p>
<h2 id="8-5-归并排序和基数排序"><a href="#8-5-归并排序和基数排序" class="headerlink" title="8.5 归并排序和基数排序"></a>8.5 归并排序和基数排序</h2><h3 id="8-5-1-归并排序"><a href="#8-5-1-归并排序" class="headerlink" title="8.5.1 归并排序"></a>8.5.1 归并排序</h3><p>将两个或两个以上的有序表组合成一个新的有序表</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *B=(<span class="keyword">int</span> *)<span class="built_in">malloc</span>((n+<span class="number">1</span>)*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> *A,<span class="keyword">int</span> low,<span class="keyword">int</span> mid,<span class="keyword">int</span> high)</span></span>&#123;<span class="comment">//实现将两个有序表合成一个</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=low;k&lt;=high;k++)</span><br><span class="line">        B[k]=A[k];  <span class="comment">//复制表A到B</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=low,j=mid+<span class="number">1</span>,k=i;i&lt;=mid&amp;&amp;j&lt;=high;k++)&#123;</span><br><span class="line">        <span class="comment">//不断比较两个子表中的第一位B[i]B[j]，选出最小值，填入表A,只要有一个表检测完就结束</span></span><br><span class="line">        <span class="keyword">if</span>(B[i]&lt;=B[j])</span><br><span class="line">            A[k]=B[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            A[k]=B[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid)  A[k++]=B[i++]; </span><br><span class="line">    <span class="keyword">while</span>(j&lt;=high) A[k++]=B[j++];</span><br><span class="line">    <span class="comment">//没检测完的表说明值全部大于检测完成的表，直接复制进去即可</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>归并排序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span> *A,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low&lt;high)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">        MergeSort(A,low,mid);<span class="comment">//分别对左右子序列排序再合并</span></span><br><span class="line">        MergeSort(A,mid+<span class="number">1</span>,high);</span><br><span class="line">        Merge(A,low,mid,high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>空间效率：O(n)</p>
<p>时间效率：每趟归并复杂度为O(n),共需进行ceil(log<del>2</del>n)次归并,事件复杂度为O(nlog<del>2</del>n)</p>
<p>稳定性：稳定</p>
<ul>
<li>归并排序的比较次数与初始状态无关</li>
<li>外部排序通常用归并排序法，如对很大的数据文件进行排序</li>
</ul>
<h3 id="8-5-2-基数排序"><a href="#8-5-2-基数排序" class="headerlink" title="8.5.2 基数排序"></a>8.5.2 基数排序</h3><p>借助多关键字排序的思想对单逻辑关键字进行排序的方法</p>
<p>实现多关键字排序通常有两种方法：一种是<em>最高位优先（</em>MSD）算法，按关键字位权重递减依次逐层划分成若干更小的子序列；第二种是<em>最低位优先</em>(LSD)算法,按关键字权重底层一次排序</p>
<p>空间效率：O(r)  r是基数</p>
<p>时间效率：O(d(n+r))</p>
<ul>
<li>基数排序第一趟排序是按照个位数排序的，第二趟按十位数大小排序</li>
</ul>
<h2 id="8-6各种内部排序算法的比较及应用"><a href="#8-6各种内部排序算法的比较及应用" class="headerlink" title="8.6各种内部排序算法的比较及应用"></a>8.6各种内部排序算法的比较及应用</h2><table>
<thead>
<tr>
<th>排序方法</th>
<th>最好情况</th>
<th>平均情况</th>
<th>最坏情况</th>
<th>空间复杂度</th>
<th>是否稳定</th>
</tr>
</thead>
<tbody><tr>
<td>直接插入排序</td>
<td>O(n)</td>
<td>O(n^2^)</td>
<td>O(n^2^)</td>
<td>O(1)</td>
<td>是</td>
</tr>
<tr>
<td>冒泡排序</td>
<td>O(n)</td>
<td>O(n^2^)</td>
<td>O(n^2^)</td>
<td>O(1)</td>
<td>是</td>
</tr>
<tr>
<td>简单选择排序</td>
<td>O(n^2^)</td>
<td>O(n^2^)</td>
<td>O(n^2^)</td>
<td>O(1)</td>
<td>否</td>
</tr>
<tr>
<td>希尔排序</td>
<td></td>
<td></td>
<td></td>
<td>O(1)</td>
<td>否</td>
</tr>
<tr>
<td>快速排序</td>
<td>O(nlog<del>2</del>n)</td>
<td>O(nlog<del>2</del>n)</td>
<td>O(n^2^)</td>
<td>O(nlog<del>2</del>n)</td>
<td>否</td>
</tr>
<tr>
<td>堆排序</td>
<td>O(nlog<del>2</del>n)</td>
<td>O(nlog<del>2</del>n)</td>
<td>O(nlog<del>2</del>n)</td>
<td>O(1)</td>
<td>否</td>
</tr>
<tr>
<td>2路归并排序</td>
<td>O(nlog<del>2</del>n)</td>
<td>O(nlog<del>2</del>n)</td>
<td>O(nlog<del>2</del>n)</td>
<td>O(n)</td>
<td>是</td>
</tr>
<tr>
<td>基数排序</td>
<td>O(d(n+r))</td>
<td>O(d(n+r))</td>
<td>O(d(n+r))</td>
<td>O(r)</td>
<td>是</td>
</tr>
</tbody></table>
<ul>
<li>n较小时，一般用直接插入排序或者简单选择排序，直接插入排序移动次数较多，因此如果记录本身信息量较大，选择简单选择排序</li>
<li>若文件初始状态已按关键字基本有序，则选择直接插入或冒泡排序</li>
<li>若n较大，采用时间复杂度较低的快速、堆、归并。要求稳定选归并，随机分布选快速，少空间复杂度且无最坏情况选堆</li>
<li>冒泡排序、堆排序每次处理都能产生当前的最大值或最小值，快速排序每次处理都能确定一个元素的最终位置</li>
<li>在序列中结点已经接近有序的情况下，直接插入排序和冒泡排序复杂度会变低为O(n),但是快速排序复杂度会升高为O(n^2^)</li>
<li>堆在用于查找时查找效率较低，是用于排序的数据结构</li>
<li>将顺序存储改为链式存储，则希尔排序、堆排序算法的时间效率会降低</li>
</ul>
<h2 id="8-7-外部排序"><a href="#8-7-外部排序" class="headerlink" title="8.7 外部排序"></a>8.7 外部排序</h2><ol>
<li>外部排序指待排序文件较大，文件一次放不下，需存放在外存的文件的排序</li>
<li>为减少平衡归并中外存读写次数所采取的方法：增大归并路数和减少归并段个数</li>
<li>利用败者树增大归并路数</li>
<li>利用置换-选择排序增大归并段长度来减少归并段个数</li>
<li>由长度不等的归并段，进行多路平衡归并，需要构造最佳归并树。</li>
</ol>
<p>​        外部排序实现两两归并时，由于不可能将两个有序段及归并结果同时放在内存中，因此需要不停将数据读出、写入磁盘：外部排序的总时间=内部排序所需时间+外存信息读写的时间+内部归并所需时间</p>
<p>​    增大归并路数k能减少归并趟数S，进而减少I/O次数，然而增加归并路数k时，内部归并的时间将增加；S趟共需要比较次数S(n-1)(k-1)=ceil(log<del>2</del>r)(n-1)(k-1)/ceil(log<del>2</del>k)</p>
<p>​    因此内部归并时间随k增长而增长，引入了<strong>败者树</strong></p>
<p>​    用内部结点来记忆左右子树中的失败者，而让胜者继续往上进行比较，一直到根结点；大的为失败者，小的为胜利者，则根结点指向的数为最小数</p>
<p>​    利用这种方法k路归并的比较次数为(n-1)ceil(log<del>2</del>r)</p>
<p>​    但是归并路数k不是越大越好。归并路数k增大时，响应需要增加输入缓冲区的个数。若可供使用的内存空间不变，需要减少每个缓冲区的容量。</p>
<p>​    在做m路平衡归并需要2m个输入缓冲区和2个输出缓冲区</p>
<p><strong>置换-选择排序</strong></p>
<p>用于产生更长的初始归并段</p>
<p>数据读入WA，将其中最小关键字存入MINIMAX并输出到FO中，再从其中选出比MINIMAX记录大的最小关键字读入FO，直到选不出比他们大的关键字，即得到一个初始归并段；直到WA为空即得到全部初始归并段</p>
<p>其中，WA中选择MINIMAX主要采用败者树实现</p>
<p><strong>最佳归并树</strong></p>
<p>置换选择排序后得到的初始归并段长度是不等的，如何组织长度不等的初始归并段的归并排序，使得IO次数最少</p>
<p>将记录最少的归并段最先归并，最多的归并段最晚归并，就可以建立总IO次数最少的最佳归并树</p>
<p>若初始归并段不足以构成一棵严格k叉树时，需要添加长度为0的虚段，权为0的叶子应离树根最远</p>
<ul>
<li>最佳归并树在外部排序中的作用是设计m路归并排序的优化方案</li>
<li>构造严格的k叉树需要增加(n<del>0</del>-1)%(k-1)个叶结点</li>
</ul>
]]></content>
      <categories>
        <category>408</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
</search>
